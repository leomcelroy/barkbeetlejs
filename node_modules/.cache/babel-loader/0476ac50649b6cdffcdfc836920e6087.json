{"ast":null,"code":"var _classCallCheck = require(\"/Users/leomcelroy/Desktop/barkbeetle_js/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/leomcelroy/Desktop/barkbeetle_js/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require('../utils/strUtils'),\n    removeQuotes = _require.removeQuotes,\n    splitNotInBrackets = _require.splitNotInBrackets;\n\nvar regex = require('../utils/regex');\n\nvar CssQuery =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  function CssQuery(query) {\n    _classCallCheck(this, CssQuery);\n\n    if (CssQuery.cache.has(query)) {\n      this.queries = CssQuery.cache.get(query);\n      return;\n    }\n\n    var queries = splitNotInBrackets(query, ',');\n    queries = queries.map(function (query) {\n      var roundBrackets = 0;\n      var squareBrackets = 0; // this is the same as above but easier\n\n      query.replace(/[()[]>~+]/g, function (ch) {\n        if (ch === '(') ++roundBrackets;else if (ch === ')') --roundBrackets;else if (ch === '[') ++squareBrackets;else if (ch === ']') --squareBrackets;\n        if (squareBrackets || roundBrackets) return ch;\n        return ' ' + ch + ' ';\n      }); // split at space and remove empty results\n\n      query = splitNotInBrackets(query, ' ').filter(function (el) {\n        return !!el.length;\n      });\n      var pairs = [];\n      var relation = '%'; // generate querynode relation tuples\n\n      for (var i = 0, il = query.length; i < il; ++i) {\n        if ('>~+%'.indexOf(query[i]) > -1) {\n          relation = query[i];\n          continue;\n        }\n\n        pairs.push([relation, query[i]]);\n        relation = '%';\n      }\n\n      return pairs;\n    });\n    this.queries = queries; // to prevent memory leaks we have to manage our cache.\n    // we delete everything which is older than 50 entries\n\n    if (CssQuery.cacheKeys.length > 50) {\n      CssQuery.cache.delete(CssQuery.cacheKeys.shift());\n    }\n\n    CssQuery.cache.set(query, queries);\n    CssQuery.cacheKeys.push(query);\n  }\n\n  _createClass(CssQuery, [{\n    key: \"matches\",\n    value: function matches(node) {\n      for (var i = this.queries.length; i--;) {\n        if (this.matchHelper(this.queries[i], node)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"matchHelper\",\n    value: function matchHelper(query, node) {\n      query = query.slice();\n      var last = query.pop();\n\n      if (!new CssQueryNode(last[1]).matches(node)) {\n        return false;\n      }\n\n      if (!query.length) return true;\n      if (last[0] === ',') return true;\n\n      if (last[0] === '+') {\n        return !!node.previousSibling && this.matchHelper(query, node.previousSibling);\n      }\n\n      if (last[0] === '>') {\n        return !!node.parentNode && this.matchHelper(query, node.parentNode);\n      }\n\n      if (last[0] === '~') {\n        while (node = node.previousSibling) {\n          if (this.matchHelper(query, node)) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n\n      if (last[0] === '%') {\n        while (node = node.parentNode) {\n          if (this.matchHelper(query, node)) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n    }\n  }]);\n\n  return CssQuery;\n}();\n\nCssQuery.cache = new Map();\nCssQuery.cacheKeys = []; // check if [node] is the [nth] child of [arr] where nth can also be a formula\n\nvar nth = function nth(node, arr, _nth) {\n  if (_nth === 'even') _nth = '2n';else if (_nth === 'odd') _nth = '2n+1'; // check for eval chars\n\n  if (/[^\\d\\-n+*/]+/.test(_nth)) return false;\n  _nth = _nth.replace('n', '*n'); // eval nth to get the index\n\n  for (var i, n = 0, nl = arr.length; n < nl; ++n) {\n    /* eslint no-eval: off */\n    i = eval(_nth);\n    if (i > nl) break;\n    if (arr[i - 1] === node) return true;\n  }\n\n  return false;\n};\n\nvar lower = function lower(a) {\n  return a.toLowerCase();\n}; // checks if a and b are equal. Is insensitive when i is true\n\n\nvar eq = function eq(a, b, i) {\n  return i ? lower(a) === lower(b) : a === b;\n}; // [i] (prebound) is true if insensitive matching is required\n// [a] (prebound) is the value the attr is compared to\n// [b] (passed)   is the value of the attribute\n\n\nvar attributeMatcher = {\n  '=': function _(i, a, b) {\n    return eq(a, b, i);\n  },\n  '~=': function _(i, a, b) {\n    return b.split(regex.delimiter).filter(function (el) {\n      return eq(el, a, i);\n    }).length > 0;\n  },\n  '|=': function _(i, a, b) {\n    return eq(b.split(regex.delimiter)[0], a, i);\n  },\n  '^=': function _(i, a, b) {\n    return i ? lower(b).startsWith(lower(a)) : b.startsWith(a);\n  },\n  '$=': function $(i, a, b) {\n    return i ? lower(b).endsWith(lower(a)) : b.endsWith(a);\n  },\n  '*=': function _(i, a, b) {\n    return i ? lower(b).includes(lower(a)) : b.includes(a);\n  },\n  '*': function _(i, a, b) {\n    return b != null;\n  } // [a] (prebound) [a]rgument of the pseudo selector\n  // [n] (passed)   [n]ode\n\n};\nvar pseudoMatcher = {\n  'first-child': function firstChild(a, n) {\n    return n.parentNode && n.parentNode.firstChild === n;\n  },\n  'last-child': function lastChild(a, n) {\n    return n.parentNode && n.parentNode.lastChild === n;\n  },\n  'nth-child': function nthChild(a, n) {\n    return n.parentNode && nth(n, n.parentNode.childNodes, a);\n  },\n  'nth-last-child': function nthLastChild(a, n) {\n    return n.parentNode && nth(n, n.parentNode.childNodes.slice().reverse(), a);\n  },\n  'first-of-type': function firstOfType(a, n) {\n    return n.parentNode && n.parentNode.childNodes.filter(function (el) {\n      return el.nodeName === n.nodeName;\n    })[0] === n;\n  },\n  'last-of-type': function lastOfType(a, n) {\n    return n.parentNode && n.parentNode.childNodes.filter(function (el) {\n      return el.nodeName === n.nodeName;\n    }).pop() === n;\n  },\n  'nth-of-type': function nthOfType(a, n) {\n    return n.parentNode && nth(n, n.parentNode.childNodes.filter(function (el) {\n      return el.nodeName === n.nodeName;\n    }), a);\n  },\n  'nth-last-of-type': function nthLastOfType(a, n) {\n    return n.parentNode && nth(n, n.parentNode.childNodes.filter(function (el) {\n      return el.nodeName === n.nodeName;\n    }).reverse(), a);\n  },\n  'only-child': function onlyChild(a, n) {\n    return n.parentNode && n.parentNode.childNodes.length === 1;\n  },\n  'only-of-type': function onlyOfType(a, n) {\n    return n.parentNode && n.parentNode.childNodes.filter(function (el) {\n      return el.nodeName === n.nodeName;\n    }).length === 1;\n  },\n  'root': function root(a, n) {\n    return n.ownerDocument.documentElement === n;\n  },\n  'not': function not(a, n) {\n    return !new CssQuery(a).matches(n);\n  },\n  'matches': function matches(a, n) {\n    return new CssQuery(a).matches(n);\n  }\n};\n\nvar CssQueryNode =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  function CssQueryNode(node) {\n    _classCallCheck(this, CssQueryNode);\n\n    this.tag = '';\n    this.id = '';\n    this.classList = [];\n    this.attrs = [];\n    this.pseudo = []; // match the tag name\n\n    var matches = node.match(/^[\\w-]+|\\*/);\n\n    if (matches) {\n      this.tag = matches[0];\n      node = node.slice(this.tag.length);\n    } // match pseudo classes\n\n\n    while (matches = /:([\\w-]+)(?:\\((.+)\\))?/g.exec(node)) {\n      this.pseudo.push(pseudoMatcher[matches[1]].bind(this, removeQuotes(matches[2] || '')));\n      node = node.slice(0, matches.index) + node.slice(matches.index + matches[0].length);\n    } // match the id\n\n\n    matches = node.match(/#([\\w-]+)/);\n\n    if (matches) {\n      this.id = matches[1];\n      node = node.slice(0, matches.index) + node.slice(matches.index + matches[0].length);\n    } // match classes\n\n\n    while (matches = /\\.([\\w-]+)/g.exec(node)) {\n      this.classList.push(matches[1]);\n      node = node.slice(0, matches.index) + node.slice(matches.index + matches[0].length);\n    } // match attributes\n\n\n    while (matches = /\\[([\\w-]+)(([=^~$|*]+)(.+?)( +[iI])?)?\\]/g.exec(node)) {\n      this.attrs.push({\n        name: matches[1],\n        matcher: attributeMatcher[matches[3] || '*'].bind(this, !!matches[5], // case insensitive yes/no\n        removeQuotes((matches[4] || '').trim()) // attribute value\n        )\n      });\n      node = node.slice(0, matches.index) + node.slice(matches.index + matches[0].length);\n    }\n  }\n\n  _createClass(CssQueryNode, [{\n    key: \"matches\",\n    value: function matches(node) {\n      var i;\n      if (node.nodeType !== 1) return false;\n\n      if (this.tag && this.tag !== node.nodeName && this.tag !== '*') {\n        return false;\n      }\n\n      if (this.id && this.id !== node.id) {\n        return false;\n      }\n\n      var classList = (node.getAttribute('class') || '').split(regex.delimiter).filter(function (el) {\n        return !!el.length;\n      });\n\n      if (this.classList.filter(function (className) {\n        return classList.indexOf(className) < 0;\n      }).length) {\n        return false;\n      }\n\n      for (i = this.attrs.length; i--;) {\n        var attrValue = node.getAttribute(this.attrs[i].name);\n\n        if (attrValue === null || !this.attrs[i].matcher(attrValue)) {\n          return false;\n        }\n      }\n\n      for (i = this.pseudo.length; i--;) {\n        if (!this.pseudo[i](node)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }]);\n\n  return CssQueryNode;\n}();\n\nmodule.exports = CssQuery;","map":null,"metadata":{},"sourceType":"script"}