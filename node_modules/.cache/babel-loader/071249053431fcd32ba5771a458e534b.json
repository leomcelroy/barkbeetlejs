{"ast":null,"code":"/*\n * Copyright 2018 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the terms of the LICENSE file distributed with this project.\n */\nimport * as tslib_1 from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { Boundary } from \"../../common/boundary\";\nimport * as Classes from \"../../common/classes\";\nimport { OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED } from \"../../common/errors\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport { safeInvoke } from \"../../common/utils\";\nimport { ResizeSensor } from \"../resize-sensor/resizeSensor\";\n/** @internal - do not expose this type */\n\nexport var OverflowDirection;\n\n(function (OverflowDirection) {\n  OverflowDirection[OverflowDirection[\"NONE\"] = 0] = \"NONE\";\n  OverflowDirection[OverflowDirection[\"GROW\"] = 1] = \"GROW\";\n  OverflowDirection[OverflowDirection[\"SHRINK\"] = 2] = \"SHRINK\";\n})(OverflowDirection || (OverflowDirection = {}));\n\nvar OverflowList =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(OverflowList, _super);\n\n  function OverflowList() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      direction: OverflowDirection.NONE,\n      lastOverflowCount: 0,\n      overflow: [],\n      visible: _this.props.items\n    };\n    /** A cache containing the widths of all elements being observed to detect growing/shrinking */\n\n    _this.previousWidths = new Map();\n    _this.spacer = null;\n\n    _this.resize = function (entries) {\n      // if any parent is growing, assume we have more room than before\n      var growing = entries.some(function (entry) {\n        var previousWidth = _this.previousWidths.get(entry.target) || 0;\n        return entry.contentRect.width > previousWidth;\n      });\n\n      _this.repartition(growing);\n\n      entries.forEach(function (entry) {\n        return _this.previousWidths.set(entry.target, entry.contentRect.width);\n      });\n    };\n\n    return _this;\n  }\n\n  OverflowList.ofType = function () {\n    return OverflowList;\n  };\n\n  OverflowList.prototype.componentDidMount = function () {\n    this.repartition(false);\n  };\n\n  OverflowList.prototype.componentWillReceiveProps = function (nextProps) {\n    var _a = this.props,\n        collapseFrom = _a.collapseFrom,\n        items = _a.items,\n        minVisibleItems = _a.minVisibleItems,\n        observeParents = _a.observeParents,\n        overflowRenderer = _a.overflowRenderer,\n        visibleItemRenderer = _a.visibleItemRenderer;\n\n    if (observeParents !== nextProps.observeParents) {\n      console.warn(OVERFLOW_LIST_OBSERVE_PARENTS_CHANGED);\n    }\n\n    if (collapseFrom !== nextProps.collapseFrom || items !== nextProps.items || minVisibleItems !== nextProps.minVisibleItems || overflowRenderer !== nextProps.overflowRenderer || visibleItemRenderer !== nextProps.visibleItemRenderer) {\n      // reset visible state if the above props change.\n      this.setState({\n        direction: OverflowDirection.GROW,\n        lastOverflowCount: 0,\n        overflow: [],\n        visible: nextProps.items\n      });\n    }\n  };\n\n  OverflowList.prototype.componentDidUpdate = function (_prevProps, prevState) {\n    this.repartition(false);\n    var _a = this.state,\n        direction = _a.direction,\n        overflow = _a.overflow,\n        lastOverflowCount = _a.lastOverflowCount;\n\n    if ( // if a resize operation has just completed (transition to NONE)\n    direction === OverflowDirection.NONE && direction !== prevState.direction && overflow.length !== lastOverflowCount) {\n      safeInvoke(this.props.onOverflow, overflow);\n    }\n  };\n\n  OverflowList.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        className = _a.className,\n        collapseFrom = _a.collapseFrom,\n        observeParents = _a.observeParents,\n        style = _a.style,\n        _b = _a.tagName,\n        TagName = _b === void 0 ? \"div\" : _b,\n        visibleItemRenderer = _a.visibleItemRenderer;\n    var overflow = this.maybeRenderOverflow();\n    return React.createElement(ResizeSensor, {\n      onResize: this.resize,\n      observeParents: observeParents\n    }, React.createElement(TagName, {\n      className: classNames(Classes.OVERFLOW_LIST, className),\n      style: style\n    }, collapseFrom === Boundary.START ? overflow : null, this.state.visible.map(visibleItemRenderer), collapseFrom === Boundary.END ? overflow : null, React.createElement(\"div\", {\n      className: Classes.OVERFLOW_LIST_SPACER,\n      ref: function ref(_ref) {\n        return _this.spacer = _ref;\n      }\n    })));\n  };\n\n  OverflowList.prototype.maybeRenderOverflow = function () {\n    var overflow = this.state.overflow;\n\n    if (overflow.length === 0) {\n      return null;\n    }\n\n    return this.props.overflowRenderer(overflow);\n  };\n\n  OverflowList.prototype.repartition = function (growing) {\n    var _this = this;\n\n    if (this.spacer == null) {\n      return;\n    }\n\n    if (growing) {\n      this.setState(function (state) {\n        return {\n          direction: OverflowDirection.GROW,\n          // store last overflow if this is the beginning of a resize (for check in componentDidUpdate).\n          lastOverflowCount: state.direction === OverflowDirection.NONE ? state.overflow.length : state.lastOverflowCount,\n          overflow: [],\n          visible: _this.props.items\n        };\n      });\n    } else if (this.spacer.getBoundingClientRect().width < 0.9) {\n      // spacer has flex-shrink and width 1px so if it's much smaller then we know to shrink\n      this.setState(function (state) {\n        if (state.visible.length <= _this.props.minVisibleItems) {\n          return null;\n        }\n\n        var collapseFromStart = _this.props.collapseFrom === Boundary.START;\n        var visible = state.visible.slice();\n        var next = collapseFromStart ? visible.shift() : visible.pop();\n\n        if (next === undefined) {\n          return null;\n        }\n\n        var overflow = collapseFromStart ? state.overflow.concat([next]) : [next].concat(state.overflow);\n        return {\n          // set SHRINK mode unless a GROW is already in progress.\n          // GROW shows all items then shrinks until it settles, so we\n          // preserve the fact that the original trigger was a GROW.\n          direction: state.direction === OverflowDirection.NONE ? OverflowDirection.SHRINK : state.direction,\n          overflow: overflow,\n          visible: visible\n        };\n      });\n    } else {\n      // repartition complete!\n      this.setState({\n        direction: OverflowDirection.NONE\n      });\n    }\n  };\n\n  OverflowList.displayName = DISPLAYNAME_PREFIX + \".OverflowList\";\n  OverflowList.defaultProps = {\n    collapseFrom: Boundary.START,\n    minVisibleItems: 0\n  };\n  return OverflowList;\n}(React.PureComponent);\n\nexport { OverflowList };","map":null,"metadata":{},"sourceType":"module"}