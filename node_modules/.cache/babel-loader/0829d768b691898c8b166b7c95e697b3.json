{"ast":null,"code":"import _toConsumableArray from \"/Users/leomcelroy/Desktop/barkBeetleEverything/barkbeetle_js_real/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n// makerjs model, depth, params -> pocket toolpath\nimport * as mjs from 'makerjs';\nvar STRANGE_CORRECTION = 0.0000001; //TODO: why is this neccessary otherwise outline shits the bed\n\nvar len = function len(toolpath) {\n  return Object.keys(toolpath.models).length;\n};\n\nvar isToolpath = function isToolpath(toolpath) {\n  //console.log(\"toolpath\", toolpath);\n  if (len(toolpath) === 1) {\n    return true;\n  } else if (len(toolpath) > 1) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\nvar intToolpath = function intToolpath(geo, radius) {\n  var corners = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  // console.log(\"geo\", geo);\n  // console.log(len(geo));\n  // let corners = (len(geo) === 1) ? 1 : 0;\n  return mjs.model.outline(geo, radius + STRANGE_CORRECTION, corners, true);\n};\n\nvar intToolpaths = function intToolpaths(geo, params) {\n  var pass = intToolpath(geo, params.compensatedRadius);\n\n  if (isToolpath(pass) !== true) {\n    return {\n      models: {}\n    };\n  }\n\n  var models = {};\n  var count = 0;\n  var corners = 1;\n\n  while (isToolpath(pass)) {\n    models[count] = pass;\n    count++; // this is a strange issue\n    // not entirely sure why mjs has issues with some corner parameters when there are sharp separate corners in model\n\n    try {\n      pass = intToolpath(models[count - 1], params.compensatedRadius * params.stepoverPercentage, corners);\n    } catch (_unused) {\n      corners = 0;\n    } //\n    // if (len(pass) > 1) {\n    //   corners = 0;\n    // }\n    //console.log(\"pass\", pass, \"count\", count, \"ispath\", isToolpath(pass));\n\n  }\n\n  var model = {\n    models: models //console.log(\"model\", model)\n\n  };\n  return model;\n};\n\nvar pocket = function pocket(model, params) {\n  //let p = model.models.profile;\n  var p = model; // let outline = mjs.model.outline(p, params.compensatedRadius, 1, true); //third parameter is what type of corners, 0 (rounded) by default\n  // let outline = intToolpath(p, params.compensatedRadius);\n\n  var outlines = intToolpaths(p, params);\n  var iterOut = Object.values(outlines.models); // let chains = mjs.model.findChains(outline);\n  // let chain = mjs.model.findSingleChain(outline);\n  // let chain2 = iterOut.map(x => mjs.model.findSingleChain(x)); //TODO: need to change this to find chains\n\n  var chains2 = iterOut.map(function (x) {\n    return mjs.model.findChains(x);\n  });\n  console.log(chains2); //chains2 = chains2.flat(1);\n\n  var divisions = chains2.map(function (c) {\n    return c.map(function (c2) {\n      return Math.floor(c2.pathLength / params.minimumSpacing);\n    });\n  });\n  var spacing = chains2.map(function (c, i) {\n    return c.map(function (c2, j) {\n      return c2.pathLength / divisions[i + j];\n    });\n  }); // let keyPoints = mjs.chain.toKeyPoints(chain, spacing);\n\n  var keyPoints2 = chains2.map(function (x, i) {\n    return mjs.chain.toKeyPoints(x, spacing[i]);\n  }); // console.log(keyPoints2);\n  // let scaleFactor = 10;\n  // let scaleXY = keyPoints.map(p => [p[0] * scaleFactor, p[1] * scaleFactor]);\n  // let gcodePoints = keyPoints.map(p => `G1 X${p[0]} Y${p[1]} F${params.feedRate}`)\n\n  var gcodePoints2 = keyPoints2.map(function (x) {\n    return x.map(function (p) {\n      return \"G1 X\".concat(p[0], \" Y\").concat(p[1], \" F\").concat(params.feedRate);\n    });\n  }); // console.log(gcodePoints2)\n  // gcodePoints2 = gcodePoints2.flat(1);\n  // let gcode = JSON.parse(JSON.stringify(gcodePoints));\n  // let gcode2 = JSON.parse(JSON.stringify(gcodePoints2));\n  //console.log(gcode2);\n  // let firstPoint = keyPoints[0];\n\n  var firstPoints2 = keyPoints2.map(function (x) {\n    return x[0];\n  }); // console.log(firstPoints2)\n  // let paths = params.depthOfPasses.map((p,i) => [\n  //   `G1 Z${params.depthOfPasses[i]} F12.0`,\n  //   ...gcodePoints,\n  //   `G1 X${firstPoint[0]} Y${firstPoint[1]} F${params.feedRate}`\n  // ])\n  // paths = paths.flat(1);\n\n  var paths2 = gcodePoints2.map(function (p, i) {\n    return _toConsumableArray(p).concat([\"G1 X\".concat(firstPoints2[i][0], \" Y\").concat(firstPoints2[i][1], \" F\").concat(params.feedRate)]);\n  });\n  paths2 = paths2.flat(1); //console.log(paths2)\n\n  var paths3 = params.depthOfPasses.map(function (p, i) {\n    return [\"G1 Z\".concat(params.depthOfPasses[i], \" F12.0\")].concat(_toConsumableArray(paths2));\n  });\n  paths3 = paths3.flat(1); // console.log(paths3)\n  // let gcode = [\n  //   params.units,\n  //   \"G90\",\n  //   `G1 Z${params.jogHeight} F9.0`,\n  //   `G0 X${firstPoint[0]} Y${firstPoint[1]}`,\n  //   ...paths\n  // ]\n\n  var gcode2 = [params.units, \"G90\", \"G1 Z\".concat(params.jogHeight, \" F9.0\"), \"G0 X\".concat(firstPoints2[0][0], \" Y\").concat(firstPoints2[0][1])].concat(_toConsumableArray(paths3), [\"G1 Z\".concat(params.jogHeight, \" F9.0\")]); // write to a new file named\n\n  var filename = 'testGcodePocket.nc';\n  var text = gcode2.join('\\n');\n  return {\n    drawing: outlines,\n    gcode: text,\n    filename: filename\n  };\n};\n\nexport { pocket };","map":{"version":3,"sources":["/Users/leomcelroy/Desktop/barkBeetleEverything/barkbeetle_js_real/src/toolpaths/pocket.js"],"names":["mjs","STRANGE_CORRECTION","len","toolpath","Object","keys","models","length","isToolpath","intToolpath","geo","radius","corners","model","outline","intToolpaths","params","pass","compensatedRadius","count","stepoverPercentage","pocket","p","outlines","iterOut","values","chains2","map","x","findChains","console","log","divisions","c","c2","Math","floor","pathLength","minimumSpacing","spacing","i","j","keyPoints2","chain","toKeyPoints","gcodePoints2","feedRate","firstPoints2","paths2","flat","paths3","depthOfPasses","gcode2","units","jogHeight","filename","text","join","drawing","gcode"],"mappings":"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","sourcesContent":["// makerjs model, depth, params -> pocket toolpath\nimport * as mjs from 'makerjs';\n\nconst STRANGE_CORRECTION = 0.0000001; //TODO: why is this neccessary otherwise outline shits the bed\n\nconst len = (toolpath) => Object.keys(toolpath.models).length;\n\nconst isToolpath = (toolpath) => {\n  //console.log(\"toolpath\", toolpath);\n\n  if (len(toolpath) === 1) {\n    return true;\n  } else if (len(toolpath) > 1) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nconst intToolpath = (geo, radius, corners = 1) => {\n  // console.log(\"geo\", geo);\n  // console.log(len(geo));\n  // let corners = (len(geo) === 1) ? 1 : 0;\n\n  return mjs.model.outline(geo, radius + STRANGE_CORRECTION, corners, true);\n}\n\nconst intToolpaths = (geo, params) => {\n  let pass = intToolpath(geo, params.compensatedRadius);\n\n  if (isToolpath(pass) !== true) {\n    return {models:{}};\n  }\n\n  let models = {}\n  let count = 0;\n  let corners = 1;\n\n  while ( isToolpath(pass)) {\n    models[count] = pass;\n    count++;\n\n    // this is a strange issue\n    // not entirely sure why mjs has issues with some corner parameters when there are sharp separate corners in model\n    try {\n      pass = intToolpath(models[count - 1], params.compensatedRadius * params.stepoverPercentage, corners);\n    } catch {\n      corners = 0;\n    }\n    //\n    // if (len(pass) > 1) {\n    //   corners = 0;\n    // }\n\n    //console.log(\"pass\", pass, \"count\", count, \"ispath\", isToolpath(pass));\n  }\n\n  let model = {models}\n\n  //console.log(\"model\", model)\n\n  return model;\n}\n\nconst pocket = (model, params) => {\n  //let p = model.models.profile;\n  let p = model;\n\n  // let outline = mjs.model.outline(p, params.compensatedRadius, 1, true); //third parameter is what type of corners, 0 (rounded) by default\n  // let outline = intToolpath(p, params.compensatedRadius);\n  let outlines = intToolpaths(p, params);\n  let iterOut = Object.values(outlines.models);\n\n  // let chains = mjs.model.findChains(outline);\n  // let chain = mjs.model.findSingleChain(outline);\n  // let chain2 = iterOut.map(x => mjs.model.findSingleChain(x)); //TODO: need to change this to find chains\n  let chains2 = iterOut.map(x => mjs.model.findChains(x));\n  console.log(chains2)\n  //chains2 = chains2.flat(1);\n\n  var divisions = chains2.map(c => c.map(c2 => Math.floor(c2.pathLength / params.minimumSpacing)));\n  var spacing = chains2.map((c,i) => c.map((c2, j) => c2.pathLength / divisions[i + j]));\n\n  // let keyPoints = mjs.chain.toKeyPoints(chain, spacing);\n  let keyPoints2 = chains2.map((x, i) => mjs.chain.toKeyPoints(x, spacing[i]));\n  // console.log(keyPoints2);\n\n  // let scaleFactor = 10;\n  // let scaleXY = keyPoints.map(p => [p[0] * scaleFactor, p[1] * scaleFactor]);\n\n  // let gcodePoints = keyPoints.map(p => `G1 X${p[0]} Y${p[1]} F${params.feedRate}`)\n  let gcodePoints2 = keyPoints2.map(x => x.map(p => `G1 X${p[0]} Y${p[1]} F${params.feedRate}`));\n  // console.log(gcodePoints2)\n  // gcodePoints2 = gcodePoints2.flat(1);\n\n  // let gcode = JSON.parse(JSON.stringify(gcodePoints));\n  // let gcode2 = JSON.parse(JSON.stringify(gcodePoints2));\n\n  //console.log(gcode2);\n\n  // let firstPoint = keyPoints[0];\n  let firstPoints2 = keyPoints2.map(x => x[0]);\n  // console.log(firstPoints2)\n\n  // let paths = params.depthOfPasses.map((p,i) => [\n  //   `G1 Z${params.depthOfPasses[i]} F12.0`,\n  //   ...gcodePoints,\n  //   `G1 X${firstPoint[0]} Y${firstPoint[1]} F${params.feedRate}`\n  // ])\n  // paths = paths.flat(1);\n\n  let paths2 = gcodePoints2.map((p, i) => [\n    ...p,\n    `G1 X${firstPoints2[i][0]} Y${firstPoints2[i][1]} F${params.feedRate}`\n  ])\n  paths2 = paths2.flat(1);\n  //console.log(paths2)\n\n  let paths3 = params.depthOfPasses.map((p,i) => [\n    `G1 Z${params.depthOfPasses[i]} F12.0`,\n    ...paths2,\n  ])\n  paths3 = paths3.flat(1);\n\n  // console.log(paths3)\n\n  // let gcode = [\n  //   params.units,\n  //   \"G90\",\n  //   `G1 Z${params.jogHeight} F9.0`,\n  //   `G0 X${firstPoint[0]} Y${firstPoint[1]}`,\n  //   ...paths\n  // ]\n\n  let gcode2 = [\n    params.units,\n    \"G90\",\n    `G1 Z${params.jogHeight} F9.0`,\n    `G0 X${firstPoints2[0][0]} Y${firstPoints2[0][1]}`,\n    ...paths3,\n    `G1 Z${params.jogHeight} F9.0`,\n  ]\n\n  // write to a new file named\n  let filename = 'testGcodePocket.nc';\n\n  let text = gcode2.join('\\n');\n\n  return {drawing: outlines, gcode: text, filename};\n};\n\n\nexport {pocket};\n"]},"metadata":{},"sourceType":"module"}