{"ast":null,"code":"'use strict'; // based on https://developers.google.com/speed/webp/docs/riff_container\n\nfunction isWebP(buffer) {\n  var riffHeader = 'RIFF' === buffer.toString('ascii', 0, 4);\n  var webpHeader = 'WEBP' === buffer.toString('ascii', 8, 12);\n  var vp8Header = 'VP8' === buffer.toString('ascii', 12, 15);\n  return riffHeader && webpHeader && vp8Header;\n}\n\nfunction calculate(buffer) {\n  var chunkHeader = buffer.toString('ascii', 12, 16);\n  buffer = buffer.slice(20, 30); // Extended webp stream signature\n\n  if (chunkHeader === 'VP8X') {\n    var extendedHeader = buffer[0];\n    var validStart = (extendedHeader & 0xc0) === 0;\n    var validEnd = (extendedHeader & 0x01) === 0;\n\n    if (validStart && validEnd) {\n      return calculateExtended(buffer);\n    } else {\n      return false;\n    }\n  } // Lossless webp stream signature\n\n\n  if (chunkHeader === 'VP8 ' && buffer[0] !== 0x2f) {\n    return calculateLossy(buffer);\n  } // Lossy webp stream signature\n\n\n  var signature = buffer.toString('hex', 3, 6);\n\n  if (chunkHeader === 'VP8L' && signature !== '9d012a') {\n    return calculateLossless(buffer);\n  }\n\n  return false;\n}\n\nfunction calculateExtended(buffer) {\n  return {\n    'width': 1 + buffer.readUIntLE(4, 3),\n    'height': 1 + buffer.readUIntLE(7, 3)\n  };\n}\n\nfunction calculateLossless(buffer) {\n  return {\n    'width': 1 + ((buffer[2] & 0x3F) << 8 | buffer[1]),\n    'height': 1 + ((buffer[4] & 0xF) << 10 | buffer[3] << 2 | (buffer[2] & 0xC0) >> 6)\n  };\n}\n\nfunction calculateLossy(buffer) {\n  // `& 0x3fff` returns the last 14 bits\n  // TO-DO: include webp scaling in the calculations\n  return {\n    'width': buffer.readInt16LE(6) & 0x3fff,\n    'height': buffer.readInt16LE(8) & 0x3fff\n  };\n}\n\nmodule.exports = {\n  'detect': isWebP,\n  'calculate': calculate\n};","map":null,"metadata":{},"sourceType":"script"}