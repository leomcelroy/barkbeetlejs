{"ast":null,"code":"var _toConsumableArray = require(\"/Users/leomcelroy/Desktop/barkbeetle_js/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar pathUtils = require('./pathUtils');\n\nvar _require = require('../class/Box'),\n    NoBox = _require.NoBox;\n\nvar regex = require('./regex');\n\nvar textUtils = require('./textUtils');\n\nvar strUtils = require('./strUtils');\n\nvar PointCloud = require('./PointCloud.js');\n\nvar applyTransformation = function applyTransformation(cloud, node, applyTransformations) {\n  if (applyTransformations) {\n    return cloud.transform(node.matrixify());\n  }\n\n  return cloud;\n};\n\nvar getPointCloud = function getPointCloud(node, applyTransformations) {\n  var cloud = getPathCloud(node, applyTransformations);\n  return applyTransformation(cloud, node, applyTransformations);\n};\n\nvar getPathCloud = function getPathCloud(node, applyTransformations) {\n  if (node.nodeType !== 1) return new PointCloud();\n\n  switch (node.nodeName) {\n    case 'rect':\n    case 'image':\n      // Create Path from rect and create PointCloud from Path\n      return pathUtils.getCloud(pathUtils.pathFrom.rect(node));\n\n    case 'svg':\n    case 'mask':\n    case 'pattern':\n    case 'symbol':\n      return pathUtils.getCloud(pathUtils.pathFrom.rect(node));\n\n    case 'g':\n    case 'clipPath':\n    case 'a':\n    case 'marker':\n      // Iterate trough all childs and get the point cloud of each\n      // Then transform it with viewbox matrix if needed\n      return node.childNodes.reduce(function (cloud, child) {\n        return cloud.merge(getPointCloud(child, true));\n      }, new PointCloud());\n\n    case 'circle':\n      return pathUtils.getCloud(pathUtils.pathFrom.circle(node));\n\n    case 'ellipse':\n      return pathUtils.getCloud(pathUtils.pathFrom.ellipse(node));\n\n    case 'line':\n      return pathUtils.getCloud(pathUtils.pathFrom.line(node));\n\n    case 'polyline':\n    case 'polygon':\n      return pathUtils.getCloud(pathUtils.pathFrom.polyline(node));\n\n    case 'path':\n    case 'glyph':\n    case 'missing-glyph':\n      return pathUtils.getCloud(node.getAttribute('d'));\n\n    case 'use':\n      // Get reference from element\n      var ref = node.getAttribute('href'); // Get the actual referenced Node\n\n      var refNode = node.getRootNode().getElementById(ref.slice(1)); // Get the BBox of the referenced element and apply the viewbox of <use>\n\n      return getPointCloud(refNode).transform(node.generateViewBoxMatrix());\n\n    case 'text':\n    case 'tspan':\n    case 'altGlyph':\n      var boxes = textIterator(node).filter(function (box) {\n        return box.x !== 0 || box.y !== 0 || box.width !== 0 || box.height !== 0;\n      });\n      var box = boxes.reduce(function (last, curr) {\n        return last.merge(curr);\n      }, new NoBox());\n\n      if (box instanceof NoBox) {\n        return new PointCloud();\n      }\n\n      return pathUtils.getCloud(pathUtils.pathFrom.box(box));\n\n    default:\n      return new PointCloud();\n  }\n}; // this function is passing dx and dy values by references. Dont assign new values to it!\n// const textIterator = function(node, x0=0, y0=0, dx=[0], dy=[0]){\n\n\nvar textIterator = function textIterator(node) {\n  var pos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    x: 0,\n    y: 0\n  };\n  var dx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0];\n  var dy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [0];\n  var x = parseFloat(node.getAttribute('x'));\n  var y = parseFloat(node.getAttribute('y'));\n  pos.x = isNaN(x) ? pos.x : x;\n  pos.y = isNaN(y) ? pos.y : y;\n  var dx0 = (node.getAttribute('dx') || '').split(regex.delimiter).filter(function (num) {\n    return num !== '';\n  }).map(parseFloat);\n  var dy0 = (node.getAttribute('dy') || '').split(regex.delimiter).filter(function (num) {\n    return num !== '';\n  }).map(parseFloat);\n  var boxes = [];\n  var data = ''; // TODO: eventually replace only as much values as we have text chars (node.textContent.length) because we could end up adding to much\n  // replace initial values with node values if present\n\n  dx.splice.apply(dx, [0, dx0.length].concat(_toConsumableArray(dx0)));\n  dy.splice.apply(dy, [0, dy0.length].concat(_toConsumableArray(dy0)));\n  var i = 0;\n  var il = node.childNodes.length; // iterate through all children\n\n  for (; i < il; ++i) {\n    // shift next child\n    pos.x += dx.shift() || 0;\n    pos.y += dy.shift() || 0; // text\n\n    if (node.childNodes[i].nodeType === 3) {\n      // get text data\n      data = strUtils.unhtmlEntities(node.childNodes[i].data);\n      var j = 0;\n      var jl = data.length; // if it is more than one dx/dy single letters are moved by the amount (https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/dx)\n\n      if (dy.length || dx.length) {\n        for (; j < jl; j++) {\n          boxes.push(textUtils.bbox(data.substr(j, 1), pos.x, pos.y, node.getFontDetails()));\n          pos.x += dx.shift() || 0;\n          pos.y += dy.shift() || 0;\n          if (!dy.length && !dx.length) break;\n        }\n      } // in case it was only one dx/dy or no more dx/dy move the rest of the text\n\n\n      boxes.push(textUtils.bbox(data.substr(j), pos.x, pos.y, node.getFontDetails()));\n      pos.x += boxes[boxes.length - 1].width; // node\n    } else {\n      // in case of node recursively call function again with new start values\n      boxes = boxes.concat(textIterator(node.childNodes[i], pos, dx, dy));\n    }\n  }\n\n  return boxes;\n};\n\nmodule.exports = getPointCloud;","map":null,"metadata":{},"sourceType":"script"}