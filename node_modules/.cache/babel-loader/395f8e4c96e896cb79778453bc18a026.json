{"ast":null,"code":"// @info\n//   Polyfill for SVG getPathData() and setPathData() methods. Based on:\n//   - SVGPathSeg polyfill by Philip Rogers (MIT License)\n//     https://github.com/progers/pathseg\n//   - SVGPathNormalizer by Tadahisa Motooka (MIT License)\n//     https://github.com/motooka/SVGPathNormalizer/tree/master/src\n//   - arcToCubicCurves() by Dmitry Baranovskiy (MIT License)\n//     https://github.com/DmitryBaranovskiy/raphael/blob/v2.1.1/raphael.core.js#L1837\n// @author\n//   JarosÅ‚aw Foksa\n//   Jeremy Apthorp\n// @license\n//   MIT License\nvar commandsMap = {\n  \"Z\": \"Z\",\n  \"M\": \"M\",\n  \"L\": \"L\",\n  \"C\": \"C\",\n  \"Q\": \"Q\",\n  \"A\": \"A\",\n  \"H\": \"H\",\n  \"V\": \"V\",\n  \"S\": \"S\",\n  \"T\": \"T\",\n  \"z\": \"Z\",\n  \"m\": \"m\",\n  \"l\": \"l\",\n  \"c\": \"c\",\n  \"q\": \"q\",\n  \"a\": \"a\",\n  \"h\": \"h\",\n  \"v\": \"v\",\n  \"s\": \"s\",\n  \"t\": \"t\"\n};\n\nvar Source = function Source(string) {\n  this._string = string;\n  this._currentIndex = 0;\n  this._endIndex = this._string.length;\n  this._prevCommand = null;\n\n  this._skipOptionalSpaces();\n};\n\nSource.prototype = {\n  parseSegment: function parseSegment() {\n    var char = this._string[this._currentIndex];\n    var command = commandsMap[char] ? commandsMap[char] : null;\n\n    if (command === null) {\n      // Possibly an implicit command. Not allowed if this is the first command.\n      if (this._prevCommand === null) {\n        return null;\n      } // Check for remaining coordinates in the current command.\n\n\n      if ((char === \"+\" || char === \"-\" || char === \".\" || char >= \"0\" && char <= \"9\") && this._prevCommand !== \"Z\") {\n        if (this._prevCommand === \"M\") {\n          command = \"L\";\n        } else if (this._prevCommand === \"m\") {\n          command = \"l\";\n        } else {\n          command = this._prevCommand;\n        }\n      } else {\n        command = null;\n      }\n\n      if (command === null) {\n        return null;\n      }\n    } else {\n      this._currentIndex += 1;\n    }\n\n    this._prevCommand = command;\n    var values = null;\n    var cmd = command.toUpperCase();\n\n    if (cmd === \"H\" || cmd === \"V\") {\n      values = [this._parseNumber()];\n    } else if (cmd === \"M\" || cmd === \"L\" || cmd === \"T\") {\n      values = [this._parseNumber(), this._parseNumber()];\n    } else if (cmd === \"S\" || cmd === \"Q\") {\n      values = [this._parseNumber(), this._parseNumber(), this._parseNumber(), this._parseNumber()];\n    } else if (cmd === \"C\") {\n      values = [this._parseNumber(), this._parseNumber(), this._parseNumber(), this._parseNumber(), this._parseNumber(), this._parseNumber()];\n    } else if (cmd === \"A\") {\n      values = [this._parseNumber(), this._parseNumber(), this._parseNumber(), this._parseArcFlag(), this._parseArcFlag(), this._parseNumber(), this._parseNumber()];\n    } else if (cmd === \"Z\") {\n      this._skipOptionalSpaces();\n\n      values = [];\n    }\n\n    if (values === null || values.indexOf(null) >= 0) {\n      // Unknown command or known command with invalid values\n      return null;\n    } else {\n      return {\n        type: command,\n        values: values\n      };\n    }\n  },\n  hasMoreData: function hasMoreData() {\n    return this._currentIndex < this._endIndex;\n  },\n  peekSegmentType: function peekSegmentType() {\n    var char = this._string[this._currentIndex];\n    return commandsMap[char] ? commandsMap[char] : null;\n  },\n  initialCommandIsMoveTo: function initialCommandIsMoveTo() {\n    // If the path is empty it is still valid, so return true.\n    if (!this.hasMoreData()) {\n      return true;\n    }\n\n    var command = this.peekSegmentType(); // Path must start with moveTo.\n\n    return command === \"M\" || command === \"m\";\n  },\n  _isCurrentSpace: function _isCurrentSpace() {\n    var char = this._string[this._currentIndex];\n    return char <= \" \" && (char === \" \" || char === \"\\n\" || char === \"\\t\" || char === \"\\r\" || char === \"\\f\");\n  },\n  _skipOptionalSpaces: function _skipOptionalSpaces() {\n    while (this._currentIndex < this._endIndex && this._isCurrentSpace()) {\n      this._currentIndex += 1;\n    }\n\n    return this._currentIndex < this._endIndex;\n  },\n  _skipOptionalSpacesOrDelimiter: function _skipOptionalSpacesOrDelimiter() {\n    if (this._currentIndex < this._endIndex && !this._isCurrentSpace() && this._string[this._currentIndex] !== \",\") {\n      return false;\n    }\n\n    if (this._skipOptionalSpaces()) {\n      if (this._currentIndex < this._endIndex && this._string[this._currentIndex] === \",\") {\n        this._currentIndex += 1;\n\n        this._skipOptionalSpaces();\n      }\n    }\n\n    return this._currentIndex < this._endIndex;\n  },\n  // Parse a number from an SVG path. This very closely follows genericParseNumber(...) from\n  // Source/core/svg/SVGParserUtilities.cpp.\n  // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-PathDataBNF\n  _parseNumber: function _parseNumber() {\n    var exponent = 0;\n    var integer = 0;\n    var frac = 1;\n    var decimal = 0;\n    var sign = 1;\n    var expsign = 1;\n    var startIndex = this._currentIndex;\n\n    this._skipOptionalSpaces(); // Read the sign.\n\n\n    if (this._currentIndex < this._endIndex && this._string[this._currentIndex] === \"+\") {\n      this._currentIndex += 1;\n    } else if (this._currentIndex < this._endIndex && this._string[this._currentIndex] === \"-\") {\n      this._currentIndex += 1;\n      sign = -1;\n    }\n\n    if (this._currentIndex === this._endIndex || (this._string[this._currentIndex] < \"0\" || this._string[this._currentIndex] > \"9\") && this._string[this._currentIndex] !== \".\") {\n      // The first character of a number must be one of [0-9+-.].\n      return null;\n    } // Read the integer part, build right-to-left.\n\n\n    var startIntPartIndex = this._currentIndex;\n\n    while (this._currentIndex < this._endIndex && this._string[this._currentIndex] >= \"0\" && this._string[this._currentIndex] <= \"9\") {\n      this._currentIndex += 1; // Advance to first non-digit.\n    }\n\n    if (this._currentIndex !== startIntPartIndex) {\n      var scanIntPartIndex = this._currentIndex - 1;\n      var multiplier = 1;\n\n      while (scanIntPartIndex >= startIntPartIndex) {\n        integer += multiplier * (this._string[scanIntPartIndex] - \"0\");\n        scanIntPartIndex -= 1;\n        multiplier *= 10;\n      }\n    } // Read the decimals.\n\n\n    if (this._currentIndex < this._endIndex && this._string[this._currentIndex] === \".\") {\n      this._currentIndex += 1; // There must be a least one digit following the .\n\n      if (this._currentIndex >= this._endIndex || this._string[this._currentIndex] < \"0\" || this._string[this._currentIndex] > \"9\") {\n        return null;\n      }\n\n      while (this._currentIndex < this._endIndex && this._string[this._currentIndex] >= \"0\" && this._string[this._currentIndex] <= \"9\") {\n        frac *= 10;\n        decimal += (this._string.charAt(this._currentIndex) - \"0\") / frac;\n        this._currentIndex += 1;\n      }\n    } // Read the exponent part.\n\n\n    if (this._currentIndex !== startIndex && this._currentIndex + 1 < this._endIndex && (this._string[this._currentIndex] === \"e\" || this._string[this._currentIndex] === \"E\") && this._string[this._currentIndex + 1] !== \"x\" && this._string[this._currentIndex + 1] !== \"m\") {\n      this._currentIndex += 1; // Read the sign of the exponent.\n\n      if (this._string[this._currentIndex] === \"+\") {\n        this._currentIndex += 1;\n      } else if (this._string[this._currentIndex] === \"-\") {\n        this._currentIndex += 1;\n        expsign = -1;\n      } // There must be an exponent.\n\n\n      if (this._currentIndex >= this._endIndex || this._string[this._currentIndex] < \"0\" || this._string[this._currentIndex] > \"9\") {\n        return null;\n      }\n\n      while (this._currentIndex < this._endIndex && this._string[this._currentIndex] >= \"0\" && this._string[this._currentIndex] <= \"9\") {\n        exponent *= 10;\n        exponent += this._string[this._currentIndex] - \"0\";\n        this._currentIndex += 1;\n      }\n    }\n\n    var number = integer + decimal;\n    number *= sign;\n\n    if (exponent) {\n      number *= Math.pow(10, expsign * exponent);\n    }\n\n    if (startIndex === this._currentIndex) {\n      return null;\n    }\n\n    this._skipOptionalSpacesOrDelimiter();\n\n    return number;\n  },\n  _parseArcFlag: function _parseArcFlag() {\n    if (this._currentIndex >= this._endIndex) {\n      return null;\n    }\n\n    var flag = null;\n    var flagChar = this._string[this._currentIndex];\n    this._currentIndex += 1;\n\n    if (flagChar === \"0\") {\n      flag = 0;\n    } else if (flagChar === \"1\") {\n      flag = 1;\n    } else {\n      return null;\n    }\n\n    this._skipOptionalSpacesOrDelimiter();\n\n    return flag;\n  }\n};\n\nvar parsePathDataString = function parsePathDataString(string) {\n  if (!string || string.length === 0) return [];\n  var source = new Source(string);\n  var pathData = [];\n\n  if (source.initialCommandIsMoveTo()) {\n    while (source.hasMoreData()) {\n      var pathSeg = source.parseSegment();\n\n      if (pathSeg === null) {\n        break;\n      } else {\n        pathData.push(pathSeg);\n      }\n    }\n  }\n\n  return pathData;\n};\n\nvar $cachedPathData = typeof Symbol !== 'undefined' ? Symbol() : \"__cachedPathData\";\nvar $cachedNormalizedPathData = typeof Symbol !== 'undefined' ? Symbol() : \"__cachedNormalizedPathData\"; // @info\n//   Get an array of corresponding cubic bezier curve parameters for given arc curve paramters.\n\nvar arcToCubicCurves = function arcToCubicCurves(x1, y1, x2, y2, r1, r2, angle, largeArcFlag, sweepFlag, _recursive) {\n  var degToRad = function degToRad(degrees) {\n    return Math.PI * degrees / 180;\n  };\n\n  var rotate = function rotate(x, y, angleRad) {\n    var X = x * Math.cos(angleRad) - y * Math.sin(angleRad);\n    var Y = x * Math.sin(angleRad) + y * Math.cos(angleRad);\n    return {\n      x: X,\n      y: Y\n    };\n  };\n\n  var angleRad = degToRad(angle);\n  var params = [];\n  var f1, f2, cx, cy;\n\n  if (_recursive) {\n    f1 = _recursive[0];\n    f2 = _recursive[1];\n    cx = _recursive[2];\n    cy = _recursive[3];\n  } else {\n    var p1 = rotate(x1, y1, -angleRad);\n    x1 = p1.x;\n    y1 = p1.y;\n    var p2 = rotate(x2, y2, -angleRad);\n    x2 = p2.x;\n    y2 = p2.y;\n    var x = (x1 - x2) / 2;\n    var y = (y1 - y2) / 2;\n    var h = x * x / (r1 * r1) + y * y / (r2 * r2);\n\n    if (h > 1) {\n      h = Math.sqrt(h);\n      r1 = h * r1;\n      r2 = h * r2;\n    }\n\n    var sign;\n\n    if (largeArcFlag === sweepFlag) {\n      sign = -1;\n    } else {\n      sign = 1;\n    }\n\n    var r1Pow = r1 * r1;\n    var r2Pow = r2 * r2;\n    var left = r1Pow * r2Pow - r1Pow * y * y - r2Pow * x * x;\n    var right = r1Pow * y * y + r2Pow * x * x;\n    var k = sign * Math.sqrt(Math.abs(left / right));\n    cx = k * r1 * y / r2 + (x1 + x2) / 2;\n    cy = k * -r2 * x / r1 + (y1 + y2) / 2;\n    f1 = Math.asin(parseFloat(((y1 - cy) / r2).toFixed(9)));\n    f2 = Math.asin(parseFloat(((y2 - cy) / r2).toFixed(9)));\n\n    if (x1 < cx) {\n      f1 = Math.PI - f1;\n    }\n\n    if (x2 < cx) {\n      f2 = Math.PI - f2;\n    }\n\n    if (f1 < 0) {\n      f1 = Math.PI * 2 + f1;\n    }\n\n    if (f2 < 0) {\n      f2 = Math.PI * 2 + f2;\n    }\n\n    if (sweepFlag && f1 > f2) {\n      f1 = f1 - Math.PI * 2;\n    }\n\n    if (!sweepFlag && f2 > f1) {\n      f2 = f2 - Math.PI * 2;\n    }\n  }\n\n  var df = f2 - f1;\n\n  if (Math.abs(df) > Math.PI * 120 / 180) {\n    var f2old = f2;\n    var x2old = x2;\n    var y2old = y2;\n\n    if (sweepFlag && f2 > f1) {\n      f2 = f1 + Math.PI * 120 / 180 * 1;\n    } else {\n      f2 = f1 + Math.PI * 120 / 180 * -1;\n    }\n\n    x2 = cx + r1 * Math.cos(f2);\n    y2 = cy + r2 * Math.sin(f2);\n    params = arcToCubicCurves(x2, y2, x2old, y2old, r1, r2, angle, 0, sweepFlag, [f2, f2old, cx, cy]);\n  }\n\n  df = f2 - f1;\n  var c1 = Math.cos(f1);\n  var s1 = Math.sin(f1);\n  var c2 = Math.cos(f2);\n  var s2 = Math.sin(f2);\n  var t = Math.tan(df / 4);\n  var hx = 4 / 3 * r1 * t;\n  var hy = 4 / 3 * r2 * t;\n  var m1 = [x1, y1];\n  var m2 = [x1 + hx * s1, y1 - hy * c1];\n  var m3 = [x2 + hx * s2, y2 - hy * c2];\n  var m4 = [x2, y2];\n  m2[0] = 2 * m1[0] - m2[0];\n  m2[1] = 2 * m1[1] - m2[1];\n\n  if (_recursive) {\n    return [m2, m3, m4].concat(params);\n  } else {\n    params = [m2, m3, m4].concat(params);\n    var curves = [];\n\n    for (var i = 0; i < params.length; i += 3) {\n      var r1 = rotate(params[i][0], params[i][1], angleRad);\n      var r2 = rotate(params[i + 1][0], params[i + 1][1], angleRad);\n      var r3 = rotate(params[i + 2][0], params[i + 2][1], angleRad);\n      curves.push([r1.x, r1.y, r2.x, r2.y, r3.x, r3.y]);\n    }\n\n    return curves;\n  }\n};\n\nvar clonePathData = function clonePathData(pathData) {\n  return pathData.map(function (seg) {\n    return {\n      type: seg.type,\n      values: Array.prototype.slice.call(seg.values)\n    };\n  });\n}; // @info\n//   Takes any path data, returns path data that consists only from absolute commands.\n\n\nvar absolutizePathData = function absolutizePathData(pathData) {\n  var absolutizedPathData = [];\n  var currentX = null;\n  var currentY = null;\n  var subpathX = null;\n  var subpathY = null;\n  pathData.forEach(function (seg) {\n    var type = seg.type;\n\n    if (type === \"M\") {\n      var x = seg.values[0];\n      var y = seg.values[1];\n      absolutizedPathData.push({\n        type: \"M\",\n        values: [x, y]\n      });\n      subpathX = x;\n      subpathY = y;\n      currentX = x;\n      currentY = y;\n    } else if (type === \"m\") {\n      var x = currentX + seg.values[0];\n      var y = currentY + seg.values[1];\n      absolutizedPathData.push({\n        type: \"M\",\n        values: [x, y]\n      });\n      subpathX = x;\n      subpathY = y;\n      currentX = x;\n      currentY = y;\n    } else if (type === \"L\") {\n      var x = seg.values[0];\n      var y = seg.values[1];\n      absolutizedPathData.push({\n        type: \"L\",\n        values: [x, y]\n      });\n      currentX = x;\n      currentY = y;\n    } else if (type === \"l\") {\n      var x = currentX + seg.values[0];\n      var y = currentY + seg.values[1];\n      absolutizedPathData.push({\n        type: \"L\",\n        values: [x, y]\n      });\n      currentX = x;\n      currentY = y;\n    } else if (type === \"C\") {\n      var x1 = seg.values[0];\n      var y1 = seg.values[1];\n      var x2 = seg.values[2];\n      var y2 = seg.values[3];\n      var x = seg.values[4];\n      var y = seg.values[5];\n      absolutizedPathData.push({\n        type: \"C\",\n        values: [x1, y1, x2, y2, x, y]\n      });\n      currentX = x;\n      currentY = y;\n    } else if (type === \"c\") {\n      var x1 = currentX + seg.values[0];\n      var y1 = currentY + seg.values[1];\n      var x2 = currentX + seg.values[2];\n      var y2 = currentY + seg.values[3];\n      var x = currentX + seg.values[4];\n      var y = currentY + seg.values[5];\n      absolutizedPathData.push({\n        type: \"C\",\n        values: [x1, y1, x2, y2, x, y]\n      });\n      currentX = x;\n      currentY = y;\n    } else if (type === \"Q\") {\n      var x1 = seg.values[0];\n      var y1 = seg.values[1];\n      var x = seg.values[2];\n      var y = seg.values[3];\n      absolutizedPathData.push({\n        type: \"Q\",\n        values: [x1, y1, x, y]\n      });\n      currentX = x;\n      currentY = y;\n    } else if (type === \"q\") {\n      var x1 = currentX + seg.values[0];\n      var y1 = currentY + seg.values[1];\n      var x = currentX + seg.values[2];\n      var y = currentY + seg.values[3];\n      absolutizedPathData.push({\n        type: \"Q\",\n        values: [x1, y1, x, y]\n      });\n      currentX = x;\n      currentY = y;\n    } else if (type === \"A\") {\n      var x = seg.values[5];\n      var y = seg.values[6];\n      absolutizedPathData.push({\n        type: \"A\",\n        values: [seg.values[0], seg.values[1], seg.values[2], seg.values[3], seg.values[4], x, y]\n      });\n      currentX = x;\n      currentY = y;\n    } else if (type === \"a\") {\n      var x = currentX + seg.values[5];\n      var y = currentY + seg.values[6];\n      absolutizedPathData.push({\n        type: \"A\",\n        values: [seg.values[0], seg.values[1], seg.values[2], seg.values[3], seg.values[4], x, y]\n      });\n      currentX = x;\n      currentY = y;\n    } else if (type === \"H\") {\n      var x = seg.values[0];\n      absolutizedPathData.push({\n        type: \"H\",\n        values: [x]\n      });\n      currentX = x;\n    } else if (type === \"h\") {\n      var x = currentX + seg.values[0];\n      absolutizedPathData.push({\n        type: \"H\",\n        values: [x]\n      });\n      currentX = x;\n    } else if (type === \"V\") {\n      var y = seg.values[0];\n      absolutizedPathData.push({\n        type: \"V\",\n        values: [y]\n      });\n      currentY = y;\n    } else if (type === \"v\") {\n      var y = currentY + seg.values[0];\n      absolutizedPathData.push({\n        type: \"V\",\n        values: [y]\n      });\n      currentY = y;\n    } else if (type === \"S\") {\n      var x2 = seg.values[0];\n      var y2 = seg.values[1];\n      var x = seg.values[2];\n      var y = seg.values[3];\n      absolutizedPathData.push({\n        type: \"S\",\n        values: [x2, y2, x, y]\n      });\n      currentX = x;\n      currentY = y;\n    } else if (type === \"s\") {\n      var x2 = currentX + seg.values[0];\n      var y2 = currentY + seg.values[1];\n      var x = currentX + seg.values[2];\n      var y = currentY + seg.values[3];\n      absolutizedPathData.push({\n        type: \"S\",\n        values: [x2, y2, x, y]\n      });\n      currentX = x;\n      currentY = y;\n    } else if (type === \"T\") {\n      var x = seg.values[0];\n      var y = seg.values[1];\n      absolutizedPathData.push({\n        type: \"T\",\n        values: [x, y]\n      });\n      currentX = x;\n      currentY = y;\n    } else if (type === \"t\") {\n      var x = currentX + seg.values[0];\n      var y = currentY + seg.values[1];\n      absolutizedPathData.push({\n        type: \"T\",\n        values: [x, y]\n      });\n      currentX = x;\n      currentY = y;\n    } else if (type === \"Z\" || type === \"z\") {\n      absolutizedPathData.push({\n        type: \"Z\",\n        values: []\n      });\n      currentX = subpathX;\n      currentY = subpathY;\n    }\n  });\n  return absolutizedPathData;\n}; // @info\n//   Takes path data that consists only from absolute commands, returns path data that consists only from\n//   \"M\", \"L\", \"C\" and \"Z\" commands.\n\n\nvar reducePathData = function reducePathData(pathData) {\n  var reducedPathData = [];\n  var lastType = null;\n  var lastControlX = null;\n  var lastControlY = null;\n  var currentX = null;\n  var currentY = null;\n  var subpathX = null;\n  var subpathY = null;\n  pathData.forEach(function (seg) {\n    if (seg.type === \"M\") {\n      var x = seg.values[0];\n      var y = seg.values[1];\n      reducedPathData.push({\n        type: \"M\",\n        values: [x, y]\n      });\n      subpathX = x;\n      subpathY = y;\n      currentX = x;\n      currentY = y;\n    } else if (seg.type === \"C\") {\n      var x1 = seg.values[0];\n      var y1 = seg.values[1];\n      var x2 = seg.values[2];\n      var y2 = seg.values[3];\n      var x = seg.values[4];\n      var y = seg.values[5];\n      reducedPathData.push({\n        type: \"C\",\n        values: [x1, y1, x2, y2, x, y]\n      });\n      lastControlX = x2;\n      lastControlY = y2;\n      currentX = x;\n      currentY = y;\n    } else if (seg.type === \"L\") {\n      var x = seg.values[0];\n      var y = seg.values[1];\n      reducedPathData.push({\n        type: \"L\",\n        values: [x, y]\n      });\n      currentX = x;\n      currentY = y;\n    } else if (seg.type === \"H\") {\n      var x = seg.values[0];\n      reducedPathData.push({\n        type: \"L\",\n        values: [x, currentY]\n      });\n      currentX = x;\n    } else if (seg.type === \"V\") {\n      var y = seg.values[0];\n      reducedPathData.push({\n        type: \"L\",\n        values: [currentX, y]\n      });\n      currentY = y;\n    } else if (seg.type === \"S\") {\n      var x2 = seg.values[0];\n      var y2 = seg.values[1];\n      var x = seg.values[2];\n      var y = seg.values[3];\n      var cx1, cy1;\n\n      if (lastType === \"C\" || lastType === \"S\") {\n        cx1 = currentX + (currentX - lastControlX);\n        cy1 = currentY + (currentY - lastControlY);\n      } else {\n        cx1 = currentX;\n        cy1 = currentY;\n      }\n\n      reducedPathData.push({\n        type: \"C\",\n        values: [cx1, cy1, x2, y2, x, y]\n      });\n      lastControlX = x2;\n      lastControlY = y2;\n      currentX = x;\n      currentY = y;\n    } else if (seg.type === \"T\") {\n      var x = seg.values[0];\n      var y = seg.values[1];\n      var x1, y1;\n\n      if (lastType === \"Q\" || lastType === \"T\") {\n        x1 = currentX + (currentX - lastControlX);\n        y1 = currentY + (currentY - lastControlY);\n      } else {\n        x1 = currentX;\n        y1 = currentY;\n      }\n\n      var cx1 = currentX + 2 * (x1 - currentX) / 3;\n      var cy1 = currentY + 2 * (y1 - currentY) / 3;\n      var cx2 = x + 2 * (x1 - x) / 3;\n      var cy2 = y + 2 * (y1 - y) / 3;\n      reducedPathData.push({\n        type: \"C\",\n        values: [cx1, cy1, cx2, cy2, x, y]\n      });\n      lastControlX = x1;\n      lastControlY = y1;\n      currentX = x;\n      currentY = y;\n    } else if (seg.type === \"Q\") {\n      var x1 = seg.values[0];\n      var y1 = seg.values[1];\n      var x = seg.values[2];\n      var y = seg.values[3];\n      var cx1 = currentX + 2 * (x1 - currentX) / 3;\n      var cy1 = currentY + 2 * (y1 - currentY) / 3;\n      var cx2 = x + 2 * (x1 - x) / 3;\n      var cy2 = y + 2 * (y1 - y) / 3;\n      reducedPathData.push({\n        type: \"C\",\n        values: [cx1, cy1, cx2, cy2, x, y]\n      });\n      lastControlX = x1;\n      lastControlY = y1;\n      currentX = x;\n      currentY = y;\n    } else if (seg.type === \"A\") {\n      var r1 = Math.abs(seg.values[0]);\n      var r2 = Math.abs(seg.values[1]);\n      var angle = seg.values[2];\n      var largeArcFlag = seg.values[3];\n      var sweepFlag = seg.values[4];\n      var x = seg.values[5];\n      var y = seg.values[6];\n\n      if (r1 === 0 || r2 === 0) {\n        reducedPathData.push({\n          type: \"C\",\n          values: [currentX, currentY, x, y, x, y]\n        });\n        currentX = x;\n        currentY = y;\n      } else {\n        if (currentX !== x || currentY !== y) {\n          var curves = arcToCubicCurves(currentX, currentY, x, y, r1, r2, angle, largeArcFlag, sweepFlag);\n          curves.forEach(function (curve) {\n            reducedPathData.push({\n              type: \"C\",\n              values: curve\n            });\n          });\n          currentX = x;\n          currentY = y;\n        }\n      }\n    } else if (seg.type === \"Z\") {\n      reducedPathData.push(seg);\n      currentX = subpathX;\n      currentY = subpathY;\n    }\n\n    lastType = seg.type;\n  });\n  return reducedPathData;\n};\n\nvar getLength = function getLength(el, key) {\n  if (key in el && \"baseVal\" in el[key]) {\n    return el[key].baseVal.value;\n  } else {\n    // svgdom doesn't support rect.x.baseVal, see https://github.com/svgdotjs/svgdom/issues/32\n    return +el.getAttribute(key);\n  }\n};\n\nvar path = function path(options) {\n  if (options && options.normalize) {\n    if (this[$cachedNormalizedPathData]) {\n      return clonePathData(this[$cachedNormalizedPathData]);\n    } else {\n      var pathData;\n\n      if (this[$cachedPathData]) {\n        pathData = clonePathData(this[$cachedPathData]);\n      } else {\n        pathData = parsePathDataString(this.getAttribute(\"d\") || \"\");\n        this[$cachedPathData] = clonePathData(pathData);\n      }\n\n      var normalizedPathData = reducePathData(absolutizePathData(pathData));\n      this[$cachedNormalizedPathData] = clonePathData(normalizedPathData);\n      return normalizedPathData;\n    }\n  } else {\n    if (this[$cachedPathData]) {\n      return clonePathData(this[$cachedPathData]);\n    } else {\n      var pathData = parsePathDataString(this.getAttribute(\"d\") || \"\");\n      this[$cachedPathData] = clonePathData(pathData);\n      return pathData;\n    }\n  }\n};\n\nvar rect = function rect(options) {\n  var x = getLength(this, \"x\");\n  var y = getLength(this, \"y\");\n  var width = getLength(this, \"width\");\n  var height = getLength(this, \"height\");\n  var rx = this.hasAttribute(\"rx\") ? getLength(this, \"rx\") : getLength(this, \"ry\");\n  var ry = this.hasAttribute(\"ry\") ? getLength(this, \"ry\") : getLength(this, \"rx\");\n\n  if (rx > width / 2) {\n    rx = width / 2;\n  }\n\n  if (ry > height / 2) {\n    ry = height / 2;\n  }\n\n  var pathData = [{\n    type: \"M\",\n    values: [x + rx, y]\n  }, {\n    type: \"H\",\n    values: [x + width - rx]\n  }, {\n    type: \"A\",\n    values: [rx, ry, 0, 0, 1, x + width, y + ry]\n  }, {\n    type: \"V\",\n    values: [y + height - ry]\n  }, {\n    type: \"A\",\n    values: [rx, ry, 0, 0, 1, x + width - rx, y + height]\n  }, {\n    type: \"H\",\n    values: [x + rx]\n  }, {\n    type: \"A\",\n    values: [rx, ry, 0, 0, 1, x, y + height - ry]\n  }, {\n    type: \"V\",\n    values: [y + ry]\n  }, {\n    type: \"A\",\n    values: [rx, ry, 0, 0, 1, x + rx, y]\n  }, {\n    type: \"Z\",\n    values: []\n  }]; // Get rid of redundant \"A\" segs when either rx or ry is 0\n\n  pathData = pathData.filter(function (s) {\n    return s.type === \"A\" && (s.values[0] === 0 || s.values[1] === 0) ? false : true;\n  });\n\n  if (options && options.normalize === true) {\n    pathData = reducePathData(pathData);\n  }\n\n  return pathData;\n};\n\nvar circle = function circle(options) {\n  var cx = getLength(this, \"cx\");\n  var cy = getLength(this, \"cy\");\n  var r = getLength(this, \"r\");\n  var pathData = [{\n    type: \"M\",\n    values: [cx + r, cy]\n  }, {\n    type: \"A\",\n    values: [r, r, 0, 0, 1, cx, cy + r]\n  }, {\n    type: \"A\",\n    values: [r, r, 0, 0, 1, cx - r, cy]\n  }, {\n    type: \"A\",\n    values: [r, r, 0, 0, 1, cx, cy - r]\n  }, {\n    type: \"A\",\n    values: [r, r, 0, 0, 1, cx + r, cy]\n  }, {\n    type: \"Z\",\n    values: []\n  }];\n\n  if (options && options.normalize === true) {\n    pathData = reducePathData(pathData);\n  }\n\n  return pathData;\n};\n\nvar ellipse = function ellipse(options) {\n  var cx = getLength(this, \"cx\");\n  var cy = getLength(this, \"cy\");\n  var rx = getLength(this, \"rx\");\n  var ry = getLength(this, \"ry\");\n  var pathData = [{\n    type: \"M\",\n    values: [cx + rx, cy]\n  }, {\n    type: \"A\",\n    values: [rx, ry, 0, 0, 1, cx, cy + ry]\n  }, {\n    type: \"A\",\n    values: [rx, ry, 0, 0, 1, cx - rx, cy]\n  }, {\n    type: \"A\",\n    values: [rx, ry, 0, 0, 1, cx, cy - ry]\n  }, {\n    type: \"A\",\n    values: [rx, ry, 0, 0, 1, cx + rx, cy]\n  }, {\n    type: \"Z\",\n    values: []\n  }];\n\n  if (options && options.normalize === true) {\n    pathData = reducePathData(pathData);\n  }\n\n  return pathData;\n};\n\nvar line = function line() {\n  var x1 = getLength(this, \"x1\");\n  var x2 = getLength(this, \"x2\");\n  var y1 = getLength(this, \"y1\");\n  var y2 = getLength(this, \"y2\");\n  return [{\n    type: \"M\",\n    values: [x1, y1]\n  }, {\n    type: \"L\",\n    values: [x2, y2]\n  }];\n};\n\nvar polyline = function polyline() {\n  var pathData = [];\n\n  for (var i = 0; i < this.points.numberOfItems; i += 1) {\n    var point = this.points.getItem(i);\n    pathData.push({\n      type: i === 0 ? \"M\" : \"L\",\n      values: [point.x, point.y]\n    });\n  }\n\n  return pathData;\n};\n\nvar polygon = function polygon() {\n  var pathData = [];\n\n  for (var i = 0; i < this.points.numberOfItems; i += 1) {\n    var point = this.points.getItem(i);\n    pathData.push({\n      type: i === 0 ? \"M\" : \"L\",\n      values: [point.x, point.y]\n    });\n  }\n\n  pathData.push({\n    type: \"Z\",\n    values: []\n  });\n  return pathData;\n};\n\nvar pathDataGetters = {\n  circle: circle,\n  ellipse: ellipse,\n  path: path,\n  polygon: polygon,\n  polyline: polyline,\n  line: line,\n  rect: rect\n};\n\nfunction getPathData(svgElement, options) {\n  var type = svgElement.nodeName.toLowerCase();\n\n  if (type in pathDataGetters) {\n    return pathDataGetters[type].call(svgElement, options);\n  } else {\n    throw new Error(\"Unsupported SVG element type: '\".concat(type, \"'\"));\n  }\n}\n\nmodule.exports = {\n  getPathData: getPathData\n};","map":null,"metadata":{},"sourceType":"script"}