{"ast":null,"code":"import _objectSpread from \"@babel/runtime/helpers/esm/objectSpread\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport React, { PureComponent } from 'react';\nimport PropTypes from 'prop-types';\nimport Box, { spacing, position, layout, dimensions } from 'ui-box';\nimport safeInvoke from '../../lib/safe-invoke';\nimport SegmentedControlRadio from './SegmentedControlRadio';\nvar radioCount = 1; // Used for generating unique input names\n\nvar SegmentedControl =\n/*#__PURE__*/\nfunction (_PureComponent) {\n  _inherits(SegmentedControl, _PureComponent);\n\n  function SegmentedControl(props, context) {\n    var _this;\n\n    _classCallCheck(this, SegmentedControl);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(SegmentedControl).call(this, props, context));\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"isControlled\", function () {\n      return typeof _this.props.value !== 'undefined' && _this.props.value !== null;\n    });\n\n    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), \"handleChange\", function (value) {\n      // Save a render cycle when it's a controlled input\n      if (!_this.isControlled()) {\n        _this.setState({\n          value: value\n        });\n      }\n\n      safeInvoke(_this.props.onChange, value);\n    });\n\n    var _value = props.defaultValue;\n\n    if (typeof _value === 'undefined' || _value === null) {\n      _value = props.options[0].value;\n    }\n\n    _this.state = {\n      value: _value\n    };\n    _this.name = \"SegmentedControl-\".concat(radioCount);\n    radioCount += 1;\n    return _this;\n  }\n\n  _createClass(SegmentedControl, [{\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$props = this.props,\n          filterOutValue = _this$props.value,\n          name = _this$props.name,\n          height = _this$props.height,\n          options = _this$props.options,\n          onChange = _this$props.onChange,\n          defaultValue = _this$props.defaultValue,\n          props = _objectWithoutProperties(_this$props, [\"value\", \"name\", \"height\", \"options\", \"onChange\", \"defaultValue\"]); // Allows it to behave like a controlled input\n\n\n      var value = this.state.value;\n\n      if (this.isControlled()) {\n        value = this.props.value;\n      }\n\n      return React.createElement(Box, _extends({\n        display: \"flex\",\n        marginRight: -1,\n        height: height\n      }, props), options.map(function (option, index) {\n        return React.createElement(SegmentedControlRadio, {\n          key: option.value,\n          id: _this2.name + index,\n          name: name || _this2.name,\n          label: option.label,\n          value: String(option.value),\n          height: height,\n          checked: value === option.value,\n          onChange: _this2.handleChange.bind(null, option.value),\n          appearance: \"default\",\n          isFirstItem: index === 0,\n          isLastItem: index === options.length - 1\n        });\n      }));\n    }\n  }]);\n\n  return SegmentedControl;\n}(PureComponent);\n\nSegmentedControl.displayName = \"SegmentedControl\";\n\n_defineProperty(SegmentedControl, \"propTypes\", _objectSpread({}, spacing.propTypes, position.propTypes, layout.propTypes, dimensions.propTypes, {\n  /**\n   * The options for the radios of the Segmented Control.\n   */\n  options: PropTypes.arrayOf(PropTypes.shape({\n    label: PropTypes.node.isRequired,\n    value: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.bool]).isRequired\n  })).isRequired,\n\n  /**\n   * The current value of the Segmented Control when controlled.\n   */\n  value: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.bool]),\n\n  /**\n   * The default value of the Segmented Control when uncontrolled.\n   */\n  defaultValue: PropTypes.oneOfType([PropTypes.number, PropTypes.string, PropTypes.bool]),\n\n  /**\n   * Function called when the value changes.\n   */\n  onChange: PropTypes.func,\n\n  /**\n   * The name of the radio group.\n   */\n  name: PropTypes.string,\n\n  /**\n   * The height of the Segmented Control.\n   */\n  height: PropTypes.number\n}));\n\n_defineProperty(SegmentedControl, \"defaultProps\", {\n  height: 32\n});\n\nexport { SegmentedControl as default };","map":null,"metadata":{},"sourceType":"module"}