{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nimport React, { PureComponent } from 'react';\nimport PropTypes from 'prop-types';\nimport cn from 'classnames';\nimport deprecated from 'react-prop-types/lib/deprecated';\nimport isRequiredForA11y from 'react-prop-types/lib/isRequiredForA11y';\nimport { SPACE } from '../constants/keyCodes';\nimport getField from '../utils/getField';\nimport themeColors from '../utils/themeColors';\nimport oneRequiredForA11y from '../utils/PropTypes/oneRequiredForA11y';\nimport capitalizeFirst from '../utils/StringUtils/capitalizeFirst';\nimport AccessibleFakeInkedButton from '../Helpers/AccessibleFakeInkedButton';\nimport FontIcon from '../FontIcons/FontIcon';\nimport SwitchTrack from './SwitchTrack';\n/**\n * Prevents a second warning from appearing when using the deprecated or a11y required\n * props by using the `__superSecretProp`.... So secret!\n */\n\nfunction preventDouble(validator) {\n  return function validate(props, propName) {\n    for (var _len = arguments.length, others = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      others[_key - 2] = arguments[_key];\n    }\n\n    var err = validator.apply(undefined, [props, propName].concat(others));\n\n    if (err && props.__superSecreteProp) {\n      err = null;\n    }\n\n    return err;\n  };\n}\n/**\n * The `SelectionControl` component is used to render any of the `Radio`, `Checkbox`, or `Switch`\n * selection control type. This component might eventually replace all three since they use this\n * anyways. I am not sure yet though.\n */\n\n\nvar SelectionControl = function (_PureComponent) {\n  _inherits(SelectionControl, _PureComponent);\n\n  function SelectionControl(props) {\n    _classCallCheck(this, SelectionControl);\n\n    var _this = _possibleConstructorReturn(this, _PureComponent.call(this, props));\n\n    _this._setInput = function (input) {\n      _this._input = input;\n    };\n\n    _this._setControl = function (control) {\n      _this._control = control;\n    };\n\n    _this._setContainer = function (container) {\n      _this._container = container;\n    };\n\n    _this._getIcon = function () {\n      var _this$props = _this.props,\n          checkedIcon = _this$props.checkedIcon,\n          uncheckedIcon = _this$props.uncheckedIcon,\n          type = _this$props.type;\n      var checked = getField(_this.props, _this.state, 'checked');\n\n      if (checkedIcon || uncheckedIcon) {\n        return checked ? checkedIcon : uncheckedIcon;\n      }\n\n      var prefix = (checked ? '' : 'un') + 'checked' + capitalizeFirst(type) + 'Icon';\n      var iconClassName = _this.props[prefix + 'ClassName'];\n      var children = _this.props[prefix + 'Children'];\n\n      if (iconClassName || children) {\n        return React.createElement(FontIcon, {\n          iconClassName: iconClassName,\n          inherit: true\n        }, children);\n      }\n\n      var icon = _this.props[prefix];\n      return icon ? React.cloneElement(icon, {\n        inherit: true\n      }) : null;\n    };\n\n    _this._handleKeyDown = function (e) {\n      if (_this.props.onKeyDown) {\n        _this.props.onKeyDown(e);\n      }\n\n      var key = e.which || e.keyCode;\n\n      if (key === SPACE) {\n        _this._input.click();\n      }\n    };\n\n    _this._handleChange = function (e) {\n      var _this$props2 = _this.props,\n          type = _this$props2.type,\n          onChange = _this$props2.onChange;\n      var checked = !getField(_this.props, _this.state, 'checked');\n\n      if (onChange) {\n        onChange(type === 'radio' ? e.target.value : checked, e);\n      }\n\n      if (typeof _this.props.checked === 'undefined') {\n        _this.setState({\n          checked: checked\n        });\n      }\n    };\n\n    _this.state = {};\n\n    if (typeof props.checked === 'undefined') {\n      _this.state.checked = !!props.defaultChecked;\n    }\n\n    return _this;\n  }\n  /**\n   * Gets the current checked value from the selection control. This is used when you have\n   * an uncontrolled selection control and simply need the checked state from a ref callback.\n   *\n   * @return {boolean} the checked state for the selection control.\\\n   */\n\n\n  SelectionControl.prototype.render = function render() {\n    var _props = this.props,\n        id = _props.id,\n        style = _props.style,\n        className = _props.className,\n        inline = _props.inline,\n        type = _props.type,\n        name = _props.name,\n        value = _props.value,\n        disabled = _props.disabled,\n        labelBefore = _props.labelBefore,\n        tabIndex = _props.tabIndex,\n        inkDisabled = _props.inkDisabled,\n        disabledInteractions = _props.disabledInteractions,\n        ariaLabel = _props['aria-label'],\n        ariaLabelledBy = _props['aria-labelledby'],\n        ariaDescribedBy = _props['aria-describedby'],\n        propLabel = _props.label,\n        propChildren = _props.checked,\n        onChange = _props.onChange,\n        tooltip = _props.tooltip,\n        checkedCheckboxIcon = _props.checkedCheckboxIcon,\n        uncheckedCheckboxIcon = _props.uncheckedCheckboxIcon,\n        checkedRadioIcon = _props.checkedRadioIcon,\n        uncheckedRadioIcon = _props.uncheckedRadioIcon,\n        __superSecreteProp = _props.__superSecreteProp,\n        checkedIcon = _props.checkedIcon,\n        uncheckedIcon = _props.uncheckedIcon,\n        checkedRadioIconChildren = _props.checkedRadioIconChildren,\n        checkedRadioIconClassName = _props.checkedRadioIconClassName,\n        uncheckedRadioIconChildren = _props.uncheckedRadioIconChildren,\n        uncheckedRadioIconClassName = _props.uncheckedRadioIconClassName,\n        checkedCheckboxIconChildren = _props.checkedCheckboxIconChildren,\n        checkedCheckboxIconClassName = _props.checkedCheckboxIconClassName,\n        uncheckedCheckboxIconChildren = _props.uncheckedCheckboxIconChildren,\n        uncheckedCheckboxIconClassName = _props.uncheckedCheckboxIconClassName,\n        props = _objectWithoutProperties(_props, ['id', 'style', 'className', 'inline', 'type', 'name', 'value', 'disabled', 'labelBefore', 'tabIndex', 'inkDisabled', 'disabledInteractions', 'aria-label', 'aria-labelledby', 'aria-describedby', 'label', 'checked', 'onChange', 'tooltip', 'checkedCheckboxIcon', 'uncheckedCheckboxIcon', 'checkedRadioIcon', 'uncheckedRadioIcon', '__superSecreteProp', 'checkedIcon', 'uncheckedIcon', 'checkedRadioIconChildren', 'checkedRadioIconClassName', 'uncheckedRadioIconChildren', 'uncheckedRadioIconClassName', 'checkedCheckboxIconChildren', 'checkedCheckboxIconClassName', 'uncheckedCheckboxIconChildren', 'uncheckedCheckboxIconClassName']);\n\n    var checked = getField(this.props, this.state, 'checked');\n    var isSwitch = type === 'switch';\n    var labelId = this.props.label && id + '-label';\n    var label = this.props.label && React.createElement('span', {\n      id: labelId\n    }, this.props.label);\n    var control = void 0;\n\n    if (isSwitch) {\n      control = React.createElement(SwitchTrack, {\n        disabled: disabled,\n        checked: checked,\n        'aria-label': ariaLabel,\n        'aria-labelledby': ariaLabelledBy || labelId\n      });\n    } else {\n      control = React.createElement(AccessibleFakeInkedButton, {\n        inkDisabled: inkDisabled,\n        disabledInteractions: disabledInteractions,\n        role: type,\n        className: cn('md-selection-control-toggle md-btn md-btn--icon', themeColors({\n          disabled: disabled,\n          hint: !checked,\n          secondary: checked\n        })),\n        'aria-checked': checked,\n        'aria-label': ariaLabel,\n        'aria-labelledby': ariaLabelledBy || labelId,\n        'aria-describedby': ariaDescribedBy,\n        tabIndex: tabIndex,\n        disabled: disabled\n      }, tooltip, this._getIcon());\n    }\n\n    return React.createElement('div', _extends({}, props, {\n      style: style,\n      className: cn('md-selection-control-container', {\n        'md-selection-control-container--inline': inline,\n        'md-switch-container': isSwitch\n      }, className),\n      onKeyDown: this._handleKeyDown\n    }), React.createElement('input', {\n      ref: this._setInput,\n      id: id,\n      type: isSwitch ? 'checkbox' : type,\n      checked: checked,\n      onChange: this._handleChange,\n      disabled: disabled,\n      className: 'md-selection-control-input',\n      name: name,\n      value: value,\n      'aria-hidden': true\n    }), React.createElement('label', {\n      htmlFor: id,\n      className: cn('md-selection-control-label', {\n        'md-pointer--hover': !disabled\n      }, themeColors({\n        disabled: disabled,\n        text: !disabled\n      }))\n    }, labelBefore && label, control, !labelBefore && label));\n  };\n\n  _createClass(SelectionControl, [{\n    key: 'checked',\n    get: function get() {\n      return getField(this.props, this.state, 'checked');\n    }\n  }]);\n\n  return SelectionControl;\n}(PureComponent);\n\nSelectionControl.propTypes = {\n  /**\n   * An id to use with the selection control. This is used for accessibility and so that the label\n   * triggers the selection control toggle.\n   */\n  id: preventDouble(isRequiredForA11y(PropTypes.oneOfType([PropTypes.string, PropTypes.number]))),\n\n  /**\n   * An optional label to apply to the checkbox when there is no visible label.\n   */\n  'aria-label': oneRequiredForA11y(PropTypes.string, 'label', 'aria-labelledby'),\n\n  /**\n   * An optional id that points to a label for the selection control when there is no visible label.\n   */\n  'aria-labelledby': PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n\n  /**\n   * An optional id of an element that describes this selection control.\n   * In the case of a fieldset, this should be the id of the fieldset legend which ensures\n   * screen readers provides additional context about the selection control\n   */\n  'aria-describedby': PropTypes.string,\n\n  /**\n   * An optional style to apply to the selection control's container.\n   */\n  style: PropTypes.object,\n\n  /**\n   * An optional className to apply to the selection control's container.\n   */\n  className: PropTypes.string,\n\n  /**\n   * The type of selection control to render.\n   */\n  type: PropTypes.oneOf(['checkbox', 'radio', 'switch']).isRequired,\n\n  /**\n   * A label to display with the selection control. This is required for accessibility and triggering\n   * the toggle.\n   */\n  label: PropTypes.node,\n\n  /**\n   * Boolean if the label should appear before the checkbox/radio icon or switch.\n   */\n  labelBefore: PropTypes.bool,\n\n  /**\n   * A name to use for the `SelectionControl`. This is required for accessibility. If the `type`\n   * is a `checkbox` and it is part of a group, it is recommended to make this a string ending\n   * in `[]` so that the value can be found from `document.querySelector('input[name=\"someName[]\"]').value`.\n   */\n  name: preventDouble(isRequiredForA11y(PropTypes.oneOfType([PropTypes.number, PropTypes.string]))),\n\n  /**\n   * Boolean if the `Radio` is disabled.\n   */\n  disabled: PropTypes.bool,\n\n  /**\n   * A function to call when the `SelectionControl` triggers the `change` event. The `onChange`\n   * callback will either include:\n   * - the currently changed radio's value\n   * - the next checked state for the `Switch` or `Checkbox`.\n   *\n   * as the first parameter followed by the change event.\n   *\n   * ```js\n   * // Radio\n   * onChange(changeEvent.target.value, changeEvent);\n   *\n   * // Checkbox or Switch\n   * onChange(changeEvent.target.checked, changeEvent);\n   * ```\n   */\n  onChange: PropTypes.func,\n\n  /**\n   * An optional function to call when the `keydown` event is triggered.\n   */\n  onKeyDown: PropTypes.func,\n\n  /**\n   * The value for the `SelectionControl`. It is not required for `Checkbox` and `Switch`,\n   * but it is recommended.\n   */\n  value: PropTypes.oneOfType([PropTypes.bool, PropTypes.number, PropTypes.string]),\n\n  /**\n   * A boolean if the `SelectionControl` is currently checked. This _really_ makes the `onChange`\n   * prop required, but since there are cases you might want to have the `onChange` listener on a\n   * `fieldset` or something above the component, it is never set to `required`. It will however\n   * prevent updates if there is no change listener.\n   */\n  checked: PropTypes.bool,\n\n  /**\n   * Boolean if the `Checkbox` or `Switch` are checked by default. This prop is invalid for a\n   * `Radio`.\n   */\n  defaultChecked: PropTypes.bool,\n\n  /**\n   * Boolean if the `SelectionControl` should be displayed inline instead of a block.\n   */\n  inline: PropTypes.bool,\n\n  /**\n   * The icon to use for a checked `checkbox` selection control.\n   */\n  checkedCheckboxIcon: PropTypes.element,\n\n  /**\n   * The icon to use for an unchecked `checkbox` selection control.\n   */\n  uncheckedCheckboxIcon: PropTypes.element,\n\n  /**\n   * The icon to use for a checked `radio` selection control.\n   */\n  checkedRadioIcon: PropTypes.element,\n\n  /**\n   * The icon to use for an unchecked `radio` selection control.\n   */\n  uncheckedRadioIcon: PropTypes.element,\n\n  /**\n   * An optional tooltip to render with the control. This is only used if you inject the\n   * tooltip manually yourself.\n   *\n   * `const TooltippedSelectionControl = injectTooltip(SelectionControl);`\n   */\n  tooltip: PropTypes.node,\n\n  /**\n   * Boolean if the ink should be disabled for radios or checkboxes.\n   *\n   * @see {@link Inks#inkDisabled}\n   */\n  inkDisabled: PropTypes.bool,\n\n  /**\n   * An optional list of ink interactions that should be disabled.\n   *\n   * @see {@link Inks#disabledInteractions}\n   */\n  disabledInteractions: PropTypes.arrayOf(PropTypes.oneOf(['keyboard', 'touch', 'mouse'])),\n\n  /**\n   * An optional tab index to apply to the selection control.\n   */\n  tabIndex: PropTypes.number,\n  checkedIcon: preventDouble(deprecated(PropTypes.node, 'Use the `checkedCheckboxIconChildren` and `checkedCheckboxIconClassName`  or the ' + '`checkedRadioIconChildren` and `checkedRadioIconClassName` props instead')),\n  uncheckedIcon: preventDouble(deprecated(PropTypes.node, 'Use the `uncheckedCheckboxIconChildren` and `uncheckedCheckboxIconClassName`  or the ' + '`uncheckedRadioIconChildren` and `uncheckedRadioIconClassName` props instead')),\n  checkedCheckboxIconChildren: deprecated(PropTypes.node, 'Use the `checkedCheckboxIcon` prop instead'),\n  checkedCheckboxIconClassName: deprecated(PropTypes.string, 'Use the `checkedCheckboxIcon` prop instead'),\n  uncheckedCheckboxIconChildren: deprecated(PropTypes.node, 'Use the `uncheckedCheckboxIcon` prop instead'),\n  uncheckedCheckboxIconClassName: deprecated(PropTypes.string, 'Use the `uncheckedCheckboxIcon` prop instead'),\n  checkedRadioIconChildren: deprecated(PropTypes.node, 'Use the `checkedRadioIcon` prop instead'),\n  checkedRadioIconClassName: deprecated(PropTypes.string, 'Use the `checkedRadioIcon` prop instead'),\n  uncheckedRadioIconChildren: deprecated(PropTypes.node, 'Use the `uncheckedRadioIcon` prop instead'),\n  uncheckedRadioIconClassName: deprecated(PropTypes.string, 'Use the `uncheckedRadioIcon` prop instead'),\n\n  /* maybe removed once upgrade again? */\n  __superSecreteProp: PropTypes.bool\n};\nSelectionControl.defaultProps = {\n  checkedCheckboxIcon: React.createElement(FontIcon, null, 'check_box'),\n  uncheckedCheckboxIcon: React.createElement(FontIcon, null, 'check_box_outline_blank'),\n  checkedRadioIcon: React.createElement(FontIcon, null, 'radio_button_checked'),\n  uncheckedRadioIcon: React.createElement(FontIcon, null, 'radio_button_unchecked')\n};\nexport default SelectionControl;","map":null,"metadata":{},"sourceType":"module"}