{"ast":null,"code":"/**\n * Normalise an SVG path to absolute coordinates\n * and full commands, rather than relative coordinates\n * and/or shortcut commands.\n */\nfunction normalizePath(d) {\n  // preprocess \"d\" so that we have spaces between values\n  d = d.replace(/,/g, \" \") // replace commas with spaces\n  .replace(/-/g, \" - \") // add spacing around minus signs\n  .replace(/-\\s+/g, \"-\") // remove spacing to the right of minus signs.\n  .replace(/([a-zA-Z])/g, \" $1 \"); // set up the variables used in this function\n\n  var instructions = d.replace(/([a-zA-Z])\\s?/g, \"|$1\").split(\"|\"),\n      instructionLength = instructions.length,\n      i,\n      instruction,\n      op,\n      lop,\n      args = [],\n      alen,\n      a,\n      sx = 0,\n      sy = 0,\n      x = 0,\n      y = 0,\n      cx = 0,\n      cy = 0,\n      cx2 = 0,\n      cy2 = 0,\n      normalized = \"\"; // we run through the instruction list starting at 1, not 0,\n  // because we split up \"|M x y ....\" so the first element will\n  // always be an empty string. By design.\n\n  for (i = 1; i < instructionLength; i++) {\n    // which instruction is this?\n    instruction = instructions[i];\n    op = instruction.substring(0, 1);\n    lop = op.toLowerCase(); // what are the arguments? note that we need to convert\n    // all strings into numbers, or + will do silly things.\n\n    args = instruction.replace(op, \"\").trim().split(\" \");\n    args = args.filter(function (v) {\n      return v !== \"\";\n    }).map(parseFloat);\n    alen = args.length; // we could use a switch, but elaborate code in a \"case\" with\n    // fallthrough is just horrid to read. So let's use ifthen\n    // statements instead.\n    // moveto command (plus possible lineto)\n\n    if (lop === \"m\") {\n      normalized += \"M \";\n\n      if (op === \"m\") {\n        x += args[0];\n        y += args[1];\n      } else {\n        x = args[0];\n        y = args[1];\n      } // records start position, for dealing\n      // with the shape close operator ('Z')\n\n\n      sx = x;\n      sy = y;\n      normalized += x + \" \" + y + \" \";\n\n      if (alen > 2) {\n        for (a = 0; a < alen; a += 2) {\n          if (op === \"m\") {\n            x += args[a];\n            y += args[a + 1];\n          } else {\n            x = args[a];\n            y = args[a + 1];\n          }\n\n          normalized += [\"L\", x, y, ''].join(\" \");\n        }\n      }\n    } else if (lop === \"l\") {\n      // lineto commands\n      for (a = 0; a < alen; a += 2) {\n        if (op === \"l\") {\n          x += args[a];\n          y += args[a + 1];\n        } else {\n          x = args[a];\n          y = args[a + 1];\n        }\n\n        normalized += [\"L\", x, y, ''].join(\" \");\n      }\n    } else if (lop === \"h\") {\n      for (a = 0; a < alen; a++) {\n        if (op === \"h\") {\n          x += args[a];\n        } else {\n          x = args[a];\n        }\n\n        normalized += [\"L\", x, y, ''].join(\" \");\n      }\n    } else if (lop === \"v\") {\n      for (a = 0; a < alen; a++) {\n        if (op === \"v\") {\n          y += args[a];\n        } else {\n          y = args[a];\n        }\n\n        normalized += [\"L\", x, y, ''].join(\" \");\n      }\n    } else if (lop === \"q\") {\n      // quadratic curveto commands\n      for (a = 0; a < alen; a += 4) {\n        if (op === \"q\") {\n          cx = x + args[a];\n          cy = y + args[a + 1];\n          x += args[a + 2];\n          y += args[a + 3];\n        } else {\n          cx = args[a];\n          cy = args[a + 1];\n          x = args[a + 2];\n          y = args[a + 3];\n        }\n\n        normalized += [\"Q\", cx, cy, x, y, ''].join(\" \");\n      }\n    } else if (lop === \"t\") {\n      for (a = 0; a < alen; a += 2) {\n        // reflect previous cx/cy over x/y\n        cx = x + (x - cx);\n        cy = y + (y - cy); // then get real end point\n\n        if (op === \"t\") {\n          x += args[a];\n          y += args[a + 1];\n        } else {\n          x = args[a];\n          y = args[a + 1];\n        }\n\n        normalized += [\"Q\", cx, cy, x, y, ''].join(\" \");\n      }\n    } else if (lop === \"c\") {\n      // cubic curveto commands\n      for (a = 0; a < alen; a += 6) {\n        if (op === \"c\") {\n          cx = x + args[a];\n          cy = y + args[a + 1];\n          cx2 = x + args[a + 2];\n          cy2 = y + args[a + 3];\n          x += args[a + 4];\n          y += args[a + 5];\n        } else {\n          cx = args[a];\n          cy = args[a + 1];\n          cx2 = args[a + 2];\n          cy2 = args[a + 3];\n          x = args[a + 4];\n          y = args[a + 5];\n        }\n\n        normalized += [\"C\", cx, cy, cx2, cy2, x, y, ''].join(\" \");\n      }\n    } else if (lop === \"s\") {\n      for (a = 0; a < alen; a += 4) {\n        // reflect previous cx2/cy2 over x/y\n        cx = x + (x - cx2);\n        cy = y + (y - cy2); // then get real control and end point\n\n        if (op === \"s\") {\n          cx2 = x + args[a];\n          cy2 = y + args[a + 1];\n          x += args[a + 2];\n          y += args[a + 3];\n        } else {\n          cx2 = args[a];\n          cy2 = args[a + 1];\n          x = args[a + 2];\n          y = args[a + 3];\n        }\n\n        normalized += [\"C\", cx, cy, cx2, cy2, x, y, ''].join(\" \");\n      }\n    } else if (lop === \"z\") {\n      normalized += \"Z \"; // not unimportant: path closing changes the current x/y coordinate\n\n      x = sx;\n      y = sy;\n    }\n  }\n\n  return normalized.trim();\n}\n\nmodule.exports = normalizePath;","map":null,"metadata":{},"sourceType":"script"}