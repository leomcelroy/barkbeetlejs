{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = global || self, global.svgson = factory());\n})(this, function () {\n  'use strict';\n\n  function _defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  function _objectSpread(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n      var ownKeys = Object.keys(source);\n\n      if (typeof Object.getOwnPropertySymbols === 'function') {\n        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n          return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n        }));\n      }\n\n      ownKeys.forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    }\n\n    return target;\n  }\n  /*!\n   * isobject <https://github.com/jonschlinkert/isobject>\n   *\n   * Copyright (c) 2014-2017, Jon Schlinkert.\n   * Released under the MIT License.\n   */\n\n\n  var isobject = function isObject(val) {\n    return val != null && typeof val === 'object' && Array.isArray(val) === false;\n  };\n\n  function isObjectObject(o) {\n    return isobject(o) === true && Object.prototype.toString.call(o) === '[object Object]';\n  }\n\n  var isPlainObject = function isPlainObject(o) {\n    var ctor, prot;\n    if (isObjectObject(o) === false) return false; // If has modified constructor\n\n    ctor = o.constructor;\n    if (typeof ctor !== 'function') return false; // If has modified prototype\n\n    prot = ctor.prototype;\n    if (isObjectObject(prot) === false) return false; // If constructor does not have an Object-specific method\n\n    if (prot.hasOwnProperty('isPrototypeOf') === false) {\n      return false;\n    } // Most likely a plain Object\n\n\n    return true;\n  };\n\n  var toString = {}.toString;\n\n  var isarray = Array.isArray || function (arr) {\n    return toString.call(arr) == '[object Array]';\n  };\n\n  var isobject$1 = function isObject(val) {\n    return val != null && typeof val === 'object' && isarray(val) === false;\n  };\n  /*!\n   * has-values <https://github.com/jonschlinkert/has-values>\n   *\n   * Copyright (c) 2014-2015, Jon Schlinkert.\n   * Licensed under the MIT License.\n   */\n\n\n  var hasValues = function hasValue(o, noZero) {\n    if (o === null || o === undefined) {\n      return false;\n    }\n\n    if (typeof o === 'boolean') {\n      return true;\n    }\n\n    if (typeof o === 'number') {\n      if (o === 0 && noZero === true) {\n        return false;\n      }\n\n      return true;\n    }\n\n    if (o.length !== undefined) {\n      return o.length !== 0;\n    }\n\n    for (var key in o) {\n      if (o.hasOwnProperty(key)) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /*!\n   * get-value <https://github.com/jonschlinkert/get-value>\n   *\n   * Copyright (c) 2014-2015, Jon Schlinkert.\n   * Licensed under the MIT License.\n   */\n\n\n  var getValue = function getValue(obj, prop, a, b, c) {\n    if (!isObject(obj) || !prop) {\n      return obj;\n    }\n\n    prop = toString$1(prop); // allowing for multiple properties to be passed as\n    // a string or array, but much faster (3-4x) than doing\n    // `[].slice.call(arguments)`\n\n    if (a) prop += '.' + toString$1(a);\n    if (b) prop += '.' + toString$1(b);\n    if (c) prop += '.' + toString$1(c);\n\n    if (prop in obj) {\n      return obj[prop];\n    }\n\n    var segs = prop.split('.');\n    var len = segs.length;\n    var i = -1;\n\n    while (obj && ++i < len) {\n      var key = segs[i];\n\n      while (key[key.length - 1] === '\\\\') {\n        key = key.slice(0, -1) + '.' + segs[++i];\n      }\n\n      obj = obj[key];\n    }\n\n    return obj;\n  };\n\n  function isObject(val) {\n    return val !== null && (typeof val === 'object' || typeof val === 'function');\n  }\n\n  function toString$1(val) {\n    if (!val) return '';\n\n    if (Array.isArray(val)) {\n      return val.join('.');\n    }\n\n    return val;\n  }\n\n  var hasValue = function hasValue(obj, prop, noZero) {\n    if (isobject$1(obj)) {\n      return hasValues(getValue(obj, prop), noZero);\n    }\n\n    return hasValues(obj, prop);\n  };\n\n  var unsetValue = function unset(obj, prop) {\n    if (!isobject(obj)) {\n      throw new TypeError('expected an object.');\n    }\n\n    if (obj.hasOwnProperty(prop)) {\n      delete obj[prop];\n      return true;\n    }\n\n    if (hasValue(obj, prop)) {\n      var segs = prop.split('.');\n      var last = segs.pop();\n\n      while (segs.length && segs[segs.length - 1].slice(-1) === '\\\\') {\n        last = segs.pop().slice(0, -1) + '.' + last;\n      }\n\n      while (segs.length) {\n        obj = obj[prop = segs.shift()];\n      }\n\n      return delete obj[last];\n    }\n\n    return true;\n  };\n\n  var omitDeep = function omitDeep(value, keys) {\n    if (typeof value === 'undefined') {\n      return {};\n    }\n\n    if (Array.isArray(value)) {\n      for (var i = 0; i < value.length; i++) {\n        value[i] = omitDeep(value[i], keys);\n      }\n\n      return value;\n    }\n\n    if (!isPlainObject(value)) {\n      return value;\n    }\n\n    if (typeof keys === 'string') {\n      keys = [keys];\n    }\n\n    if (!Array.isArray(keys)) {\n      return value;\n    }\n\n    for (var j = 0; j < keys.length; j++) {\n      unsetValue(value, keys[j]);\n    }\n\n    for (var key in value) {\n      if (value.hasOwnProperty(key)) {\n        value[key] = omitDeep(value[key], keys);\n      }\n    }\n\n    return value;\n  };\n  /*!\n   * Determine if an object is a Buffer\n   *\n   * @author   Feross Aboukhadijeh <https://feross.org>\n   * @license  MIT\n   */\n  // The _isBuffer check is for Safari 5-7 support, because it's missing\n  // Object.prototype.constructor. Remove this eventually\n\n\n  var isBuffer_1 = function isBuffer_1(obj) {\n    return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);\n  };\n\n  function isBuffer(obj) {\n    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);\n  } // For Node v0.10 support. Remove this eventually.\n\n\n  function isSlowBuffer(obj) {\n    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));\n  }\n\n  var toString$2 = Object.prototype.toString;\n  /**\n   * Get the native `typeof` a value.\n   *\n   * @param  {*} `val`\n   * @return {*} Native javascript type\n   */\n\n  var kindOf = function kindOf(val) {\n    // primitivies\n    if (typeof val === 'undefined') {\n      return 'undefined';\n    }\n\n    if (val === null) {\n      return 'null';\n    }\n\n    if (val === true || val === false || val instanceof Boolean) {\n      return 'boolean';\n    }\n\n    if (typeof val === 'string' || val instanceof String) {\n      return 'string';\n    }\n\n    if (typeof val === 'number' || val instanceof Number) {\n      return 'number';\n    } // functions\n\n\n    if (typeof val === 'function' || val instanceof Function) {\n      return 'function';\n    } // array\n\n\n    if (typeof Array.isArray !== 'undefined' && Array.isArray(val)) {\n      return 'array';\n    } // check for instances of RegExp and Date before calling `toString`\n\n\n    if (val instanceof RegExp) {\n      return 'regexp';\n    }\n\n    if (val instanceof Date) {\n      return 'date';\n    } // other objects\n\n\n    var type = toString$2.call(val);\n\n    if (type === '[object RegExp]') {\n      return 'regexp';\n    }\n\n    if (type === '[object Date]') {\n      return 'date';\n    }\n\n    if (type === '[object Arguments]') {\n      return 'arguments';\n    }\n\n    if (type === '[object Error]') {\n      return 'error';\n    } // buffer\n\n\n    if (isBuffer_1(val)) {\n      return 'buffer';\n    } // es6: Map, WeakMap, Set, WeakSet\n\n\n    if (type === '[object Set]') {\n      return 'set';\n    }\n\n    if (type === '[object WeakSet]') {\n      return 'weakset';\n    }\n\n    if (type === '[object Map]') {\n      return 'map';\n    }\n\n    if (type === '[object WeakMap]') {\n      return 'weakmap';\n    }\n\n    if (type === '[object Symbol]') {\n      return 'symbol';\n    } // typed arrays\n\n\n    if (type === '[object Int8Array]') {\n      return 'int8array';\n    }\n\n    if (type === '[object Uint8Array]') {\n      return 'uint8array';\n    }\n\n    if (type === '[object Uint8ClampedArray]') {\n      return 'uint8clampedarray';\n    }\n\n    if (type === '[object Int16Array]') {\n      return 'int16array';\n    }\n\n    if (type === '[object Uint16Array]') {\n      return 'uint16array';\n    }\n\n    if (type === '[object Int32Array]') {\n      return 'int32array';\n    }\n\n    if (type === '[object Uint32Array]') {\n      return 'uint32array';\n    }\n\n    if (type === '[object Float32Array]') {\n      return 'float32array';\n    }\n\n    if (type === '[object Float64Array]') {\n      return 'float64array';\n    } // must be a plain object\n\n\n    return 'object';\n  };\n\n  var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n  function unwrapExports(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x.default : x;\n  }\n\n  function createCommonjsModule(fn, module) {\n    return module = {\n      exports: {}\n    }, fn(module, module.exports), module.exports;\n  }\n\n  var renameKeys = createCommonjsModule(function (module) {\n    (function () {\n      function rename(obj, fn) {\n        if (typeof fn !== 'function') {\n          return obj;\n        }\n\n        var res = {};\n\n        for (var key in obj) {\n          if (Object.prototype.hasOwnProperty.call(obj, key)) {\n            res[fn(key, obj[key]) || key] = obj[key];\n          }\n        }\n\n        return res;\n      }\n\n      if (module.exports) {\n        module.exports = rename;\n      } else {\n        {\n          window.rename = rename;\n        }\n      }\n    })();\n  });\n  /**\n   * Expose `renameDeep`\n   */\n\n  var deepRenameKeys = function renameDeep(obj, cb) {\n    var type = kindOf(obj);\n\n    if (type !== 'object' && type !== 'array') {\n      throw new Error('expected an object');\n    }\n\n    var res = [];\n\n    if (type === 'object') {\n      obj = renameKeys(obj, cb);\n      res = {};\n    }\n\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        var val = obj[key];\n\n        if (kindOf(val) === 'object' || kindOf(val) === 'array') {\n          res[key] = renameDeep(val, cb);\n        } else {\n          res[key] = val;\n        }\n      }\n    }\n\n    return res;\n  };\n\n  var lodash_isempty = createCommonjsModule(function (module, exports) {\n    /**\n     * lodash (Custom Build) <https://lodash.com/>\n     * Build: `lodash modularize exports=\"npm\" -o ./`\n     * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n     * Released under MIT license <https://lodash.com/license>\n     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n     */\n\n    /** Used as references for various `Number` constants. */\n    var MAX_SAFE_INTEGER = 9007199254740991;\n    /** `Object#toString` result references. */\n\n    var argsTag = '[object Arguments]',\n        funcTag = '[object Function]',\n        genTag = '[object GeneratorFunction]',\n        mapTag = '[object Map]',\n        objectTag = '[object Object]',\n        promiseTag = '[object Promise]',\n        setTag = '[object Set]',\n        weakMapTag = '[object WeakMap]';\n    var dataViewTag = '[object DataView]';\n    /**\n     * Used to match `RegExp`\n     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n     */\n\n    var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n    /** Used to detect host constructors (Safari). */\n\n    var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n    /** Detect free variable `global` from Node.js. */\n\n    var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\n    /** Detect free variable `self`. */\n\n    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n    /** Used as a reference to the global object. */\n\n    var root = freeGlobal || freeSelf || Function('return this')();\n    /** Detect free variable `exports`. */\n\n    var freeExports = exports && !exports.nodeType && exports;\n    /** Detect free variable `module`. */\n\n    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;\n    /** Detect the popular CommonJS extension `module.exports`. */\n\n    var moduleExports = freeModule && freeModule.exports === freeExports;\n    /**\n     * Gets the value at `key` of `object`.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {string} key The key of the property to get.\n     * @returns {*} Returns the property value.\n     */\n\n    function getValue(object, key) {\n      return object == null ? undefined : object[key];\n    }\n    /**\n     * Checks if `value` is a host object in IE < 9.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n     */\n\n\n    function isHostObject(value) {\n      // Many host objects are `Object` objects that can coerce to strings\n      // despite having improperly defined `toString` methods.\n      var result = false;\n\n      if (value != null && typeof value.toString != 'function') {\n        try {\n          result = !!(value + '');\n        } catch (e) {}\n      }\n\n      return result;\n    }\n    /**\n     * Creates a unary function that invokes `func` with its argument transformed.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {Function} transform The argument transform.\n     * @returns {Function} Returns the new function.\n     */\n\n\n    function overArg(func, transform) {\n      return function (arg) {\n        return func(transform(arg));\n      };\n    }\n    /** Used for built-in method references. */\n\n\n    var funcProto = Function.prototype,\n        objectProto = Object.prototype;\n    /** Used to detect overreaching core-js shims. */\n\n    var coreJsData = root['__core-js_shared__'];\n    /** Used to detect methods masquerading as native. */\n\n    var maskSrcKey = function () {\n      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n      return uid ? 'Symbol(src)_1.' + uid : '';\n    }();\n    /** Used to resolve the decompiled source of functions. */\n\n\n    var funcToString = funcProto.toString;\n    /** Used to check objects for own properties. */\n\n    var hasOwnProperty = objectProto.hasOwnProperty;\n    /**\n     * Used to resolve the\n     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n     * of values.\n     */\n\n    var objectToString = objectProto.toString;\n    /** Used to detect if a method is native. */\n\n    var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&').replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$');\n    /** Built-in value references. */\n\n    var Buffer = moduleExports ? root.Buffer : undefined,\n        propertyIsEnumerable = objectProto.propertyIsEnumerable;\n    /* Built-in method references for those with the same name as other `lodash` methods. */\n\n    var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,\n        nativeKeys = overArg(Object.keys, Object);\n    /* Built-in method references that are verified to be native. */\n\n    var DataView = getNative(root, 'DataView'),\n        Map = getNative(root, 'Map'),\n        Promise = getNative(root, 'Promise'),\n        Set = getNative(root, 'Set'),\n        WeakMap = getNative(root, 'WeakMap');\n    /** Detect if properties shadowing those on `Object.prototype` are non-enumerable. */\n\n    var nonEnumShadows = !propertyIsEnumerable.call({\n      'valueOf': 1\n    }, 'valueOf');\n    /** Used to detect maps, sets, and weakmaps. */\n\n    var dataViewCtorString = toSource(DataView),\n        mapCtorString = toSource(Map),\n        promiseCtorString = toSource(Promise),\n        setCtorString = toSource(Set),\n        weakMapCtorString = toSource(WeakMap);\n    /**\n     * The base implementation of `getTag`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n\n    function baseGetTag(value) {\n      return objectToString.call(value);\n    }\n    /**\n     * The base implementation of `_.isNative` without bad shim checks.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function,\n     *  else `false`.\n     */\n\n\n    function baseIsNative(value) {\n      if (!isObject(value) || isMasked(value)) {\n        return false;\n      }\n\n      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;\n      return pattern.test(toSource(value));\n    }\n    /**\n     * Gets the native function at `key` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the method to get.\n     * @returns {*} Returns the function if it's native, else `undefined`.\n     */\n\n\n    function getNative(object, key) {\n      var value = getValue(object, key);\n      return baseIsNative(value) ? value : undefined;\n    }\n    /**\n     * Gets the `toStringTag` of `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n\n\n    var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11,\n    // for data views in Edge < 14, and promises in Node.js.\n\n    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {\n      getTag = function getTag(value) {\n        var result = objectToString.call(value),\n            Ctor = result == objectTag ? value.constructor : undefined,\n            ctorString = Ctor ? toSource(Ctor) : undefined;\n\n        if (ctorString) {\n          switch (ctorString) {\n            case dataViewCtorString:\n              return dataViewTag;\n\n            case mapCtorString:\n              return mapTag;\n\n            case promiseCtorString:\n              return promiseTag;\n\n            case setCtorString:\n              return setTag;\n\n            case weakMapCtorString:\n              return weakMapTag;\n          }\n        }\n\n        return result;\n      };\n    }\n    /**\n     * Checks if `func` has its source masked.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n     */\n\n\n    function isMasked(func) {\n      return !!maskSrcKey && maskSrcKey in func;\n    }\n    /**\n     * Checks if `value` is likely a prototype object.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n     */\n\n\n    function isPrototype(value) {\n      var Ctor = value && value.constructor,\n          proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;\n      return value === proto;\n    }\n    /**\n     * Converts `func` to its source code.\n     *\n     * @private\n     * @param {Function} func The function to process.\n     * @returns {string} Returns the source code.\n     */\n\n\n    function toSource(func) {\n      if (func != null) {\n        try {\n          return funcToString.call(func);\n        } catch (e) {}\n\n        try {\n          return func + '';\n        } catch (e) {}\n      }\n\n      return '';\n    }\n    /**\n     * Checks if `value` is likely an `arguments` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArguments(function() { return arguments; }());\n     * // => true\n     *\n     * _.isArguments([1, 2, 3]);\n     * // => false\n     */\n\n\n    function isArguments(value) {\n      // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n      return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n    }\n    /**\n     * Checks if `value` is classified as an `Array` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n     * @example\n     *\n     * _.isArray([1, 2, 3]);\n     * // => true\n     *\n     * _.isArray(document.body.children);\n     * // => false\n     *\n     * _.isArray('abc');\n     * // => false\n     *\n     * _.isArray(_.noop);\n     * // => false\n     */\n\n\n    var isArray = Array.isArray;\n    /**\n     * Checks if `value` is array-like. A value is considered array-like if it's\n     * not a function and has a `value.length` that's an integer greater than or\n     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n     * @example\n     *\n     * _.isArrayLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLike(document.body.children);\n     * // => true\n     *\n     * _.isArrayLike('abc');\n     * // => true\n     *\n     * _.isArrayLike(_.noop);\n     * // => false\n     */\n\n    function isArrayLike(value) {\n      return value != null && isLength(value.length) && !isFunction(value);\n    }\n    /**\n     * This method is like `_.isArrayLike` except that it also checks if `value`\n     * is an object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array-like object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArrayLikeObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLikeObject(document.body.children);\n     * // => true\n     *\n     * _.isArrayLikeObject('abc');\n     * // => false\n     *\n     * _.isArrayLikeObject(_.noop);\n     * // => false\n     */\n\n\n    function isArrayLikeObject(value) {\n      return isObjectLike(value) && isArrayLike(value);\n    }\n    /**\n     * Checks if `value` is a buffer.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.3.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\n     * @example\n     *\n     * _.isBuffer(new Buffer(2));\n     * // => true\n     *\n     * _.isBuffer(new Uint8Array(2));\n     * // => false\n     */\n\n\n    var isBuffer = nativeIsBuffer || stubFalse;\n    /**\n     * Checks if `value` is an empty object, collection, map, or set.\n     *\n     * Objects are considered empty if they have no own enumerable string keyed\n     * properties.\n     *\n     * Array-like values such as `arguments` objects, arrays, buffers, strings, or\n     * jQuery-like collections are considered empty if they have a `length` of `0`.\n     * Similarly, maps and sets are considered empty if they have a `size` of `0`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is empty, else `false`.\n     * @example\n     *\n     * _.isEmpty(null);\n     * // => true\n     *\n     * _.isEmpty(true);\n     * // => true\n     *\n     * _.isEmpty(1);\n     * // => true\n     *\n     * _.isEmpty([1, 2, 3]);\n     * // => false\n     *\n     * _.isEmpty({ 'a': 1 });\n     * // => false\n     */\n\n    function isEmpty(value) {\n      if (isArrayLike(value) && (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' || isBuffer(value) || isArguments(value))) {\n        return !value.length;\n      }\n\n      var tag = getTag(value);\n\n      if (tag == mapTag || tag == setTag) {\n        return !value.size;\n      }\n\n      if (nonEnumShadows || isPrototype(value)) {\n        return !nativeKeys(value).length;\n      }\n\n      for (var key in value) {\n        if (hasOwnProperty.call(value, key)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Checks if `value` is classified as a `Function` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n     * @example\n     *\n     * _.isFunction(_);\n     * // => true\n     *\n     * _.isFunction(/abc/);\n     * // => false\n     */\n\n\n    function isFunction(value) {\n      // The use of `Object#toString` avoids issues with the `typeof` operator\n      // in Safari 8-9 which returns 'object' for typed array and other constructors.\n      var tag = isObject(value) ? objectToString.call(value) : '';\n      return tag == funcTag || tag == genTag;\n    }\n    /**\n     * Checks if `value` is a valid array-like length.\n     *\n     * **Note:** This method is loosely based on\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n     * @example\n     *\n     * _.isLength(3);\n     * // => true\n     *\n     * _.isLength(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isLength(Infinity);\n     * // => false\n     *\n     * _.isLength('3');\n     * // => false\n     */\n\n\n    function isLength(value) {\n      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n    }\n    /**\n     * Checks if `value` is the\n     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n     * @example\n     *\n     * _.isObject({});\n     * // => true\n     *\n     * _.isObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isObject(_.noop);\n     * // => true\n     *\n     * _.isObject(null);\n     * // => false\n     */\n\n\n    function isObject(value) {\n      var type = typeof value;\n      return !!value && (type == 'object' || type == 'function');\n    }\n    /**\n     * Checks if `value` is object-like. A value is object-like if it's not `null`\n     * and has a `typeof` result of \"object\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n     * @example\n     *\n     * _.isObjectLike({});\n     * // => true\n     *\n     * _.isObjectLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isObjectLike(_.noop);\n     * // => false\n     *\n     * _.isObjectLike(null);\n     * // => false\n     */\n\n\n    function isObjectLike(value) {\n      return !!value && typeof value == 'object';\n    }\n    /**\n     * This method returns `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.13.0\n     * @category Util\n     * @returns {boolean} Returns `false`.\n     * @example\n     *\n     * _.times(2, _.stubFalse);\n     * // => [false, false]\n     */\n\n\n    function stubFalse() {\n      return false;\n    }\n\n    module.exports = isEmpty;\n  });\n  /**\n   * lodash (Custom Build) <https://lodash.com/>\n   * Build: `lodash modularize exports=\"npm\" -o ./`\n   * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n   * Released under MIT license <https://lodash.com/license>\n   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n   */\n\n  /** `Object#toString` result references. */\n\n  var objectTag = '[object Object]';\n  /**\n   * Checks if `value` is a host object in IE < 9.\n   *\n   * @private\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n   */\n\n  function isHostObject(value) {\n    // Many host objects are `Object` objects that can coerce to strings\n    // despite having improperly defined `toString` methods.\n    var result = false;\n\n    if (value != null && typeof value.toString != 'function') {\n      try {\n        result = !!(value + '');\n      } catch (e) {}\n    }\n\n    return result;\n  }\n  /**\n   * Creates a unary function that invokes `func` with its argument transformed.\n   *\n   * @private\n   * @param {Function} func The function to wrap.\n   * @param {Function} transform The argument transform.\n   * @returns {Function} Returns the new function.\n   */\n\n\n  function overArg(func, transform) {\n    return function (arg) {\n      return func(transform(arg));\n    };\n  }\n  /** Used for built-in method references. */\n\n\n  var funcProto = Function.prototype,\n      objectProto = Object.prototype;\n  /** Used to resolve the decompiled source of functions. */\n\n  var funcToString = funcProto.toString;\n  /** Used to check objects for own properties. */\n\n  var hasOwnProperty = objectProto.hasOwnProperty;\n  /** Used to infer the `Object` constructor. */\n\n  var objectCtorString = funcToString.call(Object);\n  /**\n   * Used to resolve the\n   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n   * of values.\n   */\n\n  var objectToString = objectProto.toString;\n  /** Built-in value references. */\n\n  var getPrototype = overArg(Object.getPrototypeOf, Object);\n  /**\n   * Checks if `value` is object-like. A value is object-like if it's not `null`\n   * and has a `typeof` result of \"object\".\n   *\n   * @static\n   * @memberOf _\n   * @since 4.0.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n   * @example\n   *\n   * _.isObjectLike({});\n   * // => true\n   *\n   * _.isObjectLike([1, 2, 3]);\n   * // => true\n   *\n   * _.isObjectLike(_.noop);\n   * // => false\n   *\n   * _.isObjectLike(null);\n   * // => false\n   */\n\n  function isObjectLike(value) {\n    return !!value && typeof value == 'object';\n  }\n  /**\n   * Checks if `value` is a plain object, that is, an object created by the\n   * `Object` constructor or one with a `[[Prototype]]` of `null`.\n   *\n   * @static\n   * @memberOf _\n   * @since 0.8.0\n   * @category Lang\n   * @param {*} value The value to check.\n   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n   * @example\n   *\n   * function Foo() {\n   *   this.a = 1;\n   * }\n   *\n   * _.isPlainObject(new Foo);\n   * // => false\n   *\n   * _.isPlainObject([1, 2, 3]);\n   * // => false\n   *\n   * _.isPlainObject({ 'x': 0, 'y': 0 });\n   * // => true\n   *\n   * _.isPlainObject(Object.create(null));\n   * // => true\n   */\n\n\n  function isPlainObject$1(value) {\n    if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {\n      return false;\n    }\n\n    var proto = getPrototype(value);\n\n    if (proto === null) {\n      return true;\n    }\n\n    var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n    return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;\n  }\n\n  var lodash_isplainobject = isPlainObject$1;\n  var lodash_transform = createCommonjsModule(function (module, exports) {\n    /**\n     * lodash (Custom Build) <https://lodash.com/>\n     * Build: `lodash modularize exports=\"npm\" -o ./`\n     * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n     * Released under MIT license <https://lodash.com/license>\n     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n     */\n\n    /** Used as the size to enable large array optimizations. */\n    var LARGE_ARRAY_SIZE = 200;\n    /** Used as the `TypeError` message for \"Functions\" methods. */\n\n    var FUNC_ERROR_TEXT = 'Expected a function';\n    /** Used to stand-in for `undefined` hash values. */\n\n    var HASH_UNDEFINED = '__lodash_hash_undefined__';\n    /** Used to compose bitmasks for comparison styles. */\n\n    var UNORDERED_COMPARE_FLAG = 1,\n        PARTIAL_COMPARE_FLAG = 2;\n    /** Used as references for various `Number` constants. */\n\n    var INFINITY = 1 / 0,\n        MAX_SAFE_INTEGER = 9007199254740991;\n    /** `Object#toString` result references. */\n\n    var argsTag = '[object Arguments]',\n        arrayTag = '[object Array]',\n        boolTag = '[object Boolean]',\n        dateTag = '[object Date]',\n        errorTag = '[object Error]',\n        funcTag = '[object Function]',\n        genTag = '[object GeneratorFunction]',\n        mapTag = '[object Map]',\n        numberTag = '[object Number]',\n        objectTag = '[object Object]',\n        promiseTag = '[object Promise]',\n        regexpTag = '[object RegExp]',\n        setTag = '[object Set]',\n        stringTag = '[object String]',\n        symbolTag = '[object Symbol]',\n        weakMapTag = '[object WeakMap]';\n    var arrayBufferTag = '[object ArrayBuffer]',\n        dataViewTag = '[object DataView]',\n        float32Tag = '[object Float32Array]',\n        float64Tag = '[object Float64Array]',\n        int8Tag = '[object Int8Array]',\n        int16Tag = '[object Int16Array]',\n        int32Tag = '[object Int32Array]',\n        uint8Tag = '[object Uint8Array]',\n        uint8ClampedTag = '[object Uint8ClampedArray]',\n        uint16Tag = '[object Uint16Array]',\n        uint32Tag = '[object Uint32Array]';\n    /** Used to match property names within property paths. */\n\n    var reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n        reIsPlainProp = /^\\w*$/,\n        reLeadingDot = /^\\./,\n        rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n    /**\n     * Used to match `RegExp`\n     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n     */\n\n    var reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n    /** Used to match backslashes in property paths. */\n\n    var reEscapeChar = /\\\\(\\\\)?/g;\n    /** Used to detect host constructors (Safari). */\n\n    var reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n    /** Used to detect unsigned integer values. */\n\n    var reIsUint = /^(?:0|[1-9]\\d*)$/;\n    /** Used to identify `toStringTag` values of typed arrays. */\n\n    var typedArrayTags = {};\n    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;\n    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;\n    /** Detect free variable `global` from Node.js. */\n\n    var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;\n    /** Detect free variable `self`. */\n\n    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n    /** Used as a reference to the global object. */\n\n    var root = freeGlobal || freeSelf || Function('return this')();\n    /** Detect free variable `exports`. */\n\n    var freeExports = exports && !exports.nodeType && exports;\n    /** Detect free variable `module`. */\n\n    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;\n    /** Detect the popular CommonJS extension `module.exports`. */\n\n    var moduleExports = freeModule && freeModule.exports === freeExports;\n    /** Detect free variable `process` from Node.js. */\n\n    var freeProcess = moduleExports && freeGlobal.process;\n    /** Used to access faster Node.js helpers. */\n\n    var nodeUtil = function () {\n      try {\n        return freeProcess && freeProcess.binding('util');\n      } catch (e) {}\n    }();\n    /* Node.js helper references. */\n\n\n    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\n    /**\n     * A specialized version of `_.forEach` for arrays without support for\n     * iteratee shorthands.\n     *\n     * @private\n     * @param {Array} [array] The array to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns `array`.\n     */\n\n    function arrayEach(array, iteratee) {\n      var index = -1,\n          length = array ? array.length : 0;\n\n      while (++index < length) {\n        if (iteratee(array[index], index, array) === false) {\n          break;\n        }\n      }\n\n      return array;\n    }\n    /**\n     * A specialized version of `_.some` for arrays without support for iteratee\n     * shorthands.\n     *\n     * @private\n     * @param {Array} [array] The array to iterate over.\n     * @param {Function} predicate The function invoked per iteration.\n     * @returns {boolean} Returns `true` if any element passes the predicate check,\n     *  else `false`.\n     */\n\n\n    function arraySome(array, predicate) {\n      var index = -1,\n          length = array ? array.length : 0;\n\n      while (++index < length) {\n        if (predicate(array[index], index, array)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n    /**\n     * The base implementation of `_.property` without support for deep paths.\n     *\n     * @private\n     * @param {string} key The key of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     */\n\n\n    function baseProperty(key) {\n      return function (object) {\n        return object == null ? undefined : object[key];\n      };\n    }\n    /**\n     * The base implementation of `_.times` without support for iteratee shorthands\n     * or max array length checks.\n     *\n     * @private\n     * @param {number} n The number of times to invoke `iteratee`.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Array} Returns the array of results.\n     */\n\n\n    function baseTimes(n, iteratee) {\n      var index = -1,\n          result = Array(n);\n\n      while (++index < n) {\n        result[index] = iteratee(index);\n      }\n\n      return result;\n    }\n    /**\n     * The base implementation of `_.unary` without support for storing metadata.\n     *\n     * @private\n     * @param {Function} func The function to cap arguments for.\n     * @returns {Function} Returns the new capped function.\n     */\n\n\n    function baseUnary(func) {\n      return function (value) {\n        return func(value);\n      };\n    }\n    /**\n     * Gets the value at `key` of `object`.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {string} key The key of the property to get.\n     * @returns {*} Returns the property value.\n     */\n\n\n    function getValue(object, key) {\n      return object == null ? undefined : object[key];\n    }\n    /**\n     * Checks if `value` is a host object in IE < 9.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n     */\n\n\n    function isHostObject(value) {\n      // Many host objects are `Object` objects that can coerce to strings\n      // despite having improperly defined `toString` methods.\n      var result = false;\n\n      if (value != null && typeof value.toString != 'function') {\n        try {\n          result = !!(value + '');\n        } catch (e) {}\n      }\n\n      return result;\n    }\n    /**\n     * Converts `map` to its key-value pairs.\n     *\n     * @private\n     * @param {Object} map The map to convert.\n     * @returns {Array} Returns the key-value pairs.\n     */\n\n\n    function mapToArray(map) {\n      var index = -1,\n          result = Array(map.size);\n      map.forEach(function (value, key) {\n        result[++index] = [key, value];\n      });\n      return result;\n    }\n    /**\n     * Creates a unary function that invokes `func` with its argument transformed.\n     *\n     * @private\n     * @param {Function} func The function to wrap.\n     * @param {Function} transform The argument transform.\n     * @returns {Function} Returns the new function.\n     */\n\n\n    function overArg(func, transform) {\n      return function (arg) {\n        return func(transform(arg));\n      };\n    }\n    /**\n     * Converts `set` to an array of its values.\n     *\n     * @private\n     * @param {Object} set The set to convert.\n     * @returns {Array} Returns the values.\n     */\n\n\n    function setToArray(set) {\n      var index = -1,\n          result = Array(set.size);\n      set.forEach(function (value) {\n        result[++index] = value;\n      });\n      return result;\n    }\n    /** Used for built-in method references. */\n\n\n    var arrayProto = Array.prototype,\n        funcProto = Function.prototype,\n        objectProto = Object.prototype;\n    /** Used to detect overreaching core-js shims. */\n\n    var coreJsData = root['__core-js_shared__'];\n    /** Used to detect methods masquerading as native. */\n\n    var maskSrcKey = function () {\n      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n      return uid ? 'Symbol(src)_1.' + uid : '';\n    }();\n    /** Used to resolve the decompiled source of functions. */\n\n\n    var funcToString = funcProto.toString;\n    /** Used to check objects for own properties. */\n\n    var hasOwnProperty = objectProto.hasOwnProperty;\n    /**\n     * Used to resolve the\n     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n     * of values.\n     */\n\n    var objectToString = objectProto.toString;\n    /** Used to detect if a method is native. */\n\n    var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&').replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$');\n    /** Built-in value references. */\n\n    var Symbol = root.Symbol,\n        Uint8Array = root.Uint8Array,\n        getPrototype = overArg(Object.getPrototypeOf, Object),\n        objectCreate = Object.create,\n        propertyIsEnumerable = objectProto.propertyIsEnumerable,\n        splice = arrayProto.splice;\n    /* Built-in method references for those with the same name as other `lodash` methods. */\n\n    var nativeKeys = overArg(Object.keys, Object);\n    /* Built-in method references that are verified to be native. */\n\n    var DataView = getNative(root, 'DataView'),\n        Map = getNative(root, 'Map'),\n        Promise = getNative(root, 'Promise'),\n        Set = getNative(root, 'Set'),\n        WeakMap = getNative(root, 'WeakMap'),\n        nativeCreate = getNative(Object, 'create');\n    /** Used to detect maps, sets, and weakmaps. */\n\n    var dataViewCtorString = toSource(DataView),\n        mapCtorString = toSource(Map),\n        promiseCtorString = toSource(Promise),\n        setCtorString = toSource(Set),\n        weakMapCtorString = toSource(WeakMap);\n    /** Used to convert symbols to primitives and strings. */\n\n    var symbolProto = Symbol ? Symbol.prototype : undefined,\n        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,\n        symbolToString = symbolProto ? symbolProto.toString : undefined;\n    /**\n     * Creates a hash object.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n\n    function Hash(entries) {\n      var index = -1,\n          length = entries ? entries.length : 0;\n      this.clear();\n\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n    /**\n     * Removes all key-value entries from the hash.\n     *\n     * @private\n     * @name clear\n     * @memberOf Hash\n     */\n\n\n    function hashClear() {\n      this.__data__ = nativeCreate ? nativeCreate(null) : {};\n    }\n    /**\n     * Removes `key` and its value from the hash.\n     *\n     * @private\n     * @name delete\n     * @memberOf Hash\n     * @param {Object} hash The hash to modify.\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n\n\n    function hashDelete(key) {\n      return this.has(key) && delete this.__data__[key];\n    }\n    /**\n     * Gets the hash value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Hash\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n\n\n    function hashGet(key) {\n      var data = this.__data__;\n\n      if (nativeCreate) {\n        var result = data[key];\n        return result === HASH_UNDEFINED ? undefined : result;\n      }\n\n      return hasOwnProperty.call(data, key) ? data[key] : undefined;\n    }\n    /**\n     * Checks if a hash value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Hash\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n\n\n    function hashHas(key) {\n      var data = this.__data__;\n      return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n    }\n    /**\n     * Sets the hash `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Hash\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the hash instance.\n     */\n\n\n    function hashSet(key, value) {\n      var data = this.__data__;\n      data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;\n      return this;\n    } // Add methods to `Hash`.\n\n\n    Hash.prototype.clear = hashClear;\n    Hash.prototype['delete'] = hashDelete;\n    Hash.prototype.get = hashGet;\n    Hash.prototype.has = hashHas;\n    Hash.prototype.set = hashSet;\n    /**\n     * Creates an list cache object.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n\n    function ListCache(entries) {\n      var index = -1,\n          length = entries ? entries.length : 0;\n      this.clear();\n\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n    /**\n     * Removes all key-value entries from the list cache.\n     *\n     * @private\n     * @name clear\n     * @memberOf ListCache\n     */\n\n\n    function listCacheClear() {\n      this.__data__ = [];\n    }\n    /**\n     * Removes `key` and its value from the list cache.\n     *\n     * @private\n     * @name delete\n     * @memberOf ListCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n\n\n    function listCacheDelete(key) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      if (index < 0) {\n        return false;\n      }\n\n      var lastIndex = data.length - 1;\n\n      if (index == lastIndex) {\n        data.pop();\n      } else {\n        splice.call(data, index, 1);\n      }\n\n      return true;\n    }\n    /**\n     * Gets the list cache value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf ListCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n\n\n    function listCacheGet(key) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n      return index < 0 ? undefined : data[index][1];\n    }\n    /**\n     * Checks if a list cache value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf ListCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n\n\n    function listCacheHas(key) {\n      return assocIndexOf(this.__data__, key) > -1;\n    }\n    /**\n     * Sets the list cache `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf ListCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the list cache instance.\n     */\n\n\n    function listCacheSet(key, value) {\n      var data = this.__data__,\n          index = assocIndexOf(data, key);\n\n      if (index < 0) {\n        data.push([key, value]);\n      } else {\n        data[index][1] = value;\n      }\n\n      return this;\n    } // Add methods to `ListCache`.\n\n\n    ListCache.prototype.clear = listCacheClear;\n    ListCache.prototype['delete'] = listCacheDelete;\n    ListCache.prototype.get = listCacheGet;\n    ListCache.prototype.has = listCacheHas;\n    ListCache.prototype.set = listCacheSet;\n    /**\n     * Creates a map cache object to store key-value pairs.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n\n    function MapCache(entries) {\n      var index = -1,\n          length = entries ? entries.length : 0;\n      this.clear();\n\n      while (++index < length) {\n        var entry = entries[index];\n        this.set(entry[0], entry[1]);\n      }\n    }\n    /**\n     * Removes all key-value entries from the map.\n     *\n     * @private\n     * @name clear\n     * @memberOf MapCache\n     */\n\n\n    function mapCacheClear() {\n      this.__data__ = {\n        'hash': new Hash(),\n        'map': new (Map || ListCache)(),\n        'string': new Hash()\n      };\n    }\n    /**\n     * Removes `key` and its value from the map.\n     *\n     * @private\n     * @name delete\n     * @memberOf MapCache\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n\n\n    function mapCacheDelete(key) {\n      return getMapData(this, key)['delete'](key);\n    }\n    /**\n     * Gets the map value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf MapCache\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n\n\n    function mapCacheGet(key) {\n      return getMapData(this, key).get(key);\n    }\n    /**\n     * Checks if a map value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf MapCache\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n\n\n    function mapCacheHas(key) {\n      return getMapData(this, key).has(key);\n    }\n    /**\n     * Sets the map `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf MapCache\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the map cache instance.\n     */\n\n\n    function mapCacheSet(key, value) {\n      getMapData(this, key).set(key, value);\n      return this;\n    } // Add methods to `MapCache`.\n\n\n    MapCache.prototype.clear = mapCacheClear;\n    MapCache.prototype['delete'] = mapCacheDelete;\n    MapCache.prototype.get = mapCacheGet;\n    MapCache.prototype.has = mapCacheHas;\n    MapCache.prototype.set = mapCacheSet;\n    /**\n     *\n     * Creates an array cache object to store unique values.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [values] The values to cache.\n     */\n\n    function SetCache(values) {\n      var index = -1,\n          length = values ? values.length : 0;\n      this.__data__ = new MapCache();\n\n      while (++index < length) {\n        this.add(values[index]);\n      }\n    }\n    /**\n     * Adds `value` to the array cache.\n     *\n     * @private\n     * @name add\n     * @memberOf SetCache\n     * @alias push\n     * @param {*} value The value to cache.\n     * @returns {Object} Returns the cache instance.\n     */\n\n\n    function setCacheAdd(value) {\n      this.__data__.set(value, HASH_UNDEFINED);\n\n      return this;\n    }\n    /**\n     * Checks if `value` is in the array cache.\n     *\n     * @private\n     * @name has\n     * @memberOf SetCache\n     * @param {*} value The value to search for.\n     * @returns {number} Returns `true` if `value` is found, else `false`.\n     */\n\n\n    function setCacheHas(value) {\n      return this.__data__.has(value);\n    } // Add methods to `SetCache`.\n\n\n    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\n    SetCache.prototype.has = setCacheHas;\n    /**\n     * Creates a stack cache object to store key-value pairs.\n     *\n     * @private\n     * @constructor\n     * @param {Array} [entries] The key-value pairs to cache.\n     */\n\n    function Stack(entries) {\n      this.__data__ = new ListCache(entries);\n    }\n    /**\n     * Removes all key-value entries from the stack.\n     *\n     * @private\n     * @name clear\n     * @memberOf Stack\n     */\n\n\n    function stackClear() {\n      this.__data__ = new ListCache();\n    }\n    /**\n     * Removes `key` and its value from the stack.\n     *\n     * @private\n     * @name delete\n     * @memberOf Stack\n     * @param {string} key The key of the value to remove.\n     * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n     */\n\n\n    function stackDelete(key) {\n      return this.__data__['delete'](key);\n    }\n    /**\n     * Gets the stack value for `key`.\n     *\n     * @private\n     * @name get\n     * @memberOf Stack\n     * @param {string} key The key of the value to get.\n     * @returns {*} Returns the entry value.\n     */\n\n\n    function stackGet(key) {\n      return this.__data__.get(key);\n    }\n    /**\n     * Checks if a stack value for `key` exists.\n     *\n     * @private\n     * @name has\n     * @memberOf Stack\n     * @param {string} key The key of the entry to check.\n     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n     */\n\n\n    function stackHas(key) {\n      return this.__data__.has(key);\n    }\n    /**\n     * Sets the stack `key` to `value`.\n     *\n     * @private\n     * @name set\n     * @memberOf Stack\n     * @param {string} key The key of the value to set.\n     * @param {*} value The value to set.\n     * @returns {Object} Returns the stack cache instance.\n     */\n\n\n    function stackSet(key, value) {\n      var cache = this.__data__;\n\n      if (cache instanceof ListCache) {\n        var pairs = cache.__data__;\n\n        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {\n          pairs.push([key, value]);\n          return this;\n        }\n\n        cache = this.__data__ = new MapCache(pairs);\n      }\n\n      cache.set(key, value);\n      return this;\n    } // Add methods to `Stack`.\n\n\n    Stack.prototype.clear = stackClear;\n    Stack.prototype['delete'] = stackDelete;\n    Stack.prototype.get = stackGet;\n    Stack.prototype.has = stackHas;\n    Stack.prototype.set = stackSet;\n    /**\n     * Creates an array of the enumerable property names of the array-like `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @param {boolean} inherited Specify returning inherited property names.\n     * @returns {Array} Returns the array of property names.\n     */\n\n    function arrayLikeKeys(value, inherited) {\n      // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n      // Safari 9 makes `arguments.length` enumerable in strict mode.\n      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];\n      var length = result.length,\n          skipIndexes = !!length;\n\n      for (var key in value) {\n        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == 'length' || isIndex(key, length)))) {\n          result.push(key);\n        }\n      }\n\n      return result;\n    }\n    /**\n     * Gets the index at which the `key` is found in `array` of key-value pairs.\n     *\n     * @private\n     * @param {Array} array The array to inspect.\n     * @param {*} key The key to search for.\n     * @returns {number} Returns the index of the matched value, else `-1`.\n     */\n\n\n    function assocIndexOf(array, key) {\n      var length = array.length;\n\n      while (length--) {\n        if (eq(array[length][0], key)) {\n          return length;\n        }\n      }\n\n      return -1;\n    }\n    /**\n     * The base implementation of `_.create` without support for assigning\n     * properties to the created object.\n     *\n     * @private\n     * @param {Object} prototype The object to inherit from.\n     * @returns {Object} Returns the new object.\n     */\n\n\n    function baseCreate(proto) {\n      return isObject(proto) ? objectCreate(proto) : {};\n    }\n    /**\n     * The base implementation of `baseForOwn` which iterates over `object`\n     * properties returned by `keysFunc` and invokes `iteratee` for each property.\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @param {Function} keysFunc The function to get the keys of `object`.\n     * @returns {Object} Returns `object`.\n     */\n\n\n    var baseFor = createBaseFor();\n    /**\n     * The base implementation of `_.forOwn` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to iterate over.\n     * @param {Function} iteratee The function invoked per iteration.\n     * @returns {Object} Returns `object`.\n     */\n\n    function baseForOwn(object, iteratee) {\n      return object && baseFor(object, iteratee, keys);\n    }\n    /**\n     * The base implementation of `_.get` without support for default values.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @returns {*} Returns the resolved value.\n     */\n\n\n    function baseGet(object, path) {\n      path = isKey(path, object) ? [path] : castPath(path);\n      var index = 0,\n          length = path.length;\n\n      while (object != null && index < length) {\n        object = object[toKey(path[index++])];\n      }\n\n      return index && index == length ? object : undefined;\n    }\n    /**\n     * The base implementation of `getTag`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n\n\n    function baseGetTag(value) {\n      return objectToString.call(value);\n    }\n    /**\n     * The base implementation of `_.hasIn` without support for deep paths.\n     *\n     * @private\n     * @param {Object} [object] The object to query.\n     * @param {Array|string} key The key to check.\n     * @returns {boolean} Returns `true` if `key` exists, else `false`.\n     */\n\n\n    function baseHasIn(object, key) {\n      return object != null && key in Object(object);\n    }\n    /**\n     * The base implementation of `_.isEqual` which supports partial comparisons\n     * and tracks traversed objects.\n     *\n     * @private\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @param {boolean} [bitmask] The bitmask of comparison flags.\n     *  The bitmask may be composed of the following flags:\n     *     1 - Unordered comparison\n     *     2 - Partial comparison\n     * @param {Object} [stack] Tracks traversed `value` and `other` objects.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     */\n\n\n    function baseIsEqual(value, other, customizer, bitmask, stack) {\n      if (value === other) {\n        return true;\n      }\n\n      if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {\n        return value !== value && other !== other;\n      }\n\n      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);\n    }\n    /**\n     * A specialized version of `baseIsEqual` for arrays and objects which performs\n     * deep comparisons and tracks traversed objects enabling objects with circular\n     * references to be compared.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @param {number} [bitmask] The bitmask of comparison flags. See `baseIsEqual`\n     *  for more details.\n     * @param {Object} [stack] Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n\n\n    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {\n      var objIsArr = isArray(object),\n          othIsArr = isArray(other),\n          objTag = arrayTag,\n          othTag = arrayTag;\n\n      if (!objIsArr) {\n        objTag = getTag(object);\n        objTag = objTag == argsTag ? objectTag : objTag;\n      }\n\n      if (!othIsArr) {\n        othTag = getTag(other);\n        othTag = othTag == argsTag ? objectTag : othTag;\n      }\n\n      var objIsObj = objTag == objectTag && !isHostObject(object),\n          othIsObj = othTag == objectTag && !isHostObject(other),\n          isSameTag = objTag == othTag;\n\n      if (isSameTag && !objIsObj) {\n        stack || (stack = new Stack());\n        return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);\n      }\n\n      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {\n        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\n            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\n\n        if (objIsWrapped || othIsWrapped) {\n          var objUnwrapped = objIsWrapped ? object.value() : object,\n              othUnwrapped = othIsWrapped ? other.value() : other;\n          stack || (stack = new Stack());\n          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);\n        }\n      }\n\n      if (!isSameTag) {\n        return false;\n      }\n\n      stack || (stack = new Stack());\n      return equalObjects(object, other, equalFunc, customizer, bitmask, stack);\n    }\n    /**\n     * The base implementation of `_.isMatch` without support for iteratee shorthands.\n     *\n     * @private\n     * @param {Object} object The object to inspect.\n     * @param {Object} source The object of property values to match.\n     * @param {Array} matchData The property names, values, and compare flags to match.\n     * @param {Function} [customizer] The function to customize comparisons.\n     * @returns {boolean} Returns `true` if `object` is a match, else `false`.\n     */\n\n\n    function baseIsMatch(object, source, matchData, customizer) {\n      var index = matchData.length,\n          length = index,\n          noCustomizer = !customizer;\n\n      if (object == null) {\n        return !length;\n      }\n\n      object = Object(object);\n\n      while (index--) {\n        var data = matchData[index];\n\n        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {\n          return false;\n        }\n      }\n\n      while (++index < length) {\n        data = matchData[index];\n        var key = data[0],\n            objValue = object[key],\n            srcValue = data[1];\n\n        if (noCustomizer && data[2]) {\n          if (objValue === undefined && !(key in object)) {\n            return false;\n          }\n        } else {\n          var stack = new Stack();\n\n          if (customizer) {\n            var result = customizer(objValue, srcValue, key, object, source, stack);\n          }\n\n          if (!(result === undefined ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    }\n    /**\n     * The base implementation of `_.isNative` without bad shim checks.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a native function,\n     *  else `false`.\n     */\n\n\n    function baseIsNative(value) {\n      if (!isObject(value) || isMasked(value)) {\n        return false;\n      }\n\n      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;\n      return pattern.test(toSource(value));\n    }\n    /**\n     * The base implementation of `_.isTypedArray` without Node.js optimizations.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n     */\n\n\n    function baseIsTypedArray(value) {\n      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];\n    }\n    /**\n     * The base implementation of `_.iteratee`.\n     *\n     * @private\n     * @param {*} [value=_.identity] The value to convert to an iteratee.\n     * @returns {Function} Returns the iteratee.\n     */\n\n\n    function baseIteratee(value) {\n      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\n      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\n      if (typeof value == 'function') {\n        return value;\n      }\n\n      if (value == null) {\n        return identity;\n      }\n\n      if (typeof value == 'object') {\n        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);\n      }\n\n      return property(value);\n    }\n    /**\n     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     */\n\n\n    function baseKeys(object) {\n      if (!isPrototype(object)) {\n        return nativeKeys(object);\n      }\n\n      var result = [];\n\n      for (var key in Object(object)) {\n        if (hasOwnProperty.call(object, key) && key != 'constructor') {\n          result.push(key);\n        }\n      }\n\n      return result;\n    }\n    /**\n     * The base implementation of `_.matches` which doesn't clone `source`.\n     *\n     * @private\n     * @param {Object} source The object of property values to match.\n     * @returns {Function} Returns the new spec function.\n     */\n\n\n    function baseMatches(source) {\n      var matchData = getMatchData(source);\n\n      if (matchData.length == 1 && matchData[0][2]) {\n        return matchesStrictComparable(matchData[0][0], matchData[0][1]);\n      }\n\n      return function (object) {\n        return object === source || baseIsMatch(object, source, matchData);\n      };\n    }\n    /**\n     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\n     *\n     * @private\n     * @param {string} path The path of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     */\n\n\n    function baseMatchesProperty(path, srcValue) {\n      if (isKey(path) && isStrictComparable(srcValue)) {\n        return matchesStrictComparable(toKey(path), srcValue);\n      }\n\n      return function (object) {\n        var objValue = get(object, path);\n        return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, undefined, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);\n      };\n    }\n    /**\n     * A specialized version of `baseProperty` which supports deep paths.\n     *\n     * @private\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     */\n\n\n    function basePropertyDeep(path) {\n      return function (object) {\n        return baseGet(object, path);\n      };\n    }\n    /**\n     * The base implementation of `_.toString` which doesn't convert nullish\n     * values to empty strings.\n     *\n     * @private\n     * @param {*} value The value to process.\n     * @returns {string} Returns the string.\n     */\n\n\n    function baseToString(value) {\n      // Exit early for strings to avoid a performance hit in some environments.\n      if (typeof value == 'string') {\n        return value;\n      }\n\n      if (isSymbol(value)) {\n        return symbolToString ? symbolToString.call(value) : '';\n      }\n\n      var result = value + '';\n      return result == '0' && 1 / value == -INFINITY ? '-0' : result;\n    }\n    /**\n     * Casts `value` to a path array if it's not one.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {Array} Returns the cast property path array.\n     */\n\n\n    function castPath(value) {\n      return isArray(value) ? value : stringToPath(value);\n    }\n    /**\n     * Creates a base function for methods like `_.forIn` and `_.forOwn`.\n     *\n     * @private\n     * @param {boolean} [fromRight] Specify iterating from right to left.\n     * @returns {Function} Returns the new base function.\n     */\n\n\n    function createBaseFor(fromRight) {\n      return function (object, iteratee, keysFunc) {\n        var index = -1,\n            iterable = Object(object),\n            props = keysFunc(object),\n            length = props.length;\n\n        while (length--) {\n          var key = props[fromRight ? length : ++index];\n\n          if (iteratee(iterable[key], key, iterable) === false) {\n            break;\n          }\n        }\n\n        return object;\n      };\n    }\n    /**\n     * A specialized version of `baseIsEqualDeep` for arrays with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Array} array The array to compare.\n     * @param {Array} other The other array to compare.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n     *  for more details.\n     * @param {Object} stack Tracks traversed `array` and `other` objects.\n     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\n     */\n\n\n    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {\n      var isPartial = bitmask & PARTIAL_COMPARE_FLAG,\n          arrLength = array.length,\n          othLength = other.length;\n\n      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\n        return false;\n      } // Assume cyclic values are equal.\n\n\n      var stacked = stack.get(array);\n\n      if (stacked && stack.get(other)) {\n        return stacked == other;\n      }\n\n      var index = -1,\n          result = true,\n          seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : undefined;\n      stack.set(array, other);\n      stack.set(other, array); // Ignore non-index properties.\n\n      while (++index < arrLength) {\n        var arrValue = array[index],\n            othValue = other[index];\n\n        if (customizer) {\n          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);\n        }\n\n        if (compared !== undefined) {\n          if (compared) {\n            continue;\n          }\n\n          result = false;\n          break;\n        } // Recursively compare arrays (susceptible to call stack limits).\n\n\n        if (seen) {\n          if (!arraySome(other, function (othValue, othIndex) {\n            if (!seen.has(othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {\n              return seen.add(othIndex);\n            }\n          })) {\n            result = false;\n            break;\n          }\n        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {\n          result = false;\n          break;\n        }\n      }\n\n      stack['delete'](array);\n      stack['delete'](other);\n      return result;\n    }\n    /**\n     * A specialized version of `baseIsEqualDeep` for comparing objects of\n     * the same `toStringTag`.\n     *\n     * **Note:** This function only supports comparing values with tags of\n     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {string} tag The `toStringTag` of the objects to compare.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n     *  for more details.\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n\n\n    function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {\n      switch (tag) {\n        case dataViewTag:\n          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {\n            return false;\n          }\n\n          object = object.buffer;\n          other = other.buffer;\n\n        case arrayBufferTag:\n          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\n            return false;\n          }\n\n          return true;\n\n        case boolTag:\n        case dateTag:\n        case numberTag:\n          // Coerce booleans to `1` or `0` and dates to milliseconds.\n          // Invalid dates are coerced to `NaN`.\n          return eq(+object, +other);\n\n        case errorTag:\n          return object.name == other.name && object.message == other.message;\n\n        case regexpTag:\n        case stringTag:\n          // Coerce regexes to strings and treat strings, primitives and objects,\n          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\n          // for more details.\n          return object == other + '';\n\n        case mapTag:\n          var convert = mapToArray;\n\n        case setTag:\n          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;\n          convert || (convert = setToArray);\n\n          if (object.size != other.size && !isPartial) {\n            return false;\n          } // Assume cyclic values are equal.\n\n\n          var stacked = stack.get(object);\n\n          if (stacked) {\n            return stacked == other;\n          }\n\n          bitmask |= UNORDERED_COMPARE_FLAG; // Recursively compare objects (susceptible to call stack limits).\n\n          stack.set(object, other);\n          var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);\n          stack['delete'](object);\n          return result;\n\n        case symbolTag:\n          if (symbolValueOf) {\n            return symbolValueOf.call(object) == symbolValueOf.call(other);\n          }\n\n      }\n\n      return false;\n    }\n    /**\n     * A specialized version of `baseIsEqualDeep` for objects with support for\n     * partial deep comparisons.\n     *\n     * @private\n     * @param {Object} object The object to compare.\n     * @param {Object} other The other object to compare.\n     * @param {Function} equalFunc The function to determine equivalents of values.\n     * @param {Function} customizer The function to customize comparisons.\n     * @param {number} bitmask The bitmask of comparison flags. See `baseIsEqual`\n     *  for more details.\n     * @param {Object} stack Tracks traversed `object` and `other` objects.\n     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\n     */\n\n\n    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {\n      var isPartial = bitmask & PARTIAL_COMPARE_FLAG,\n          objProps = keys(object),\n          objLength = objProps.length,\n          othProps = keys(other),\n          othLength = othProps.length;\n\n      if (objLength != othLength && !isPartial) {\n        return false;\n      }\n\n      var index = objLength;\n\n      while (index--) {\n        var key = objProps[index];\n\n        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\n          return false;\n        }\n      } // Assume cyclic values are equal.\n\n\n      var stacked = stack.get(object);\n\n      if (stacked && stack.get(other)) {\n        return stacked == other;\n      }\n\n      var result = true;\n      stack.set(object, other);\n      stack.set(other, object);\n      var skipCtor = isPartial;\n\n      while (++index < objLength) {\n        key = objProps[index];\n        var objValue = object[key],\n            othValue = other[key];\n\n        if (customizer) {\n          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);\n        } // Recursively compare objects (susceptible to call stack limits).\n\n\n        if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {\n          result = false;\n          break;\n        }\n\n        skipCtor || (skipCtor = key == 'constructor');\n      }\n\n      if (result && !skipCtor) {\n        var objCtor = object.constructor,\n            othCtor = other.constructor; // Non `Object` object instances with different constructors are not equal.\n\n        if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {\n          result = false;\n        }\n      }\n\n      stack['delete'](object);\n      stack['delete'](other);\n      return result;\n    }\n    /**\n     * Gets the data for `map`.\n     *\n     * @private\n     * @param {Object} map The map to query.\n     * @param {string} key The reference key.\n     * @returns {*} Returns the map data.\n     */\n\n\n    function getMapData(map, key) {\n      var data = map.__data__;\n      return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;\n    }\n    /**\n     * Gets the property names, values, and compare flags of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the match data of `object`.\n     */\n\n\n    function getMatchData(object) {\n      var result = keys(object),\n          length = result.length;\n\n      while (length--) {\n        var key = result[length],\n            value = object[key];\n        result[length] = [key, value, isStrictComparable(value)];\n      }\n\n      return result;\n    }\n    /**\n     * Gets the native function at `key` of `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {string} key The key of the method to get.\n     * @returns {*} Returns the function if it's native, else `undefined`.\n     */\n\n\n    function getNative(object, key) {\n      var value = getValue(object, key);\n      return baseIsNative(value) ? value : undefined;\n    }\n    /**\n     * Gets the `toStringTag` of `value`.\n     *\n     * @private\n     * @param {*} value The value to query.\n     * @returns {string} Returns the `toStringTag`.\n     */\n\n\n    var getTag = baseGetTag; // Fallback for data views, maps, sets, and weak maps in IE 11,\n    // for data views in Edge < 14, and promises in Node.js.\n\n    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {\n      getTag = function getTag(value) {\n        var result = objectToString.call(value),\n            Ctor = result == objectTag ? value.constructor : undefined,\n            ctorString = Ctor ? toSource(Ctor) : undefined;\n\n        if (ctorString) {\n          switch (ctorString) {\n            case dataViewCtorString:\n              return dataViewTag;\n\n            case mapCtorString:\n              return mapTag;\n\n            case promiseCtorString:\n              return promiseTag;\n\n            case setCtorString:\n              return setTag;\n\n            case weakMapCtorString:\n              return weakMapTag;\n          }\n        }\n\n        return result;\n      };\n    }\n    /**\n     * Checks if `path` exists on `object`.\n     *\n     * @private\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @param {Function} hasFunc The function to check properties.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     */\n\n\n    function hasPath(object, path, hasFunc) {\n      path = isKey(path, object) ? [path] : castPath(path);\n      var result,\n          index = -1,\n          length = path.length;\n\n      while (++index < length) {\n        var key = toKey(path[index]);\n\n        if (!(result = object != null && hasFunc(object, key))) {\n          break;\n        }\n\n        object = object[key];\n      }\n\n      if (result) {\n        return result;\n      }\n\n      var length = object ? object.length : 0;\n      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));\n    }\n    /**\n     * Checks if `value` is a valid array-like index.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n     */\n\n\n    function isIndex(value, length) {\n      length = length == null ? MAX_SAFE_INTEGER : length;\n      return !!length && (typeof value == 'number' || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;\n    }\n    /**\n     * Checks if `value` is a property name and not a property path.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @param {Object} [object] The object to query keys on.\n     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n     */\n\n\n    function isKey(value, object) {\n      if (isArray(value)) {\n        return false;\n      }\n\n      var type = typeof value;\n\n      if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {\n        return true;\n      }\n\n      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);\n    }\n    /**\n     * Checks if `value` is suitable for use as unique object key.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n     */\n\n\n    function isKeyable(value) {\n      var type = typeof value;\n      return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;\n    }\n    /**\n     * Checks if `func` has its source masked.\n     *\n     * @private\n     * @param {Function} func The function to check.\n     * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n     */\n\n\n    function isMasked(func) {\n      return !!maskSrcKey && maskSrcKey in func;\n    }\n    /**\n     * Checks if `value` is likely a prototype object.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n     */\n\n\n    function isPrototype(value) {\n      var Ctor = value && value.constructor,\n          proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;\n      return value === proto;\n    }\n    /**\n     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` if suitable for strict\n     *  equality comparisons, else `false`.\n     */\n\n\n    function isStrictComparable(value) {\n      return value === value && !isObject(value);\n    }\n    /**\n     * A specialized version of `matchesProperty` for source values suitable\n     * for strict equality comparisons, i.e. `===`.\n     *\n     * @private\n     * @param {string} key The key of the property to get.\n     * @param {*} srcValue The value to match.\n     * @returns {Function} Returns the new spec function.\n     */\n\n\n    function matchesStrictComparable(key, srcValue) {\n      return function (object) {\n        if (object == null) {\n          return false;\n        }\n\n        return object[key] === srcValue && (srcValue !== undefined || key in Object(object));\n      };\n    }\n    /**\n     * Converts `string` to a property path array.\n     *\n     * @private\n     * @param {string} string The string to convert.\n     * @returns {Array} Returns the property path array.\n     */\n\n\n    var stringToPath = memoize(function (string) {\n      string = toString(string);\n      var result = [];\n\n      if (reLeadingDot.test(string)) {\n        result.push('');\n      }\n\n      string.replace(rePropName, function (match, number, quote, string) {\n        result.push(quote ? string.replace(reEscapeChar, '$1') : number || match);\n      });\n      return result;\n    });\n    /**\n     * Converts `value` to a string key if it's not a string or symbol.\n     *\n     * @private\n     * @param {*} value The value to inspect.\n     * @returns {string|symbol} Returns the key.\n     */\n\n    function toKey(value) {\n      if (typeof value == 'string' || isSymbol(value)) {\n        return value;\n      }\n\n      var result = value + '';\n      return result == '0' && 1 / value == -INFINITY ? '-0' : result;\n    }\n    /**\n     * Converts `func` to its source code.\n     *\n     * @private\n     * @param {Function} func The function to process.\n     * @returns {string} Returns the source code.\n     */\n\n\n    function toSource(func) {\n      if (func != null) {\n        try {\n          return funcToString.call(func);\n        } catch (e) {}\n\n        try {\n          return func + '';\n        } catch (e) {}\n      }\n\n      return '';\n    }\n    /**\n     * Creates a function that memoizes the result of `func`. If `resolver` is\n     * provided, it determines the cache key for storing the result based on the\n     * arguments provided to the memoized function. By default, the first argument\n     * provided to the memoized function is used as the map cache key. The `func`\n     * is invoked with the `this` binding of the memoized function.\n     *\n     * **Note:** The cache is exposed as the `cache` property on the memoized\n     * function. Its creation may be customized by replacing the `_.memoize.Cache`\n     * constructor with one whose instances implement the\n     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n     * method interface of `delete`, `get`, `has`, and `set`.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Function\n     * @param {Function} func The function to have its output memoized.\n     * @param {Function} [resolver] The function to resolve the cache key.\n     * @returns {Function} Returns the new memoized function.\n     * @example\n     *\n     * var object = { 'a': 1, 'b': 2 };\n     * var other = { 'c': 3, 'd': 4 };\n     *\n     * var values = _.memoize(_.values);\n     * values(object);\n     * // => [1, 2]\n     *\n     * values(other);\n     * // => [3, 4]\n     *\n     * object.a = 2;\n     * values(object);\n     * // => [1, 2]\n     *\n     * // Modify the result cache.\n     * values.cache.set(object, ['a', 'b']);\n     * values(object);\n     * // => ['a', 'b']\n     *\n     * // Replace `_.memoize.Cache`.\n     * _.memoize.Cache = WeakMap;\n     */\n\n\n    function memoize(func, resolver) {\n      if (typeof func != 'function' || resolver && typeof resolver != 'function') {\n        throw new TypeError(FUNC_ERROR_TEXT);\n      }\n\n      var memoized = function memoized() {\n        var args = arguments,\n            key = resolver ? resolver.apply(this, args) : args[0],\n            cache = memoized.cache;\n\n        if (cache.has(key)) {\n          return cache.get(key);\n        }\n\n        var result = func.apply(this, args);\n        memoized.cache = cache.set(key, result);\n        return result;\n      };\n\n      memoized.cache = new (memoize.Cache || MapCache)();\n      return memoized;\n    } // Assign cache to `_.memoize`.\n\n\n    memoize.Cache = MapCache;\n    /**\n     * Performs a\n     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n     * comparison between two values to determine if they are equivalent.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to compare.\n     * @param {*} other The other value to compare.\n     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     * var other = { 'a': 1 };\n     *\n     * _.eq(object, object);\n     * // => true\n     *\n     * _.eq(object, other);\n     * // => false\n     *\n     * _.eq('a', 'a');\n     * // => true\n     *\n     * _.eq('a', Object('a'));\n     * // => false\n     *\n     * _.eq(NaN, NaN);\n     * // => true\n     */\n\n    function eq(value, other) {\n      return value === other || value !== value && other !== other;\n    }\n    /**\n     * Checks if `value` is likely an `arguments` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArguments(function() { return arguments; }());\n     * // => true\n     *\n     * _.isArguments([1, 2, 3]);\n     * // => false\n     */\n\n\n    function isArguments(value) {\n      // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n      return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') && (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n    }\n    /**\n     * Checks if `value` is classified as an `Array` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n     * @example\n     *\n     * _.isArray([1, 2, 3]);\n     * // => true\n     *\n     * _.isArray(document.body.children);\n     * // => false\n     *\n     * _.isArray('abc');\n     * // => false\n     *\n     * _.isArray(_.noop);\n     * // => false\n     */\n\n\n    var isArray = Array.isArray;\n    /**\n     * Checks if `value` is array-like. A value is considered array-like if it's\n     * not a function and has a `value.length` that's an integer greater than or\n     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n     * @example\n     *\n     * _.isArrayLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLike(document.body.children);\n     * // => true\n     *\n     * _.isArrayLike('abc');\n     * // => true\n     *\n     * _.isArrayLike(_.noop);\n     * // => false\n     */\n\n    function isArrayLike(value) {\n      return value != null && isLength(value.length) && !isFunction(value);\n    }\n    /**\n     * This method is like `_.isArrayLike` except that it also checks if `value`\n     * is an object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an array-like object,\n     *  else `false`.\n     * @example\n     *\n     * _.isArrayLikeObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isArrayLikeObject(document.body.children);\n     * // => true\n     *\n     * _.isArrayLikeObject('abc');\n     * // => false\n     *\n     * _.isArrayLikeObject(_.noop);\n     * // => false\n     */\n\n\n    function isArrayLikeObject(value) {\n      return isObjectLike(value) && isArrayLike(value);\n    }\n    /**\n     * Checks if `value` is classified as a `Function` object.\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n     * @example\n     *\n     * _.isFunction(_);\n     * // => true\n     *\n     * _.isFunction(/abc/);\n     * // => false\n     */\n\n\n    function isFunction(value) {\n      // The use of `Object#toString` avoids issues with the `typeof` operator\n      // in Safari 8-9 which returns 'object' for typed array and other constructors.\n      var tag = isObject(value) ? objectToString.call(value) : '';\n      return tag == funcTag || tag == genTag;\n    }\n    /**\n     * Checks if `value` is a valid array-like length.\n     *\n     * **Note:** This method is loosely based on\n     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n     * @example\n     *\n     * _.isLength(3);\n     * // => true\n     *\n     * _.isLength(Number.MIN_VALUE);\n     * // => false\n     *\n     * _.isLength(Infinity);\n     * // => false\n     *\n     * _.isLength('3');\n     * // => false\n     */\n\n\n    function isLength(value) {\n      return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n    }\n    /**\n     * Checks if `value` is the\n     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n     *\n     * @static\n     * @memberOf _\n     * @since 0.1.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n     * @example\n     *\n     * _.isObject({});\n     * // => true\n     *\n     * _.isObject([1, 2, 3]);\n     * // => true\n     *\n     * _.isObject(_.noop);\n     * // => true\n     *\n     * _.isObject(null);\n     * // => false\n     */\n\n\n    function isObject(value) {\n      var type = typeof value;\n      return !!value && (type == 'object' || type == 'function');\n    }\n    /**\n     * Checks if `value` is object-like. A value is object-like if it's not `null`\n     * and has a `typeof` result of \"object\".\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n     * @example\n     *\n     * _.isObjectLike({});\n     * // => true\n     *\n     * _.isObjectLike([1, 2, 3]);\n     * // => true\n     *\n     * _.isObjectLike(_.noop);\n     * // => false\n     *\n     * _.isObjectLike(null);\n     * // => false\n     */\n\n\n    function isObjectLike(value) {\n      return !!value && typeof value == 'object';\n    }\n    /**\n     * Checks if `value` is classified as a `Symbol` primitive or object.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n     * @example\n     *\n     * _.isSymbol(Symbol.iterator);\n     * // => true\n     *\n     * _.isSymbol('abc');\n     * // => false\n     */\n\n\n    function isSymbol(value) {\n      return typeof value == 'symbol' || isObjectLike(value) && objectToString.call(value) == symbolTag;\n    }\n    /**\n     * Checks if `value` is classified as a typed array.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.0.0\n     * @category Lang\n     * @param {*} value The value to check.\n     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\n     * @example\n     *\n     * _.isTypedArray(new Uint8Array);\n     * // => true\n     *\n     * _.isTypedArray([]);\n     * // => false\n     */\n\n\n    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\n    /**\n     * Converts `value` to a string. An empty string is returned for `null`\n     * and `undefined` values. The sign of `-0` is preserved.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Lang\n     * @param {*} value The value to process.\n     * @returns {string} Returns the string.\n     * @example\n     *\n     * _.toString(null);\n     * // => ''\n     *\n     * _.toString(-0);\n     * // => '-0'\n     *\n     * _.toString([1, 2, 3]);\n     * // => '1,2,3'\n     */\n\n    function toString(value) {\n      return value == null ? '' : baseToString(value);\n    }\n    /**\n     * Gets the value at `path` of `object`. If the resolved value is\n     * `undefined`, the `defaultValue` is returned in its place.\n     *\n     * @static\n     * @memberOf _\n     * @since 3.7.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path of the property to get.\n     * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n     * @returns {*} Returns the resolved value.\n     * @example\n     *\n     * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n     *\n     * _.get(object, 'a[0].b.c');\n     * // => 3\n     *\n     * _.get(object, ['a', '0', 'b', 'c']);\n     * // => 3\n     *\n     * _.get(object, 'a.b.c', 'default');\n     * // => 'default'\n     */\n\n\n    function get(object, path, defaultValue) {\n      var result = object == null ? undefined : baseGet(object, path);\n      return result === undefined ? defaultValue : result;\n    }\n    /**\n     * Checks if `path` is a direct or inherited property of `object`.\n     *\n     * @static\n     * @memberOf _\n     * @since 4.0.0\n     * @category Object\n     * @param {Object} object The object to query.\n     * @param {Array|string} path The path to check.\n     * @returns {boolean} Returns `true` if `path` exists, else `false`.\n     * @example\n     *\n     * var object = _.create({ 'a': _.create({ 'b': 2 }) });\n     *\n     * _.hasIn(object, 'a');\n     * // => true\n     *\n     * _.hasIn(object, 'a.b');\n     * // => true\n     *\n     * _.hasIn(object, ['a', 'b']);\n     * // => true\n     *\n     * _.hasIn(object, 'b');\n     * // => false\n     */\n\n\n    function hasIn(object, path) {\n      return object != null && hasPath(object, path, baseHasIn);\n    }\n    /**\n     * Creates an array of the own enumerable property names of `object`.\n     *\n     * **Note:** Non-object values are coerced to objects. See the\n     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n     * for more details.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Object\n     * @param {Object} object The object to query.\n     * @returns {Array} Returns the array of property names.\n     * @example\n     *\n     * function Foo() {\n     *   this.a = 1;\n     *   this.b = 2;\n     * }\n     *\n     * Foo.prototype.c = 3;\n     *\n     * _.keys(new Foo);\n     * // => ['a', 'b'] (iteration order is not guaranteed)\n     *\n     * _.keys('hi');\n     * // => ['0', '1']\n     */\n\n\n    function keys(object) {\n      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\n    }\n    /**\n     * An alternative to `_.reduce`; this method transforms `object` to a new\n     * `accumulator` object which is the result of running each of its own\n     * enumerable string keyed properties thru `iteratee`, with each invocation\n     * potentially mutating the `accumulator` object. If `accumulator` is not\n     * provided, a new object with the same `[[Prototype]]` will be used. The\n     * iteratee is invoked with four arguments: (accumulator, value, key, object).\n     * Iteratee functions may exit iteration early by explicitly returning `false`.\n     *\n     * @static\n     * @memberOf _\n     * @since 1.3.0\n     * @category Object\n     * @param {Object} object The object to iterate over.\n     * @param {Function} [iteratee=_.identity] The function invoked per iteration.\n     * @param {*} [accumulator] The custom accumulator value.\n     * @returns {*} Returns the accumulated value.\n     * @example\n     *\n     * _.transform([2, 3, 4], function(result, n) {\n     *   result.push(n *= n);\n     *   return n % 2 == 0;\n     * }, []);\n     * // => [4, 9]\n     *\n     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\n     *   (result[value] || (result[value] = [])).push(key);\n     * }, {});\n     * // => { '1': ['a', 'c'], '2': ['b'] }\n     */\n\n\n    function transform(object, iteratee, accumulator) {\n      var isArr = isArray(object) || isTypedArray(object);\n      iteratee = baseIteratee(iteratee, 4);\n\n      if (accumulator == null) {\n        if (isArr || isObject(object)) {\n          var Ctor = object.constructor;\n\n          if (isArr) {\n            accumulator = isArray(object) ? new Ctor() : [];\n          } else {\n            accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};\n          }\n        } else {\n          accumulator = {};\n        }\n      }\n\n      (isArr ? arrayEach : baseForOwn)(object, function (value, index, object) {\n        return iteratee(accumulator, value, index, object);\n      });\n      return accumulator;\n    }\n    /**\n     * This method returns the first argument it receives.\n     *\n     * @static\n     * @since 0.1.0\n     * @memberOf _\n     * @category Util\n     * @param {*} value Any value.\n     * @returns {*} Returns `value`.\n     * @example\n     *\n     * var object = { 'a': 1 };\n     *\n     * console.log(_.identity(object) === object);\n     * // => true\n     */\n\n\n    function identity(value) {\n      return value;\n    }\n    /**\n     * Creates a function that returns the value at `path` of a given object.\n     *\n     * @static\n     * @memberOf _\n     * @since 2.4.0\n     * @category Util\n     * @param {Array|string} path The path of the property to get.\n     * @returns {Function} Returns the new accessor function.\n     * @example\n     *\n     * var objects = [\n     *   { 'a': { 'b': 2 } },\n     *   { 'a': { 'b': 1 } }\n     * ];\n     *\n     * _.map(objects, _.property('a.b'));\n     * // => [2, 1]\n     *\n     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\n     * // => [1, 2]\n     */\n\n\n    function property(path) {\n      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\n    }\n\n    module.exports = transform;\n  });\n  var dist = createCommonjsModule(function (module, exports) {\n    Object.defineProperty(exports, \"__esModule\", {\n      value: true\n    });\n    exports.default = cleanDeep;\n\n    var _lodash2 = _interopRequireDefault(lodash_isempty);\n\n    var _lodash4 = _interopRequireDefault(lodash_isplainobject);\n\n    var _lodash6 = _interopRequireDefault(lodash_transform);\n\n    function _interopRequireDefault(obj) {\n      return obj && obj.__esModule ? obj : {\n        default: obj\n      };\n    }\n    /**\n     * Export `cleanDeep` function.\n     */\n\n\n    function cleanDeep(object) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref$emptyArrays = _ref.emptyArrays,\n          emptyArrays = _ref$emptyArrays === undefined ? true : _ref$emptyArrays,\n          _ref$emptyObjects = _ref.emptyObjects,\n          emptyObjects = _ref$emptyObjects === undefined ? true : _ref$emptyObjects,\n          _ref$emptyStrings = _ref.emptyStrings,\n          emptyStrings = _ref$emptyStrings === undefined ? true : _ref$emptyStrings,\n          _ref$nullValues = _ref.nullValues,\n          nullValues = _ref$nullValues === undefined ? true : _ref$nullValues,\n          _ref$undefinedValues = _ref.undefinedValues,\n          undefinedValues = _ref$undefinedValues === undefined ? true : _ref$undefinedValues;\n\n      return (0, _lodash6.default)(object, function (result, value, key) {\n        // Recurse into arrays and objects.\n        if (Array.isArray(value) || (0, _lodash4.default)(value)) {\n          value = cleanDeep(value, {\n            emptyArrays: emptyArrays,\n            emptyObjects: emptyObjects,\n            emptyStrings: emptyStrings,\n            nullValues: nullValues,\n            undefinedValues: undefinedValues\n          });\n        } // Exclude empty objects.\n\n\n        if (emptyObjects && (0, _lodash4.default)(value) && (0, _lodash2.default)(value)) {\n          return;\n        } // Exclude empty arrays.\n\n\n        if (emptyArrays && Array.isArray(value) && !value.length) {\n          return;\n        } // Exclude empty strings.\n\n\n        if (emptyStrings && value === '') {\n          return;\n        } // Exclude null values.\n\n\n        if (nullValues && value === null) {\n          return;\n        } // Exclude undefined values.\n\n\n        if (undefinedValues && value === undefined) {\n          return;\n        } // Append when recursing arrays.\n\n\n        if (Array.isArray(result)) {\n          return result.push(value);\n        }\n\n        result[key] = value;\n      });\n    }\n    /**\n     * Module dependencies.\n     */\n\n\n    module.exports = exports['default'];\n  });\n  var clean = unwrapExports(dist);\n  var eventemitter3 = createCommonjsModule(function (module) {\n    var has = Object.prototype.hasOwnProperty,\n        prefix = '~';\n    /**\n     * Constructor to create a storage for our `EE` objects.\n     * An `Events` instance is a plain object whose properties are event names.\n     *\n     * @constructor\n     * @api private\n     */\n\n    function Events() {} //\n    // We try to not inherit from `Object.prototype`. In some engines creating an\n    // instance in this way is faster than calling `Object.create(null)` directly.\n    // If `Object.create(null)` is not supported we prefix the event names with a\n    // character to make sure that the built-in object properties are not\n    // overridden or used as an attack vector.\n    //\n\n\n    if (Object.create) {\n      Events.prototype = Object.create(null); //\n      // This hack is needed because the `__proto__` property is still inherited in\n      // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n      //\n\n      if (!new Events().__proto__) prefix = false;\n    }\n    /**\n     * Representation of a single event listener.\n     *\n     * @param {Function} fn The listener function.\n     * @param {Mixed} context The context to invoke the listener with.\n     * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n     * @constructor\n     * @api private\n     */\n\n\n    function EE(fn, context, once) {\n      this.fn = fn;\n      this.context = context;\n      this.once = once || false;\n    }\n    /**\n     * Minimal `EventEmitter` interface that is molded against the Node.js\n     * `EventEmitter` interface.\n     *\n     * @constructor\n     * @api public\n     */\n\n\n    function EventEmitter() {\n      this._events = new Events();\n      this._eventsCount = 0;\n    }\n    /**\n     * Return an array listing the events for which the emitter has registered\n     * listeners.\n     *\n     * @returns {Array}\n     * @api public\n     */\n\n\n    EventEmitter.prototype.eventNames = function eventNames() {\n      var names = [],\n          events,\n          name;\n      if (this._eventsCount === 0) return names;\n\n      for (name in events = this._events) {\n        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n      }\n\n      if (Object.getOwnPropertySymbols) {\n        return names.concat(Object.getOwnPropertySymbols(events));\n      }\n\n      return names;\n    };\n    /**\n     * Return the listeners registered for a given event.\n     *\n     * @param {String|Symbol} event The event name.\n     * @param {Boolean} exists Only check if there are listeners.\n     * @returns {Array|Boolean}\n     * @api public\n     */\n\n\n    EventEmitter.prototype.listeners = function listeners(event, exists) {\n      var evt = prefix ? prefix + event : event,\n          available = this._events[evt];\n      if (exists) return !!available;\n      if (!available) return [];\n      if (available.fn) return [available.fn];\n\n      for (var i = 0, l = available.length, ee = new Array(l); i < l; i++) {\n        ee[i] = available[i].fn;\n      }\n\n      return ee;\n    };\n    /**\n     * Calls each of the listeners registered for a given event.\n     *\n     * @param {String|Symbol} event The event name.\n     * @returns {Boolean} `true` if the event had listeners, else `false`.\n     * @api public\n     */\n\n\n    EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n      var evt = prefix ? prefix + event : event;\n      if (!this._events[evt]) return false;\n      var listeners = this._events[evt],\n          len = arguments.length,\n          args,\n          i;\n\n      if (listeners.fn) {\n        if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n        switch (len) {\n          case 1:\n            return listeners.fn.call(listeners.context), true;\n\n          case 2:\n            return listeners.fn.call(listeners.context, a1), true;\n\n          case 3:\n            return listeners.fn.call(listeners.context, a1, a2), true;\n\n          case 4:\n            return listeners.fn.call(listeners.context, a1, a2, a3), true;\n\n          case 5:\n            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n\n          case 6:\n            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n        }\n\n        for (i = 1, args = new Array(len - 1); i < len; i++) {\n          args[i - 1] = arguments[i];\n        }\n\n        listeners.fn.apply(listeners.context, args);\n      } else {\n        var length = listeners.length,\n            j;\n\n        for (i = 0; i < length; i++) {\n          if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n          switch (len) {\n            case 1:\n              listeners[i].fn.call(listeners[i].context);\n              break;\n\n            case 2:\n              listeners[i].fn.call(listeners[i].context, a1);\n              break;\n\n            case 3:\n              listeners[i].fn.call(listeners[i].context, a1, a2);\n              break;\n\n            case 4:\n              listeners[i].fn.call(listeners[i].context, a1, a2, a3);\n              break;\n\n            default:\n              if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {\n                args[j - 1] = arguments[j];\n              }\n              listeners[i].fn.apply(listeners[i].context, args);\n          }\n        }\n      }\n\n      return true;\n    };\n    /**\n     * Add a listener for a given event.\n     *\n     * @param {String|Symbol} event The event name.\n     * @param {Function} fn The listener function.\n     * @param {Mixed} [context=this] The context to invoke the listener with.\n     * @returns {EventEmitter} `this`.\n     * @api public\n     */\n\n\n    EventEmitter.prototype.on = function on(event, fn, context) {\n      var listener = new EE(fn, context || this),\n          evt = prefix ? prefix + event : event;\n      if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;else if (!this._events[evt].fn) this._events[evt].push(listener);else this._events[evt] = [this._events[evt], listener];\n      return this;\n    };\n    /**\n     * Add a one-time listener for a given event.\n     *\n     * @param {String|Symbol} event The event name.\n     * @param {Function} fn The listener function.\n     * @param {Mixed} [context=this] The context to invoke the listener with.\n     * @returns {EventEmitter} `this`.\n     * @api public\n     */\n\n\n    EventEmitter.prototype.once = function once(event, fn, context) {\n      var listener = new EE(fn, context || this, true),\n          evt = prefix ? prefix + event : event;\n      if (!this._events[evt]) this._events[evt] = listener, this._eventsCount++;else if (!this._events[evt].fn) this._events[evt].push(listener);else this._events[evt] = [this._events[evt], listener];\n      return this;\n    };\n    /**\n     * Remove the listeners of a given event.\n     *\n     * @param {String|Symbol} event The event name.\n     * @param {Function} fn Only remove the listeners that match this function.\n     * @param {Mixed} context Only remove the listeners that have this context.\n     * @param {Boolean} once Only remove one-time listeners.\n     * @returns {EventEmitter} `this`.\n     * @api public\n     */\n\n\n    EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n      var evt = prefix ? prefix + event : event;\n      if (!this._events[evt]) return this;\n\n      if (!fn) {\n        if (--this._eventsCount === 0) this._events = new Events();else delete this._events[evt];\n        return this;\n      }\n\n      var listeners = this._events[evt];\n\n      if (listeners.fn) {\n        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {\n          if (--this._eventsCount === 0) this._events = new Events();else delete this._events[evt];\n        }\n      } else {\n        for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {\n            events.push(listeners[i]);\n          }\n        } //\n        // Reset the array, or remove it completely if we have no more listeners.\n        //\n\n\n        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;else if (--this._eventsCount === 0) this._events = new Events();else delete this._events[evt];\n      }\n\n      return this;\n    };\n    /**\n     * Remove all listeners, or those of the specified event.\n     *\n     * @param {String|Symbol} [event] The event name.\n     * @returns {EventEmitter} `this`.\n     * @api public\n     */\n\n\n    EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n      var evt;\n\n      if (event) {\n        evt = prefix ? prefix + event : event;\n\n        if (this._events[evt]) {\n          if (--this._eventsCount === 0) this._events = new Events();else delete this._events[evt];\n        }\n      } else {\n        this._events = new Events();\n        this._eventsCount = 0;\n      }\n\n      return this;\n    }; //\n    // Alias methods names because people roll like that.\n    //\n\n\n    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n    EventEmitter.prototype.addListener = EventEmitter.prototype.on; //\n    // This function doesn't apply anymore.\n    //\n\n    EventEmitter.prototype.setMaxListeners = function setMaxListeners() {\n      return this;\n    }; //\n    // Expose the prefix.\n    //\n\n\n    EventEmitter.prefixed = prefix; //\n    // Allow `EventEmitter` to be imported as module namespace.\n    //\n\n    EventEmitter.EventEmitter = EventEmitter; //\n    // Expose the module.\n    //\n\n    {\n      module.exports = EventEmitter;\n    }\n  });\n\n  function _defineProperty$1(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  var noop = function noop() {};\n\n  var State = {\n    data: 'state-data',\n    cdata: 'state-cdata',\n    tagBegin: 'state-tag-begin',\n    tagName: 'state-tag-name',\n    tagEnd: 'state-tag-end',\n    attributeNameStart: 'state-attribute-name-start',\n    attributeName: 'state-attribute-name',\n    attributeNameEnd: 'state-attribute-name-end',\n    attributeValueBegin: 'state-attribute-value-begin',\n    attributeValue: 'state-attribute-value'\n  };\n  var Action = {\n    lt: 'action-lt',\n    gt: 'action-gt',\n    space: 'action-space',\n    equal: 'action-equal',\n    quote: 'action-quote',\n    slash: 'action-slash',\n    char: 'action-char',\n    error: 'action-error'\n  };\n  var Type = {\n    text: 'text',\n    openTag: 'open-tag',\n    closeTag: 'close-tag',\n    attributeName: 'attribute-name',\n    attributeValue: 'attribute-value'\n  };\n  var charToAction = {\n    ' ': Action.space,\n    '\\t': Action.space,\n    '\\n': Action.space,\n    '\\r': Action.space,\n    '<': Action.lt,\n    '>': Action.gt,\n    '\"': Action.quote,\n    \"'\": Action.quote,\n    '=': Action.equal,\n    '/': Action.slash\n  };\n\n  var getAction = function getAction(_char) {\n    return charToAction[_char] || Action.char;\n  };\n  /**\n   * @param  {Object} options\n   * @param  {Boolean} options.debug\n   * @return {Object}\n   */\n\n\n  var create = function create(options) {\n    var _State$data, _State$tagBegin, _State$tagName, _State$tagEnd, _State$attributeNameS, _State$attributeName, _State$attributeNameE, _State$attributeValue, _State$attributeValue2, _lexer$stateMachine;\n\n    options = Object.assign({\n      debug: false\n    }, options);\n    var lexer = new eventemitter3();\n    var state = State.data;\n    var data = '';\n    var tagName = '';\n    var attrName = '';\n    var attrValue = '';\n    var isClosing = '';\n    var openingQuote = '';\n\n    var emit = function emit(type, value) {\n      // for now, ignore tags like: '?xml', '!DOCTYPE' or comments\n      if (tagName[0] === '?' || tagName[0] === '!') {\n        return;\n      }\n\n      var event = {\n        type: type,\n        value: value\n      };\n\n      if (options.debug) {\n        console.log('emit:', event);\n      }\n\n      lexer.emit('data', event);\n    };\n\n    lexer.stateMachine = (_lexer$stateMachine = {}, _defineProperty$1(_lexer$stateMachine, State.data, (_State$data = {}, _defineProperty$1(_State$data, Action.lt, function () {\n      if (data.trim()) {\n        emit(Type.text, data);\n      }\n\n      tagName = '';\n      isClosing = false;\n      state = State.tagBegin;\n    }), _defineProperty$1(_State$data, Action.char, function (_char2) {\n      data += _char2;\n    }), _State$data)), _defineProperty$1(_lexer$stateMachine, State.cdata, _defineProperty$1({}, Action.char, function (_char3) {\n      data += _char3;\n\n      if (data.substr(-3) === ']]>') {\n        emit(Type.text, data.slice(0, -3));\n        data = '';\n        state = State.data;\n      }\n    })), _defineProperty$1(_lexer$stateMachine, State.tagBegin, (_State$tagBegin = {}, _defineProperty$1(_State$tagBegin, Action.space, noop), _defineProperty$1(_State$tagBegin, Action.char, function (_char4) {\n      tagName = _char4;\n      state = State.tagName;\n    }), _defineProperty$1(_State$tagBegin, Action.slash, function () {\n      tagName = '';\n      isClosing = true;\n    }), _State$tagBegin)), _defineProperty$1(_lexer$stateMachine, State.tagName, (_State$tagName = {}, _defineProperty$1(_State$tagName, Action.space, function () {\n      if (isClosing) {\n        state = State.tagEnd;\n      } else {\n        state = State.attributeNameStart;\n        emit(Type.openTag, tagName);\n      }\n    }), _defineProperty$1(_State$tagName, Action.gt, function () {\n      if (isClosing) {\n        emit(Type.closeTag, tagName);\n      } else {\n        emit(Type.openTag, tagName);\n      }\n\n      data = '';\n      state = State.data;\n    }), _defineProperty$1(_State$tagName, Action.slash, function () {\n      state = State.tagEnd;\n      emit(Type.openTag, tagName);\n    }), _defineProperty$1(_State$tagName, Action.char, function (_char5) {\n      tagName += _char5;\n\n      if (tagName === '![CDATA[') {\n        state = State.cdata;\n        data = '';\n        tagName = '';\n      }\n    }), _State$tagName)), _defineProperty$1(_lexer$stateMachine, State.tagEnd, (_State$tagEnd = {}, _defineProperty$1(_State$tagEnd, Action.gt, function () {\n      emit(Type.closeTag, tagName);\n      data = '';\n      state = State.data;\n    }), _defineProperty$1(_State$tagEnd, Action.char, noop), _State$tagEnd)), _defineProperty$1(_lexer$stateMachine, State.attributeNameStart, (_State$attributeNameS = {}, _defineProperty$1(_State$attributeNameS, Action.char, function (_char6) {\n      attrName = _char6;\n      state = State.attributeName;\n    }), _defineProperty$1(_State$attributeNameS, Action.gt, function () {\n      data = '';\n      state = State.data;\n    }), _defineProperty$1(_State$attributeNameS, Action.space, noop), _defineProperty$1(_State$attributeNameS, Action.slash, function () {\n      isClosing = true;\n      state = State.tagEnd;\n    }), _State$attributeNameS)), _defineProperty$1(_lexer$stateMachine, State.attributeName, (_State$attributeName = {}, _defineProperty$1(_State$attributeName, Action.space, function () {\n      state = State.attributeNameEnd;\n    }), _defineProperty$1(_State$attributeName, Action.equal, function () {\n      emit(Type.attributeName, attrName);\n      state = State.attributeValueBegin;\n    }), _defineProperty$1(_State$attributeName, Action.gt, function () {\n      attrValue = '';\n      emit(Type.attributeName, attrName);\n      emit(Type.attributeValue, attrValue);\n      data = '';\n      state = State.data;\n    }), _defineProperty$1(_State$attributeName, Action.slash, function () {\n      isClosing = true;\n      attrValue = '';\n      emit(Type.attributeName, attrName);\n      emit(Type.attributeValue, attrValue);\n      state = State.tagEnd;\n    }), _defineProperty$1(_State$attributeName, Action.char, function (_char7) {\n      attrName += _char7;\n    }), _State$attributeName)), _defineProperty$1(_lexer$stateMachine, State.attributeNameEnd, (_State$attributeNameE = {}, _defineProperty$1(_State$attributeNameE, Action.space, noop), _defineProperty$1(_State$attributeNameE, Action.equal, function () {\n      emit(Type.attributeName, attrName);\n      state = State.attributeValueBegin;\n    }), _defineProperty$1(_State$attributeNameE, Action.gt, function () {\n      attrValue = '';\n      emit(Type.attributeName, attrName);\n      emit(Type.attributeValue, attrValue);\n      data = '';\n      state = State.data;\n    }), _defineProperty$1(_State$attributeNameE, Action.char, function (_char8) {\n      attrValue = '';\n      emit(Type.attributeName, attrName);\n      emit(Type.attributeValue, attrValue);\n      attrName = _char8;\n      state = State.attributeName;\n    }), _State$attributeNameE)), _defineProperty$1(_lexer$stateMachine, State.attributeValueBegin, (_State$attributeValue = {}, _defineProperty$1(_State$attributeValue, Action.space, noop), _defineProperty$1(_State$attributeValue, Action.quote, function (_char9) {\n      openingQuote = _char9;\n      attrValue = '';\n      state = State.attributeValue;\n    }), _defineProperty$1(_State$attributeValue, Action.gt, function () {\n      attrValue = '';\n      emit(Type.attributeValue, attrValue);\n      data = '';\n      state = State.data;\n    }), _defineProperty$1(_State$attributeValue, Action.char, function (_char10) {\n      openingQuote = '';\n      attrValue = _char10;\n      state = State.attributeValue;\n    }), _State$attributeValue)), _defineProperty$1(_lexer$stateMachine, State.attributeValue, (_State$attributeValue2 = {}, _defineProperty$1(_State$attributeValue2, Action.space, function (_char11) {\n      if (openingQuote) {\n        attrValue += _char11;\n      } else {\n        emit(Type.attributeValue, attrValue);\n        state = State.attributeNameStart;\n      }\n    }), _defineProperty$1(_State$attributeValue2, Action.quote, function (_char12) {\n      if (openingQuote === _char12) {\n        emit(Type.attributeValue, attrValue);\n        state = State.attributeNameStart;\n      } else {\n        attrValue += _char12;\n      }\n    }), _defineProperty$1(_State$attributeValue2, Action.gt, function (_char13) {\n      if (openingQuote) {\n        attrValue += _char13;\n      } else {\n        emit(Type.attributeValue, attrValue);\n        data = '';\n        state = State.data;\n      }\n    }), _defineProperty$1(_State$attributeValue2, Action.slash, function (_char14) {\n      if (openingQuote) {\n        attrValue += _char14;\n      } else {\n        emit(Type.attributeValue, attrValue);\n        isClosing = true;\n        state = State.tagEnd;\n      }\n    }), _defineProperty$1(_State$attributeValue2, Action.char, function (_char15) {\n      attrValue += _char15;\n    }), _State$attributeValue2)), _lexer$stateMachine);\n\n    var step = function step(_char16) {\n      if (options.debug) {\n        console.log(state, _char16);\n      }\n\n      var actions = lexer.stateMachine[state];\n      var action = actions[getAction(_char16)] || actions[Action.error] || actions[Action.char];\n      action(_char16);\n    };\n\n    lexer.write = function (str) {\n      var len = str.length;\n\n      for (var i = 0; i < len; i++) {\n        step(str[i]);\n      }\n    };\n\n    return lexer;\n  };\n\n  var lexer = {\n    State: State,\n    Action: Action,\n    Type: Type,\n    create: create\n  };\n  var Type$1 = lexer.Type;\n  var NodeType = {\n    element: 'element',\n    text: 'text'\n  };\n\n  var createNode = function createNode(params) {\n    return Object.assign({\n      name: '',\n      type: NodeType.element,\n      value: '',\n      parent: null,\n      attributes: {},\n      children: []\n    }, params);\n  };\n\n  var create$1 = function create(options) {\n    options = Object.assign({\n      stream: false,\n      parentNodes: true,\n      doneEvent: 'done',\n      tagPrefix: 'tag:',\n      emitTopLevelOnly: false,\n      debug: false\n    }, options);\n    var lexer$1 = void 0,\n        rootNode = void 0,\n        current = void 0,\n        attrName = void 0;\n    var reader = new eventemitter3();\n\n    var handleLexerData = function handleLexerData(data) {\n      switch (data.type) {\n        case Type$1.openTag:\n          if (current === null) {\n            current = rootNode;\n            current.name = data.value;\n          } else {\n            var node = createNode({\n              name: data.value,\n              parent: current\n            });\n            current.children.push(node);\n            current = node;\n          }\n\n          break;\n\n        case Type$1.closeTag:\n          var parent = current.parent;\n\n          if (!options.parentNodes) {\n            current.parent = null;\n          }\n\n          if (current.name !== data.value) {\n            // ignore unexpected closing tag\n            break;\n          }\n\n          if (options.stream && parent === rootNode) {\n            rootNode.children = []; // do not expose parent node in top level nodes\n\n            current.parent = null;\n          }\n\n          if (!options.emitTopLevelOnly || parent === rootNode) {\n            reader.emit(options.tagPrefix + current.name, current);\n            reader.emit('tag', current.name, current);\n          }\n\n          if (current === rootNode) {\n            // end of document, stop listening\n            lexer$1.removeAllListeners('data');\n            reader.emit(options.doneEvent, current);\n            rootNode = null;\n          }\n\n          current = parent;\n          break;\n\n        case Type$1.text:\n          if (current) {\n            current.children.push(createNode({\n              type: NodeType.text,\n              value: data.value,\n              parent: options.parentNodes ? current : null\n            }));\n          }\n\n          break;\n\n        case Type$1.attributeName:\n          attrName = data.value;\n          current.attributes[attrName] = '';\n          break;\n\n        case Type$1.attributeValue:\n          current.attributes[attrName] = data.value;\n          break;\n      }\n    };\n\n    reader.reset = function () {\n      lexer$1 = lexer.create({\n        debug: options.debug\n      });\n      lexer$1.on('data', handleLexerData);\n      rootNode = createNode();\n      current = null;\n      attrName = '';\n      reader.parse = lexer$1.write;\n    };\n\n    reader.reset();\n    return reader;\n  };\n\n  var parseSync = function parseSync(xml, options) {\n    options = Object.assign({}, options, {\n      stream: false,\n      tagPrefix: ':'\n    });\n    var reader = create$1(options);\n    var res = void 0;\n    reader.on('done', function (ast) {\n      res = ast;\n    });\n    reader.parse(xml);\n    return res;\n  };\n\n  var reader = {\n    parseSync: parseSync,\n    create: create$1,\n    NodeType: NodeType\n  };\n  var reader_1 = reader.parseSync;\n\n  var parseInput = function parseInput(input) {\n    var parsed = reader_1(input, {\n      parentNodes: false\n    });\n    var hasMoreChildren = parsed.name === 'root' && parsed.children.length > 1;\n    var isValid = hasMoreChildren ? parsed.children.reduce(function (acc, _ref) {\n      var name = _ref.name;\n      return !acc ? name === 'svg' : true;\n    }, false) : parsed.children[0].name === 'svg';\n\n    if (isValid) {\n      return hasMoreChildren ? parsed : parsed.children[0];\n    } else {\n      throw Error('nothing to parse');\n    }\n  };\n\n  var removeDoctype = function removeDoctype(input) {\n    return input.replace(/<[\\/]{0,1}(\\!?DOCTYPE|\\??xml)[^><]*>/gi, '');\n  };\n\n  var wrapInput = function wrapInput(input) {\n    return \"<root>\".concat(input, \"</root>\");\n  };\n\n  var removeAttrs = function removeAttrs(obj) {\n    return omitDeep(obj, ['parent']);\n  };\n\n  var applyCompat = function applyCompat(node) {\n    var renamed = deepRenameKeys(node, function (key) {\n      if (key === 'attributes') {\n        return 'attrs';\n      }\n\n      if (key === 'children') {\n        return 'childs';\n      }\n\n      return key;\n    });\n    return omitDeep(clean(renamed), ['type']);\n  };\n\n  var camelize = function camelize(node) {\n    return deepRenameKeys(node, function (key) {\n      if (!notCamelcase(key)) {\n        return toCamelCase(key);\n      }\n\n      return key;\n    });\n  };\n\n  var toCamelCase = function toCamelCase(prop) {\n    return prop.replace(/[-|:]([a-z])/gi, function (all, letter) {\n      return letter.toUpperCase();\n    });\n  };\n\n  var notCamelcase = function notCamelcase(prop) {\n    return /^(data|aria)(-\\w+)/.test(prop);\n  };\n\n  var escapeText = function escapeText(text) {\n    if (text) {\n      var str = String(text);\n      return /[&<>]/.test(str) ? \"<![CDATA[\".concat(str.replace(/]]>/, ']]]]><![CDATA[>'), \"]]>\") : str;\n    }\n\n    return '';\n  };\n\n  var escapeAttr = function escapeAttr(attr) {\n    return String(attr).replace(/&/g, '&amp;').replace(/'/g, '&apos;').replace(/\"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');\n  };\n\n  var svgsonSync = function svgsonSync(input) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$transformNode = _ref.transformNode,\n        transformNode = _ref$transformNode === void 0 ? function (node) {\n      return node;\n    } : _ref$transformNode,\n        _ref$compat = _ref.compat,\n        compat = _ref$compat === void 0 ? false : _ref$compat,\n        _ref$camelcase = _ref.camelcase,\n        camelcase = _ref$camelcase === void 0 ? false : _ref$camelcase;\n\n    var wrap = function wrap(input) {\n      var cleanInput = removeDoctype(input);\n      return wrapInput(cleanInput);\n    };\n\n    var unwrap = function unwrap(res) {\n      return res.name === 'root' ? res.children : res;\n    };\n\n    var applyFilters = function applyFilters(input) {\n      var applyTransformNode = function applyTransformNode(node) {\n        var children = compat ? node.childs : node.children;\n        return node.name === 'root' ? children.map(applyTransformNode) : _objectSpread({}, transformNode(node), children && children.length > 0 ? _defineProperty({}, compat ? 'childs' : 'children', children.map(applyTransformNode)) : {});\n      };\n\n      var n;\n      n = removeAttrs(input);\n\n      if (compat) {\n        n = applyCompat(n);\n      }\n\n      n = applyTransformNode(n);\n\n      if (camelcase || compat) {\n        n = camelize(n);\n      }\n\n      return n;\n    };\n\n    return unwrap(applyFilters(parseInput(wrap(input))));\n  };\n\n  function svgson() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return new Promise(function (resolve, reject) {\n      try {\n        var res = svgsonSync.apply(void 0, args);\n        resolve(res);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  var stringify = function stringify(ast) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$transformAttr = _ref.transformAttr,\n        transformAttr = _ref$transformAttr === void 0 ? function (key, value, escape) {\n      return \"\".concat(key, \"=\\\"\").concat(escape(value), \"\\\"\");\n    } : _ref$transformAttr,\n        _ref$selfClose = _ref.selfClose,\n        selfClose = _ref$selfClose === void 0 ? true : _ref$selfClose;\n\n    if (Array.isArray(ast)) {\n      return ast.map(function (ast) {\n        return stringify(ast, {\n          transformAttr: transformAttr,\n          selfClose: selfClose\n        });\n      }).join('');\n    }\n\n    if (ast.type === 'text') {\n      return escapeText(ast.value);\n    }\n\n    var attributes = '';\n\n    for (var attr in ast.attributes) {\n      var attrStr = transformAttr(attr, ast.attributes[attr], escapeAttr, ast.name);\n      attributes += attrStr ? \" \".concat(attrStr) : '';\n    }\n\n    return ast.children.length || !selfClose ? \"<\".concat(ast.name).concat(attributes, \">\").concat(stringify(ast.children, {\n      transformAttr: transformAttr,\n      selfClose: selfClose\n    }), \"</\").concat(ast.name, \">\") : \"<\".concat(ast.name).concat(attributes, \"/>\");\n  };\n\n  var indexUmd = Object.assign({}, {\n    parse: svgson,\n    parseSync: svgsonSync,\n    stringify: stringify\n  });\n  return indexUmd;\n});","map":null,"metadata":{},"sourceType":"script"}