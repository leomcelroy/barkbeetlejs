{"ast":null,"code":"var _assertThisInitialized = require(\"/Users/leomcelroy/Desktop/barkbeetle_js/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _classCallCheck = require(\"/Users/leomcelroy/Desktop/barkbeetle_js/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/leomcelroy/Desktop/barkbeetle_js/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/leomcelroy/Desktop/barkbeetle_js/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/leomcelroy/Desktop/barkbeetle_js/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/leomcelroy/Desktop/barkbeetle_js/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _require = require('../utils/objectCreationUtils'),\n    extendClass = _require.extendClass;\n\nvar EventTarget = require('./EventTarget');\n\nvar _require2 = require('../utils/mapUtils'),\n    objectToMap = _require2.objectToMap,\n    mapToObject = _require2.mapToObject,\n    mapMap = _require2.mapMap,\n    mapToCss = _require2.mapToCss,\n    cssToMap = _require2.cssToMap;\n\nvar _require3 = require('../utils/strUtils'),\n    hexToRGB = _require3.hexToRGB,\n    camelCase = _require3.camelCase,\n    htmlEntities = _require3.htmlEntities;\n\nvar pathUtils = require('../utils/pathUtils');\n\nvar _require4 = require('../utils/tagUtils'),\n    tag = _require4.tag,\n    _cloneNode = _require4.cloneNode;\n\nvar bbox = require('../utils/bboxUtils');\n\nvar regex = require('../utils/regex');\n\nvar CssQuery = require('./CssQuery');\n\nvar SVGPoint = require('./SVGPoint');\n\nvar SVGMatrix = require('./SVGMatrix');\n\nvar Box = require('./Box'); // XMLParser\n\n\nvar sax = require('sax'); // Map matrix array to object\n\n\nfunction arrayToMatrix(a) {\n  return {\n    a: a[0],\n    b: a[1],\n    c: a[2],\n    d: a[3],\n    e: a[4],\n    f: a[5]\n  };\n}\n\nvar Node =\n/*#__PURE__*/\nfunction (_EventTarget) {\n  \"use strict\";\n\n  _inherits(Node, _EventTarget);\n\n  function Node() {\n    var _this;\n\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Node);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Node).call(this));\n    _this.nodeName = name;\n    _this.nodeType = Node.ELEMENT_NODE;\n    _this.nodeValue = 0;\n    _this.childNodes = [];\n    _this._style = {};\n\n    if (props.attrs && props.attrs.style) {\n      _this._style = mapToObject(cssToMap(props.attrs.style));\n    }\n\n    _this.attrs = objectToMap(props.attrs || {});\n    _this.data = props.data || '';\n    _this.ownerDocument = props.ownerDocument || null;\n    _this.parentNode = null;\n    _this.cnt = 0;\n    _this.style = _this.getStyleProxy();\n\n    if (props.childNodes) {\n      for (var i = 0, il = props.childNodes.length; i < il; ++i) {\n        _this.appendChild(props.childNodes[i]);\n      }\n    }\n\n    return _this;\n  }\n\n  _createClass(Node, [{\n    key: \"getStyleProxy\",\n    value: function getStyleProxy() {\n      return new Proxy(this._style, {\n        get: function get(target, key) {\n          if (typeof key !== 'string') return Reflect.get(target, key);\n\n          if (key === 'cssText') {\n            return mapToCss(objectToMap(target));\n          }\n\n          if (key === 'setProperty') {\n            return function (propertyName, value, priority) {\n              Reflect.set(target, propertyName, value);\n            };\n          }\n\n          key = camelCase(key);\n          if (!target[key]) return '';\n          return Reflect.get(target, key);\n        },\n        set: function set(target, key, value) {\n          value = hexToRGB(value.toString());\n          key = camelCase(key);\n          return Reflect.set(target, key, value);\n        }\n      });\n    }\n  }, {\n    key: \"setNewStyle\",\n    value: function setNewStyle(obj) {\n      this._style = hexToRGB(obj);\n      this.style = this.getStyleProxy();\n    }\n  }, {\n    key: \"setAttribute\",\n    value: function setAttribute(name, value) {\n      if (name === 'style') {\n        return this.setNewStyle(mapToObject(cssToMap(value)));\n      }\n\n      this.attrs.set(name, value);\n    }\n  }, {\n    key: \"setAttributeNS\",\n    value: function setAttributeNS(ns, name, value) {\n      this.setAttribute(name, value);\n    }\n  }, {\n    key: \"removeAttribute\",\n    value: function removeAttribute(name) {\n      this.attrs.delete(name);\n    }\n  }, {\n    key: \"removeAttributeNS\",\n    value: function removeAttributeNS(ns, name) {\n      this.removeAttribute(name);\n    }\n  }, {\n    key: \"hasAttribute\",\n    value: function hasAttribute(name) {\n      if (name === 'style') return !!this.style.cssText; // TODO check\n\n      return this.attrs.get(name) != null;\n    }\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute(name) {\n      if (name === 'style') return this.style.cssText;\n      return this.attrs.get(name) == null ? null : this.attrs.get(name);\n    }\n  }, {\n    key: \"getAttributeNS\",\n    value: function getAttributeNS(ns, name) {\n      return this.getAttribute(name);\n    }\n  }, {\n    key: \"hasChildNodes\",\n    value: function hasChildNodes() {\n      return !!this.childNodes.length;\n    }\n  }, {\n    key: \"appendChild\",\n    value: function appendChild(node) {\n      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n        for (var i = 0, il = node.childNodes.length; i < il; ++i) {\n          node.parentNode = this;\n          this.childNodes.push(node.childNodes[i]);\n        }\n\n        node.childNodes.splice(0);\n        return node;\n      }\n\n      if (node.parentNode) {\n        node.parentNode.removeChild(node);\n      }\n\n      node.parentNode = this;\n      this.childNodes.push(node);\n      return node;\n    }\n  }, {\n    key: \"insertBefore\",\n    value: function insertBefore(node, before) {\n      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n        var _index = this.childNodes.indexOf(before);\n\n        if (_index === -1) return this.appendChild(node);\n        this.childNodes = this.childNodes.slice(0, _index).concat(node.childNodes, this.childNodes.slice(_index));\n        node.childNodes.splice(0);\n        return node;\n      }\n\n      if (node.parentNode) {\n        node.parentNode.removeChild(node);\n      }\n\n      node.parentNode = this;\n      var index = this.childNodes.indexOf(before);\n      if (index === -1) return this.appendChild(node);\n      this.childNodes = this.childNodes.slice(0, index).concat(node, this.childNodes.slice(index));\n      return node;\n    }\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(node) {\n      node.parentNode = null;\n      var index = this.childNodes.indexOf(node);\n      if (index === -1) return node;\n      this.childNodes.splice(index, 1);\n      return node;\n    }\n  }, {\n    key: \"replaceChild\",\n    value: function replaceChild(newChild, oldChild) {\n      newChild.parentNode && newChild.parentNode.removeChild(newChild);\n      var before = oldChild.nextSibling;\n      this.removeChild(oldChild);\n      this.insertBefore(newChild, before);\n      return oldChild;\n    }\n  }, {\n    key: \"getElementsByTagName\",\n    value: function getElementsByTagName(name) {\n      return this.childNodes.reduce(function (last, current) {\n        if (current.nodeName === name) last.push(current);\n        return last.concat(current.getElementsByTagName(name));\n      }, []);\n    }\n  }, {\n    key: \"getElementById\",\n    value: function getElementById(id) {\n      for (var i = this.childNodes.length; i--;) {\n        if (this.childNodes[i].id === id) return this.childNodes[i];\n        var el = this.childNodes[i].getElementById(id);\n        if (el) return el;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"cloneNode\",\n    value: function cloneNode(deep) {\n      var clone = _cloneNode(this);\n\n      if (deep) {\n        this.childNodes.forEach(function (el) {\n          var node = el.cloneNode(deep);\n          clone.appendChild(node);\n        });\n      }\n\n      return clone;\n    }\n  }, {\n    key: \"getRootNode\",\n    value: function getRootNode() {\n      if (!this.parentNode || this.parentNode.nodeType === Node.DOCUMENT_NODE) return this;\n      return this.parentNode.getRootNode();\n    }\n  }, {\n    key: \"isDefaultNamespace\",\n    value: function isDefaultNamespace(ns) {\n      return ns === this.attrs.get('xmlns');\n    }\n  }, {\n    key: \"isEqualNode\",\n    value: function isEqualNode(node) {\n      return node.nodeName === this.nodeName && node.constructor === this.constructor && node.nodeType === this.nodeType;\n    }\n  }, {\n    key: \"isSameNode\",\n    value: function isSameNode(node) {\n      return this === node;\n    }\n  }, {\n    key: \"contains\",\n    value: function contains(node) {\n      if (node === this) return false;\n\n      while (node.parentNode) {\n        if (node === this) return true;\n        node = node.parentNode;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      this.childNodes = this.childNodes.reduce(function (textNodes, node) {\n        // FIXME: If first node is an empty textnode, what do we do? -> spec\n        if (!textNodes) return [node];\n        var last = textNodes.pop();\n\n        if (node.nodeType === Node.TEXT_NODE) {\n          if (!node.data) return textNodes;\n\n          if (last.nodeType === Node.TEXT_NODE) {\n            var merged = new TextNode(last.data + ' ' + node.data);\n            textNodes.push(merged);\n            return textNodes.concat(merged);\n          }\n        } else {\n          textNodes.push(last, node);\n        }\n\n        return textNodes;\n      }, null);\n    }\n  }, {\n    key: \"dropNameSpace\",\n    value: function dropNameSpace(ns) {\n      if (this.parentNode) {\n        if (this.parentNode.attrs.get('xmlns') === ns) return true;\n        return this.parentNode.dropNameSpace(ns);\n      }\n\n      return false;\n    }\n  }, {\n    key: \"getBBox\",\n    value: function getBBox() {\n      return bbox(this).bbox();\n    }\n  }, {\n    key: \"getBoundingClientRect\",\n    value: function getBoundingClientRect() {\n      // The bounding client rect takes the screen ctm of the element\n      // and converts the bounding box with it\n      // however, normal bounding consists of:\n      // - all children transformed\n      // - the viewbox of the element if available\n      // The boundingClientRect is not affected by its own viewbox\n      // So we apply only our own transformations and parents screenCTM\n      var m = this.matrixify();\n\n      if (this.parentNode && this.parentNode.nodeName !== '#document') {\n        m = this.parentNode.getScreenCTM().multiply(m);\n      } // let m = this.getScreenCTM()\n\n\n      return bbox(this).transform(m).bbox();\n    }\n  }, {\n    key: \"matrixify\",\n    value: function matrixify() {\n      var matrix = (this.getAttribute('transform') || ''). // split transformations\n      split(regex.transforms).slice(0, -1).map(function (str) {\n        // generate key => value pairs\n        var kv = str.trim().split('(');\n        return [kv[0].trim(), kv[1].split(regex.delimiter).map(function (str) {\n          return parseFloat(str.trim());\n        })];\n      }) // merge every transformation into one matrix\n      .reduce(function (matrix, transform) {\n        if (transform[0] === 'matrix') return matrix.multiply(arrayToMatrix(transform[1]));\n        return matrix[transform[0]].apply(matrix, transform[1]);\n      }, new SVGMatrix());\n      return matrix;\n    } // TODO: https://www.w3.org/TR/SVG2/coords.html#ComputingAViewportsTransform\n\n  }, {\n    key: \"generateViewBoxMatrix\",\n    value: function generateViewBoxMatrix() {\n      var view = (this.getAttribute('viewBox') || '').split(regex.delimiter).map(parseFloat).filter(function (el) {\n        return !isNaN(el);\n      });\n      var width = parseFloat(this.getAttribute('width')) || 0;\n      var height = parseFloat(this.getAttribute('height')) || 0;\n      var x = parseFloat(this.getAttribute('x')) || 0;\n      var y = parseFloat(this.getAttribute('y')) || 0; // TODO: If no width and height is given, width and height of the outer svg element is used\n\n      if (!width || !height) {\n        return new SVGMatrix().translate(x, y);\n      }\n\n      if (view.length !== 4) {\n        view = [0, 0, width, height];\n      } // first apply x and y if nested, then viewbox scale, then viewBox move\n\n\n      return new SVGMatrix().translate(x, y).scale(width / view[2], height / view[3]).translate(-view[0], -view[1]);\n    }\n  }, {\n    key: \"getCTM\",\n    value: function getCTM() {\n      var m = this.matrixify();\n      var node = this;\n\n      while (node = node.parentNode) {\n        if (['svg', 'symbol', 'image', 'pattern', 'marker'].indexOf(node.nodeName) > -1) break;\n        m = m.multiply(node.matrixify());\n        if (node.nodeName === '#document') return this.getScreenCTM();\n      }\n\n      return node.generateViewBoxMatrix().multiply(m);\n    }\n  }, {\n    key: \"getScreenCTM\",\n    value: function getScreenCTM() {\n      // ref: https://bugzilla.mozilla.org/show_bug.cgi?id=1344537\n      // We follow Chromes behavior and include the viewbox in the screenCTM\n      var m = this.getInnerMatrix();\n\n      if (this.parentNode && this.parentNode.nodeName !== '#document') {\n        return this.parentNode.getScreenCTM().multiply(m);\n      }\n\n      return m;\n    }\n  }, {\n    key: \"getInnerMatrix\",\n    value: function getInnerMatrix() {\n      var m = this.matrixify();\n\n      if (['svg', 'symbol', 'image', 'pattern', 'marker'].indexOf(this.nodeName) > -1) {\n        m = this.generateViewBoxMatrix().multiply(m);\n      }\n\n      return m;\n    }\n  }, {\n    key: \"createSVGRect\",\n    value: function createSVGRect() {\n      return new Box();\n    }\n  }, {\n    key: \"createSVGMatrix\",\n    value: function createSVGMatrix() {\n      return new SVGMatrix();\n    }\n  }, {\n    key: \"createSVGPoint\",\n    value: function createSVGPoint() {\n      return new SVGPoint();\n    }\n  }, {\n    key: \"matches\",\n    value: function matches(query) {\n      return new CssQuery(query).matches(this);\n    }\n  }, {\n    key: \"querySelectorAll\",\n    value: function querySelectorAll(query) {\n      var ret = [];\n\n      for (var i = 0, il = this.childNodes.length; i < il; ++i) {\n        if (this.childNodes[i].matches(query)) ret.push(this.childNodes[i]);\n        ret = ret.concat(this.childNodes[i].querySelectorAll(query));\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"querySelector\",\n    value: function querySelector(query) {\n      var ret = [];\n\n      for (var i = 0, il = this.childNodes.length; i < il; ++i) {\n        if (this.childNodes[i].matches(query)) ret.push(this.childNodes[i]);\n        ret = ret.concat(this.childNodes[i].querySelectorAll(query));\n      }\n\n      return ret[0] || null;\n    }\n  }, {\n    key: \"getComputedTextLength\",\n    value: function getComputedTextLength() {\n      return this.getBBox().width;\n    }\n  }, {\n    key: \"getPointAtLength\",\n    value: function getPointAtLength(len) {\n      return pathUtils.pointAtLength(this.getAttribute('d'), len);\n    }\n  }, {\n    key: \"getTotalLength\",\n    value: function getTotalLength() {\n      return pathUtils.length(this.getAttribute('d'));\n    }\n  }, {\n    key: \"getFontDetails\",\n    value: function getFontDetails() {\n      var node = this;\n      var fontSize = null;\n      var fontFamily = null;\n      var textAnchor = null;\n      var dominantBaseline = null;\n      var textContentElements = {\n        text: true,\n        tspan: true,\n        tref: true,\n        textPath: true,\n        altGlyph: true,\n        g: true\n      };\n\n      do {\n        // TODO: stop on\n        if (!fontSize) {\n          fontSize = node.style.fontSize || node.getAttribute('font-size');\n        }\n\n        if (!fontFamily) {\n          fontFamily = node.style.fontFamily || node.getAttribute('font-family');\n        }\n\n        if (!textAnchor) {\n          textAnchor = node.style.textAnchor || node.getAttribute('text-anchor');\n        }\n\n        if (!dominantBaseline) {\n          dominantBaseline = node.style.dominantBaseline || node.getAttribute('dominant-baseline');\n        } // TODO: check for alignment-baseline in tspan, tref, textPath, altGlyph\n        // TODO: alignment-adjust, baseline-shift\n\n        /*\r\n        if(!alignmentBaseline)\r\n        alignmentBaseline = this.style.alignmentBaseline || this.getAttribute('alignment-baseline')\r\n        */\n\n      } while (node.parentNode.nodeType === Node.ELEMENT_NODE && node.parentNode.nodeName in textContentElements && (node = node.parentNode));\n\n      return {\n        fontFamily: fontFamily,\n        fontSize: fontSize,\n        textAnchor: textAnchor || 'start',\n        // TODO: use central for writing-mode === horizontal https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/dominant-baseline\n        dominantBaseline: dominantBaseline || 'alphabetical',\n        fontFamilyMappings: this.ownerDocument.fontFamilyMappings,\n        fontDir: this.ownerDocument.fontDir,\n        preloaded: this.ownerDocument._preloaded\n      };\n    }\n  }]);\n\n  return Node;\n}(EventTarget); // Define dynamic properties\n\n\nObject.defineProperties(Node.prototype, {\n  attributes: {\n    get: function get() {\n      var attributes = mapToAttributeArray(this.attrs);\n\n      if (Object.keys(this._style).length) {\n        attributes.push(new AttributeNode('style', this.getAttribute('style')));\n      }\n\n      return attributes;\n    }\n  },\n  className: {\n    get: function get() {\n      return this.getAttribute('class');\n    },\n    set: function set(c) {\n      this.setAttribute('class', c);\n    }\n  },\n  textContent: {\n    get: function get() {\n      if (this.nodeType === Node.TEXT_NODE) return this.data;\n      return this.childNodes.reduce(function (last, current) {\n        return last + current.textContent;\n      }, '');\n    },\n    set: function set(text) {\n      this.childNodes = [new TextNode('#text', {\n        data: htmlEntities(text)\n      })];\n    }\n  },\n  firstChild: {\n    get: function get() {\n      return this.childNodes[0] || null;\n    }\n  },\n  lastChild: {\n    get: function get() {\n      return this.childNodes[this.childNodes.length - 1] || null;\n    }\n  },\n  children: {\n    get: function get() {\n      return this.childNodes.filter(function (node) {\n        return node.nodeType === Node.ELEMENT_NODE;\n      });\n    }\n  },\n  nextSibling: {\n    get: function get() {\n      var child = this.parentNode && this.parentNode.childNodes[this.parentNode.childNodes.indexOf(this) + 1];\n      return child || null;\n    }\n  },\n  previousSibling: {\n    get: function get() {\n      var child = this.parentNode && this.parentNode.childNodes[this.parentNode.childNodes.indexOf(this) - 1];\n      return child || null;\n    }\n  },\n  innerHTML: {\n    get: function get() {\n      if (this.nodeType === Node.TEXT_NODE) return this.data;\n      return this.childNodes.reduce(function (last, current) {\n        return last + current.outerHTML;\n      }, '');\n    },\n    set: function set(str) {\n      while (this.firstChild) {\n        this.removeChild(this.firstChild);\n      } // The parser adds the html to this\n\n\n      HTMLParser(str, this);\n    }\n  },\n  outerHTML: {\n    get: function get() {\n      if (this.nodeType === Node.TEXT_NODE) return this.data;\n      if (this.nodeType === Node.DOCUMENT_NODE || this.nodeType === Node.DOCUMENT_FRAGMENT_NODE) return this.innerHTML;\n      return tag(this);\n    },\n    set: function set(str) {\n      var well = new SVGElement('well');\n      HTMLParser(str, well);\n\n      for (var i = 0, il = well.childNodes.length; i < il; ++i) {\n        this.parentNode.insertBefore(well.childNodes[i], this);\n      }\n\n      this.parentNode.removeChild(this);\n    }\n  },\n  id: {\n    get: function get() {\n      return this.attrs.get('id');\n    },\n    set: function set(id) {\n      this.attrs.set('id', id);\n    }\n  },\n  ownerSVGElement: {\n    get: function get() {\n      return this.ownerDocument ? this.ownerDocument.documentElement : null;\n    }\n  }\n});\nextendClass(Node, {\n  ELEMENT_NODE: 1,\n  ATTRIBUTE_NODE: 2,\n  TEXT_NODE: 3,\n  CDATA_SECTION_NODE: 4,\n  ENTITY_REFERENCE_NODE: 5,\n  ENTITY_NODE: 6,\n  PROCESSING_INSTRUCTION_NODE: 7,\n  COMMENT_NODE: 8,\n  DOCUMENT_NODE: 9,\n  DOCUMENT_TYPE_NODE: 10,\n  DOCUMENT_FRAGMENT_NODE: 11,\n  NOTATION_NODE: 12\n});\n\nvar SVGElement =\n/*#__PURE__*/\nfunction (_Node) {\n  \"use strict\";\n\n  _inherits(SVGElement, _Node);\n\n  function SVGElement() {\n    _classCallCheck(this, SVGElement);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(SVGElement).apply(this, arguments));\n  }\n\n  return SVGElement;\n}(Node);\n\nvar mapToAttributeArray = function mapToAttributeArray(themap) {\n  return mapMap(themap, function (value, key) {\n    return new AttributeNode(key, value);\n  });\n};\n\nvar DocumentFragment =\n/*#__PURE__*/\nfunction (_Node2) {\n  \"use strict\";\n\n  _inherits(DocumentFragment, _Node2);\n\n  function DocumentFragment() {\n    var _this2;\n\n    _classCallCheck(this, DocumentFragment);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(DocumentFragment).call(this, '#document-fragment'));\n    _this2.nodeType = Node.DOCUMENT_FRAGMENT_NODE;\n    return _this2;\n  }\n\n  return DocumentFragment;\n}(Node);\n\nvar AttributeNode =\n/*#__PURE__*/\nfunction (_Node3) {\n  \"use strict\";\n\n  _inherits(AttributeNode, _Node3);\n\n  function AttributeNode() {\n    var _this3;\n\n    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    _classCallCheck(this, AttributeNode);\n\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(AttributeNode).call(this, name));\n    _this3.nodeValue = value;\n    _this3.nodeType = Node.ATTRIBUTE_NODE;\n    return _this3;\n  }\n\n  return AttributeNode;\n}(Node);\n\nvar CharacterData =\n/*#__PURE__*/\nfunction (_Node4) {\n  \"use strict\";\n\n  _inherits(CharacterData, _Node4);\n\n  function CharacterData(name, props) {\n    var _this4;\n\n    _classCallCheck(this, CharacterData);\n\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(CharacterData).call(this, name, props));\n\n    if (Object.getPrototypeOf(_assertThisInitialized(_assertThisInitialized(_this4))) === CharacterData.prototype) {\n      throw new Error('CharacterData cannot be created directly');\n    }\n\n    return _this4;\n  }\n\n  return CharacterData;\n}(Node);\n\nvar TextNode =\n/*#__PURE__*/\nfunction (_CharacterData) {\n  \"use strict\";\n\n  _inherits(TextNode, _CharacterData);\n\n  function TextNode(name, props) {\n    var _this5;\n\n    _classCallCheck(this, TextNode);\n\n    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(TextNode).call(this, name, props));\n    _this5.nodeType = Node.TEXT_NODE;\n    return _this5;\n  }\n\n  return TextNode;\n}(CharacterData);\n\nvar Comment =\n/*#__PURE__*/\nfunction (_CharacterData2) {\n  \"use strict\";\n\n  _inherits(Comment, _CharacterData2);\n\n  function Comment(name, props) {\n    var _this6;\n\n    _classCallCheck(this, Comment);\n\n    _this6 = _possibleConstructorReturn(this, _getPrototypeOf(Comment).call(this, name, props));\n    _this6.nodeType = Node.COMMENT_NODE;\n    return _this6;\n  }\n\n  return Comment;\n}(CharacterData);\n\nvar HTMLParser = function HTMLParser(str, el) {\n  var currentTag = el;\n  var ownerDocument = el.ownerDocument;\n  var parser = sax.parser(true);\n\n  parser.ontext = function (t) {\n    return currentTag.appendChild(new TextNode('#text', {\n      data: t,\n      ownerDocument: ownerDocument\n    }));\n  };\n\n  parser.onopentag = function (node) {\n    var newSvgElement = new SVGElement(node.name, {\n      attrs: node.attributes,\n      ownerDocument: ownerDocument\n    });\n    currentTag.appendChild(newSvgElement);\n    currentTag = newSvgElement;\n  };\n\n  parser.onclosetag = function (node) {\n    currentTag = currentTag.parentNode;\n  };\n\n  parser.write(str);\n};\n\nmodule.exports = {\n  Node: Node,\n  SVGElement: SVGElement,\n  DocumentFragment: DocumentFragment,\n  AttributeNode: AttributeNode,\n  TextNode: TextNode,\n  Comment: Comment\n};","map":null,"metadata":{},"sourceType":"script"}