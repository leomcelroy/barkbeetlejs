{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/leomcelroy/Desktop/barkbeetle_js/node_modules/@babel/runtime/regenerator\");\n\nvar _slicedToArray = require(\"/Users/leomcelroy/Desktop/barkbeetle_js/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _marked =\n/*#__PURE__*/\n_regeneratorRuntime.mark(walkSvgShapes);\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar path_data_polyfill_1 = require(\"./path-data-polyfill\");\n\nfunction isFlatEnough(_ref, flatness) {\n  var _ref2 = _slicedToArray(_ref, 8),\n      x0 = _ref2[0],\n      y0 = _ref2[1],\n      x1 = _ref2[2],\n      y1 = _ref2[3],\n      x2 = _ref2[4],\n      y2 = _ref2[5],\n      x3 = _ref2[6],\n      y3 = _ref2[7];\n\n  // https://github.com/paperjs/paper.js/blob/a61e83edf2ed1870bd41bad135f4f6fc85b0f628/src/path/Curve.js#L806\n  var ux = 3 * x1 - 2 * x0 - x3,\n      uy = 3 * y1 - 2 * y0 - y3,\n      vx = 3 * x2 - 2 * x3 - x0,\n      vy = 3 * y2 - 2 * y3 - y0;\n  return Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy) <= 16 * flatness * flatness;\n}\n\nfunction subdivide(_ref3, t) {\n  var _ref4 = _slicedToArray(_ref3, 8),\n      x0 = _ref4[0],\n      y0 = _ref4[1],\n      x1 = _ref4[2],\n      y1 = _ref4[3],\n      x2 = _ref4[4],\n      y2 = _ref4[5],\n      x3 = _ref4[6],\n      y3 = _ref4[7];\n\n  // https://github.com/paperjs/paper.js/blob/a61e83edf2ed1870bd41bad135f4f6fc85b0f628/src/path/Curve.js#L606\n  if (t === undefined) t = 0.5; // Triangle computation, with loops unrolled.\n\n  var u = 1 - t,\n      // Interpolate from 4 to 3 points\n  x4 = u * x0 + t * x1,\n      y4 = u * y0 + t * y1,\n      x5 = u * x1 + t * x2,\n      y5 = u * y1 + t * y2,\n      x6 = u * x2 + t * x3,\n      y6 = u * y2 + t * y3,\n      // Interpolate from 3 to 2 points\n  x7 = u * x4 + t * x5,\n      y7 = u * y4 + t * y5,\n      x8 = u * x5 + t * x6,\n      y8 = u * y5 + t * y6,\n      // Interpolate from 2 points to 1 point\n  x9 = u * x7 + t * x8,\n      y9 = u * y7 + t * y8; // We now have all the values we need to build the sub-curves:\n\n  return [[x0, y0, x4, y4, x7, y7, x9, y9], [x9, y9, x8, y8, x6, y6, x3, y3] // right\n  ];\n}\n\nfunction flatten(v, flatness) {\n  var maxRecursion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 32;\n  var minSpan = 1 / maxRecursion;\n  var parts = [];\n\n  function computeParts(curve, t1, t2) {\n    if (t2 - t1 > minSpan && !isFlatEnough(curve, flatness)\n    /* && !isStraight(curve) */\n    ) {\n        var halves = subdivide(curve, 0.5);\n        var tMid = (t1 + t2) / 2;\n        computeParts(halves[0], t1, tMid);\n        computeParts(halves[1], tMid, t2);\n      } else {\n      var dx = curve[6] - curve[0];\n      var dy = curve[7] - curve[1];\n      var dist = Math.sqrt(dx * dx + dy * dy);\n\n      if (dist > 0) {\n        parts.push(curve);\n      }\n    }\n  }\n\n  computeParts(v, 0, 1);\n  return parts;\n}\n\nfunction walkSvgShapes(svgEl) {\n  var _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, child;\n\n  return _regeneratorRuntime.wrap(function walkSvgShapes$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _context.t0 = svgEl.nodeName.toLowerCase();\n          _context.next = _context.t0 === 'svg' ? 3 : _context.t0 === 'g' ? 3 : _context.t0 === 'rect' ? 29 : _context.t0 === 'circle' ? 29 : _context.t0 === 'ellipse' ? 29 : _context.t0 === 'path' ? 29 : _context.t0 === 'line' ? 29 : _context.t0 === 'polyline' ? 29 : _context.t0 === 'polygon' ? 29 : 32;\n          break;\n\n        case 3:\n          _iteratorNormalCompletion = true;\n          _didIteratorError = false;\n          _iteratorError = undefined;\n          _context.prev = 6;\n          _iterator = svgEl.children[Symbol.iterator]();\n\n        case 8:\n          if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n            _context.next = 14;\n            break;\n          }\n\n          child = _step.value;\n          return _context.delegateYield(walkSvgShapes(child), \"t1\", 11);\n\n        case 11:\n          _iteratorNormalCompletion = true;\n          _context.next = 8;\n          break;\n\n        case 14:\n          _context.next = 20;\n          break;\n\n        case 16:\n          _context.prev = 16;\n          _context.t2 = _context[\"catch\"](6);\n          _didIteratorError = true;\n          _iteratorError = _context.t2;\n\n        case 20:\n          _context.prev = 20;\n          _context.prev = 21;\n\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n\n        case 23:\n          _context.prev = 23;\n\n          if (!_didIteratorError) {\n            _context.next = 26;\n            break;\n          }\n\n          throw _iteratorError;\n\n        case 26:\n          return _context.finish(23);\n\n        case 27:\n          return _context.finish(20);\n\n        case 28:\n          return _context.abrupt(\"break\", 32);\n\n        case 29:\n          _context.next = 31;\n          return svgEl;\n\n        case 31:\n          return _context.abrupt(\"break\", 32);\n\n        case 32:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked, this, [[6, 16, 20, 28], [21,, 23, 27]]);\n}\n\nfunction flattenSVG(svg) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _options$maxError = options.maxError,\n      maxError = _options$maxError === void 0 ? 0.1 : _options$maxError;\n  var svgPoint = svg.createSVGPoint();\n  var paths = [];\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    var _loop = function _loop() {\n      var path = _step2.value;\n      var type = path.nodeName.toLowerCase();\n      var ctm = path.getCTM();\n\n      var xf = function xf(_ref5) {\n        var _ref6 = _slicedToArray(_ref5, 2),\n            x = _ref6[0],\n            y = _ref6[1];\n\n        svgPoint.x = x;\n        svgPoint.y = y;\n        var xfd = svgPoint.matrixTransform(ctm);\n        return [xfd.x, xfd.y];\n      };\n\n      var pathData = path_data_polyfill_1.getPathData(path, {\n        normalize: true\n      });\n      var cur = null;\n      var closePoint = null;\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = pathData[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var cmd = _step3.value;\n\n          if (cmd.type === 'M') {\n            cur = xf(cmd.values);\n            closePoint = cur;\n            paths.push({\n              points: [cur],\n              stroke: path.getAttribute('stroke') // getComputedStyle doesn't seem to work until the JS loop that inserted it is done...\n              // stroke: path.getComputedStyle(path).stroke\n\n            });\n          } else if (cmd.type === 'L') {\n            cur = xf(cmd.values);\n            paths[paths.length - 1].points.push(cur);\n          } else if (cmd.type === 'C') {\n            var _cmd$values = _slicedToArray(cmd.values, 6),\n                x1 = _cmd$values[0],\n                y1 = _cmd$values[1],\n                x2 = _cmd$values[2],\n                y2 = _cmd$values[3],\n                x3 = _cmd$values[4],\n                y3 = _cmd$values[5];\n\n            var _cur = cur,\n                _cur2 = _slicedToArray(_cur, 2),\n                x0 = _cur2[0],\n                y0 = _cur2[1];\n\n            var _xf = xf([x1, y1]),\n                _xf2 = _slicedToArray(_xf, 2),\n                tx1 = _xf2[0],\n                ty1 = _xf2[1];\n\n            var _xf3 = xf([x2, y2]),\n                _xf4 = _slicedToArray(_xf3, 2),\n                tx2 = _xf4[0],\n                ty2 = _xf4[1];\n\n            var _xf5 = xf([x3, y3]),\n                _xf6 = _slicedToArray(_xf5, 2),\n                tx3 = _xf6[0],\n                ty3 = _xf6[1];\n\n            var parts = flatten([x0, y0, tx1, ty1, tx2, ty2, tx3, ty3], maxError);\n            var _iteratorNormalCompletion4 = true;\n            var _didIteratorError4 = false;\n            var _iteratorError4 = undefined;\n\n            try {\n              for (var _iterator4 = parts[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n                var part = _step4.value;\n                paths[paths.length - 1].points.push([part[6], part[7]]);\n              }\n            } catch (err) {\n              _didIteratorError4 = true;\n              _iteratorError4 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n                  _iterator4.return();\n                }\n              } finally {\n                if (_didIteratorError4) {\n                  throw _iteratorError4;\n                }\n              }\n            }\n\n            cur = [tx3, ty3];\n          } else if (cmd.type === 'A') {\n            (function () {\n              var _cmd$values2 = _slicedToArray(cmd.values, 7),\n                  rx_ = _cmd$values2[0],\n                  ry_ = _cmd$values2[1],\n                  xAxisRotation = _cmd$values2[2],\n                  largeArc = _cmd$values2[3],\n                  sweep = _cmd$values2[4],\n                  x = _cmd$values2[5],\n                  y = _cmd$values2[6];\n\n              var phi = xAxisRotation;\n              var fS = sweep;\n              var fA = largeArc;\n              var cos = Math.cos,\n                  sin = Math.sin,\n                  atan2 = Math.atan2,\n                  sqrt = Math.sqrt,\n                  sign = Math.sign,\n                  acos = Math.acos,\n                  abs = Math.abs,\n                  ceil = Math.ceil; // https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n\n              var mpx = (cur[0] - x) / 2,\n                  mpy = (cur[1] - y) / 2;\n              var x1_ = cos(phi) * mpx + sin(phi) * mpy,\n                  y1_ = -sin(phi) * mpx + cos(phi) * mpy;\n              var x1_2 = x1_ * x1_,\n                  y1_2 = y1_ * y1_; // ... ensure radii are large enough\n\n              var L = x1_2 / (rx_ * rx_) + y1_2 / (ry_ * ry_);\n              var rx = L <= 1 ? sqrt(L) * rx_ : rx_;\n              var ry = L <= 1 ? sqrt(L) * ry_ : ry_;\n              var rx2 = rx * rx,\n                  ry2 = ry * ry;\n              var factor = (rx2 * ry2 - rx2 * y1_2 - ry2 * x1_2) / (rx2 * y1_2 + ry2 * x1_2);\n              if (abs(factor) < 0.0001) factor = 0;\n              if (factor < 0) throw new Error(\"bad arc args \".concat(factor));\n              var k = (fA === fS ? -1 : 1) * sqrt(factor);\n              var cx_ = k * rx * y1_ / ry,\n                  cy_ = k * -ry * x1_ / rx;\n              var cx = cos(phi) * cx_ - sin(phi) * cy_ + (cur[0] + x) / 2,\n                  cy = sin(phi) * cx_ + cos(phi) * cy_ + (cur[1] + y) / 2;\n\n              var ang = function ang(ux, uy, vx, vy) {\n                /*\n                (ux*vy - uy*vx < 0 ? -1 : 1) *\n                  acos((ux*vx+uy*vy) / sqrt(ux*ux+uy*uy)*sqrt(vx*vx+vy*vy))\n                  */\n                // https://github.com/paperjs/paper.js/blob/f5366fb3cb53bc1ea52e9792e2ec2584c0c4f9c1/src/path/Path.js#L2516\n                return atan2(ux * vy - uy * vx, ux * vx + uy * vy);\n              };\n\n              var t1 = ang(1, 0, (x1_ - cx_) / rx, (y1_ - cy_) / ry);\n              var dt_ = ang((x1_ - cx_) / rx, (y1_ - cy_) / ry, (-x1_ - cx_) / rx, (-y1_ - cy_) / ry) % (Math.PI * 2);\n              var dt = fS === 0 && dt_ > 0 ? dt_ - Math.PI * 2 : fS === 1 && dt_ < 0 ? dt_ + Math.PI * 2 : dt_; // now:\n              // - (cx, cy) is the center of the ellipse\n              // - (rx, ry) is the radius\n              // - phi is the angle around the x-axis of the current\n              //   coordinate system to the x-axis of the ellipse\n              // - t1 is the start angle of the elliptical arc prior to the stretch and rotate operations.\n              // - t1+dt is the end angle of the elliptical arc prior to the stretch and rotate operations.\n              // parameterization:\n              // ( x )  =  ( cos phi   -sin phi ) . ( rx cos t )  +  ( cx )\n              // ( y )  =  ( sin phi    cos phi )   ( ry sin t )     ( cy )\n              // https://i.imgur.com/JORhNjU.jpg\n              // maximum error based on maximum deviation from true arc\n\n              var e0 = maxError;\n              var n = ceil(abs(dt) / acos(1 - e0 / rx));\n\n              for (var i = 1; i <= n; i++) {\n                var theta = t1 + dt * i / n;\n                var tx = cos(phi) * rx * cos(theta) - sin(phi) * ry * sin(theta) + cx;\n                var ty = sin(phi) * rx * cos(theta) + cos(phi) * ry * sin(theta) + cy;\n                paths[paths.length - 1].points.push([tx, ty]);\n              }\n\n              cur = [x, y];\n            })();\n          } else if (cmd.type === 'Z') {\n            if (closePoint && (cur[0] !== closePoint[0] || cur[1] !== closePoint[1])) {\n              paths[paths.length - 1].points.push(closePoint);\n            }\n          } else {\n            throw Error(\"Unexpected path command: \\\"\".concat(cmd, \"\\\"\"));\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    };\n\n    for (var _iterator2 = walkSvgShapes(svg)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      _loop();\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return paths;\n}\n\nexports.flattenSVG = flattenSVG;","map":null,"metadata":{},"sourceType":"script"}