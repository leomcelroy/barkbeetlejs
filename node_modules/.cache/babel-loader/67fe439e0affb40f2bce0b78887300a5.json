{"ast":null,"code":"/** @module utils/PropTypes/controlled */\nimport PropTypes from 'prop-types';\n/**\n * Validates the a component is fully controlled or uncontrolled.  If the given prop is not\n * `undefined`, it will check if the `funcName` is defined and a function. A missing function\n * will generate an error similar to the built-in React controlled validation message.\n *\n * @param {String} funcName - The function name to use for additional validation.\n * @param {function} validator - The PropTypes validator to use for the given prop.\n * @return {Error} an error or null.\n */\n\nexport default function controlled(validator, funcName) {\n  var fallbackPropName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'defaultValue';\n  return function validate(props, propName, componentName, location, propFullName) {\n    var componentNameSafe = componentName || '<<anonymous>>';\n    var propFullNameSafe = propFullName || propName;\n\n    for (var _len = arguments.length, args = Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {\n      args[_key - 5] = arguments[_key];\n    }\n\n    var err = validator.apply(undefined, [props, propName, componentName, location, propFullName].concat(args));\n\n    if (!err && typeof props[propName] !== 'undefined' && !props.readOnly && !props.disabled) {\n      var _PropTypes$func;\n\n      var funcError = (_PropTypes$func = PropTypes.func).isRequired.apply(_PropTypes$func, [props, funcName, componentName, location, propFullName].concat(args));\n\n      if (funcError) {\n        err = new Error('You provided a `' + propFullNameSafe + '` ' + location + ' to the ' + componentNameSafe + ' without a ' + ('`' + funcName + '` handler. This will render a read only field. Set either the `' + funcName + '` ') + ('or use the `' + fallbackPropName + '` instead.'));\n      }\n    }\n\n    return err;\n  };\n}","map":null,"metadata":{},"sourceType":"module"}