{"ast":null,"code":"// rev 452\n\n/********************************************************************************\n*                                                                              *\n* Author    :  Angus Johnson                                                   *\n* Version   :  6.1.3a                                                          *\n* Date      :  22 January 2014                                                 *\n* Website   :  http://www.angusj.com                                           *\n* Copyright :  Angus Johnson 2010-2014                                         *\n*                                                                              *\n* License:                                                                     *\n* Use, modification & distribution is subject to Boost Software License Ver 1. *\n* http://www.boost.org/LICENSE_1_0.txt                                         *\n*                                                                              *\n* Attributions:                                                                *\n* The code in this library is an extension of Bala Vatti's clipping algorithm: *\n* \"A generic solution to polygon clipping\"                                     *\n* Communications of the ACM, Vol 35, Issue 7 (July 1992) pp 56-63.             *\n* http://portal.acm.org/citation.cfm?id=129906                                 *\n*                                                                              *\n* Computer graphics and geometric modeling: implementation and algorithms      *\n* By Max K. Agoston                                                            *\n* Springer; 1 edition (January 4, 2005)                                        *\n* http://books.google.com/books?q=vatti+clipping+agoston                       *\n*                                                                              *\n* See also:                                                                    *\n* \"Polygon Offsetting by Computing Winding Numbers\"                            *\n* Paper no. DETC2005-85513 pp. 565-575                                         *\n* ASME 2005 International Design Engineering Technical Conferences             *\n* and Computers and Information in Engineering Conference (IDETC/CIE2005)      *\n* September 24-28, 2005 , Long Beach, California, USA                          *\n* http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf              *\n*                                                                              *\n*******************************************************************************/\n\n/*******************************************************************************\n*                                                                              *\n* Author    :  Timo                                                            *\n* Version   :  6.1.3.2                                                         *\n* Date      :  1 February 2014                                                 *\n*                                                                              *\n* This is a translation of the C# Clipper library to Javascript.               *\n* Int128 struct of C# is implemented using JSBN of Tom Wu.                     *\n* Because Javascript lacks support for 64-bit integers, the space              *\n* is a little more restricted than in C# version.                              *\n*                                                                              *\n* C# version has support for coordinate space:                                 *\n* +-4611686018427387903 ( sqrt(2^127 -1)/2 )                                   *\n* while Javascript version has support for space:                              *\n* +-4503599627370495 ( sqrt(2^106 -1)/2 )                                      *\n*                                                                              *\n* Tom Wu's JSBN proved to be the fastest big integer library:                  *\n* http://jsperf.com/big-integer-library-test                                   *\n*                                                                              *\n* This class can be made simpler when (if ever) 64-bit integer support comes.  *\n*                                                                              *\n*******************************************************************************/\n\n/*******************************************************************************\n*                                                                              *\n* Basic JavaScript BN library - subset useful for RSA encryption.              *\n* http://www-cs-students.stanford.edu/~tjw/jsbn/                               *\n* Copyright (c) 2005  Tom Wu                                                   *\n* All Rights Reserved.                                                         *\n* See \"LICENSE\" for details:                                                   *\n* http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE                        *\n*                                                                              *\n*******************************************************************************/\n\"use strict\"; //use_int32: When enabled 32bit ints are used instead of 64bit ints. This\n//improve performance but coordinate values are limited to the range +/- 46340\n\nvar use_int32 = false; //use_xyz: adds a Z member to IntPoint. Adds a minor cost to performance.\n\nvar use_xyz = false; //UseLines: Enables line clipping. Adds a very minor cost to performance.\n\nvar use_lines = true; //use_deprecated: Enables support for the obsolete OffsetPaths() function\n//which has been replace with the ClipperOffset class.\n\nvar use_deprecated = false;\nvar ClipperLib = {};\nvar isNode = false;\n\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = ClipperLib;\n  isNode = true;\n} else {\n  if (typeof document !== \"undefined\") window.ClipperLib = ClipperLib;else self['ClipperLib'] = ClipperLib;\n}\n\nvar navigator_appName;\n\nif (!isNode) {\n  var nav = navigator.userAgent.toString().toLowerCase();\n  navigator_appName = navigator.appName;\n} else {\n  var nav = \"chrome\"; // Node.js uses Chrome's V8 engine\n\n  navigator_appName = \"Netscape\"; // Firefox, Chrome and Safari returns \"Netscape\", so Node.js should also\n} // Browser test to speedup performance critical functions\n\n\nvar browser = {};\nif (nav.indexOf(\"chrome\") != -1 && nav.indexOf(\"chromium\") == -1) browser.chrome = 1;else browser.chrome = 0;\nif (nav.indexOf(\"chromium\") != -1) browser.chromium = 1;else browser.chromium = 0;\nif (nav.indexOf(\"safari\") != -1 && nav.indexOf(\"chrome\") == -1 && nav.indexOf(\"chromium\") == -1) browser.safari = 1;else browser.safari = 0;\nif (nav.indexOf(\"firefox\") != -1) browser.firefox = 1;else browser.firefox = 0;\nif (nav.indexOf(\"firefox/17\") != -1) browser.firefox17 = 1;else browser.firefox17 = 0;\nif (nav.indexOf(\"firefox/15\") != -1) browser.firefox15 = 1;else browser.firefox15 = 0;\nif (nav.indexOf(\"firefox/3\") != -1) browser.firefox3 = 1;else browser.firefox3 = 0;\nif (nav.indexOf(\"opera\") != -1) browser.opera = 1;else browser.opera = 0;\nif (nav.indexOf(\"msie 10\") != -1) browser.msie10 = 1;else browser.msie10 = 0;\nif (nav.indexOf(\"msie 9\") != -1) browser.msie9 = 1;else browser.msie9 = 0;\nif (nav.indexOf(\"msie 8\") != -1) browser.msie8 = 1;else browser.msie8 = 0;\nif (nav.indexOf(\"msie 7\") != -1) browser.msie7 = 1;else browser.msie7 = 0;\nif (nav.indexOf(\"msie \") != -1) browser.msie = 1;else browser.msie = 0;\nClipperLib.biginteger_used = null; // Copyright (c) 2005  Tom Wu\n// All Rights Reserved.\n// See \"LICENSE\" for details.\n// Basic JavaScript BN library - subset useful for RSA encryption.\n// Bits per digit\n\nvar dbits; // JavaScript engine analysis\n\nvar canary = 0xdeadbeefcafe;\nvar j_lm = (canary & 0xffffff) == 0xefcafe; // (public) Constructor\n\nfunction BigInteger(a, b, c) {\n  // This test variable can be removed,\n  // but at least for performance tests it is useful piece of knowledge\n  // This is the only ClipperLib related variable in BigInteger library\n  ClipperLib.biginteger_used = 1;\n  if (a != null) if (\"number\" == typeof a && \"undefined\" == typeof b) this.fromInt(a); // faster conversion\n  else if (\"number\" == typeof a) this.fromNumber(a, b, c);else if (b == null && \"string\" != typeof a) this.fromString(a, 256);else this.fromString(a, b);\n} // return new, unset BigInteger\n\n\nfunction nbi() {\n  return new BigInteger(null);\n} // am: Compute w_j += (x*this_i), propagate carries,\n// c is initial carry, returns final carry.\n// c < 3*dvalue, x < 2*dvalue, this_i < dvalue\n// We need to select the fastest one that works in this environment.\n// am1: use a single mult and divide to get the high bits,\n// max digit bits should be 26 because\n// max internal value = 2*dvalue^2-2*dvalue (< 2^53)\n\n\nfunction am1(i, x, w, j, c, n) {\n  while (--n >= 0) {\n    var v = x * this[i++] + w[j] + c;\n    c = Math.floor(v / 0x4000000);\n    w[j++] = v & 0x3ffffff;\n  }\n\n  return c;\n} // am2 avoids a big mult-and-extract completely.\n// Max digit bits should be <= 30 because we do bitwise ops\n// on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)\n\n\nfunction am2(i, x, w, j, c, n) {\n  var xl = x & 0x7fff,\n      xh = x >> 15;\n\n  while (--n >= 0) {\n    var l = this[i] & 0x7fff;\n    var h = this[i++] >> 15;\n    var m = xh * l + h * xl;\n    l = xl * l + ((m & 0x7fff) << 15) + w[j] + (c & 0x3fffffff);\n    c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);\n    w[j++] = l & 0x3fffffff;\n  }\n\n  return c;\n} // Alternately, set max digit bits to 28 since some\n// browsers slow down when dealing with 32-bit numbers.\n\n\nfunction am3(i, x, w, j, c, n) {\n  var xl = x & 0x3fff,\n      xh = x >> 14;\n\n  while (--n >= 0) {\n    var l = this[i] & 0x3fff;\n    var h = this[i++] >> 14;\n    var m = xh * l + h * xl;\n    l = xl * l + ((m & 0x3fff) << 14) + w[j] + c;\n    c = (l >> 28) + (m >> 14) + xh * h;\n    w[j++] = l & 0xfffffff;\n  }\n\n  return c;\n}\n\nif (j_lm && navigator_appName == \"Microsoft Internet Explorer\") {\n  BigInteger.prototype.am = am2;\n  dbits = 30;\n} else if (j_lm && navigator_appName != \"Netscape\") {\n  BigInteger.prototype.am = am1;\n  dbits = 26;\n} else {\n  // Mozilla/Netscape seems to prefer am3\n  BigInteger.prototype.am = am3;\n  dbits = 28;\n}\n\nBigInteger.prototype.DB = dbits;\nBigInteger.prototype.DM = (1 << dbits) - 1;\nBigInteger.prototype.DV = 1 << dbits;\nvar BI_FP = 52;\nBigInteger.prototype.FV = Math.pow(2, BI_FP);\nBigInteger.prototype.F1 = BI_FP - dbits;\nBigInteger.prototype.F2 = 2 * dbits - BI_FP; // Digit conversions\n\nvar BI_RM = \"0123456789abcdefghijklmnopqrstuvwxyz\";\nvar BI_RC = new Array();\nvar rr, vv;\nrr = \"0\".charCodeAt(0);\n\nfor (vv = 0; vv <= 9; ++vv) {\n  BI_RC[rr++] = vv;\n}\n\nrr = \"a\".charCodeAt(0);\n\nfor (vv = 10; vv < 36; ++vv) {\n  BI_RC[rr++] = vv;\n}\n\nrr = \"A\".charCodeAt(0);\n\nfor (vv = 10; vv < 36; ++vv) {\n  BI_RC[rr++] = vv;\n}\n\nfunction int2char(n) {\n  return BI_RM.charAt(n);\n}\n\nfunction intAt(s, i) {\n  var c = BI_RC[s.charCodeAt(i)];\n  return c == null ? -1 : c;\n} // (protected) copy this to r\n\n\nfunction bnpCopyTo(r) {\n  for (var i = this.t - 1; i >= 0; --i) {\n    r[i] = this[i];\n  }\n\n  r.t = this.t;\n  r.s = this.s;\n} // (protected) set from integer value x, -DV <= x < DV\n\n\nfunction bnpFromInt(x) {\n  this.t = 1;\n  this.s = x < 0 ? -1 : 0;\n  if (x > 0) this[0] = x;else if (x < -1) this[0] = x + this.DV;else this.t = 0;\n} // return bigint initialized to value\n\n\nfunction nbv(i) {\n  var r = nbi();\n  r.fromInt(i);\n  return r;\n} // (protected) set from string and radix\n\n\nfunction bnpFromString(s, b) {\n  var k;\n  if (b == 16) k = 4;else if (b == 8) k = 3;else if (b == 256) k = 8; // byte array\n  else if (b == 2) k = 1;else if (b == 32) k = 5;else if (b == 4) k = 2;else {\n      this.fromRadix(s, b);\n      return;\n    }\n  this.t = 0;\n  this.s = 0;\n  var i = s.length,\n      mi = false,\n      sh = 0;\n\n  while (--i >= 0) {\n    var x = k == 8 ? s[i] & 0xff : intAt(s, i);\n\n    if (x < 0) {\n      if (s.charAt(i) == \"-\") mi = true;\n      continue;\n    }\n\n    mi = false;\n    if (sh == 0) this[this.t++] = x;else if (sh + k > this.DB) {\n      this[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;\n      this[this.t++] = x >> this.DB - sh;\n    } else this[this.t - 1] |= x << sh;\n    sh += k;\n    if (sh >= this.DB) sh -= this.DB;\n  }\n\n  if (k == 8 && (s[0] & 0x80) != 0) {\n    this.s = -1;\n    if (sh > 0) this[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;\n  }\n\n  this.clamp();\n  if (mi) BigInteger.ZERO.subTo(this, this);\n} // (protected) clamp off excess high words\n\n\nfunction bnpClamp() {\n  var c = this.s & this.DM;\n\n  while (this.t > 0 && this[this.t - 1] == c) {\n    --this.t;\n  }\n} // (public) return string representation in given radix\n\n\nfunction bnToString(b) {\n  if (this.s < 0) return \"-\" + this.negate().toString(b);\n  var k;\n  if (b == 16) k = 4;else if (b == 8) k = 3;else if (b == 2) k = 1;else if (b == 32) k = 5;else if (b == 4) k = 2;else return this.toRadix(b);\n  var km = (1 << k) - 1,\n      d,\n      m = false,\n      r = \"\",\n      i = this.t;\n  var p = this.DB - i * this.DB % k;\n\n  if (i-- > 0) {\n    if (p < this.DB && (d = this[i] >> p) > 0) {\n      m = true;\n      r = int2char(d);\n    }\n\n    while (i >= 0) {\n      if (p < k) {\n        d = (this[i] & (1 << p) - 1) << k - p;\n        d |= this[--i] >> (p += this.DB - k);\n      } else {\n        d = this[i] >> (p -= k) & km;\n\n        if (p <= 0) {\n          p += this.DB;\n          --i;\n        }\n      }\n\n      if (d > 0) m = true;\n      if (m) r += int2char(d);\n    }\n  }\n\n  return m ? r : \"0\";\n} // (public) -this\n\n\nfunction bnNegate() {\n  var r = nbi();\n  BigInteger.ZERO.subTo(this, r);\n  return r;\n} // (public) |this|\n\n\nfunction bnAbs() {\n  return this.s < 0 ? this.negate() : this;\n} // (public) return + if this > a, - if this < a, 0 if equal\n\n\nfunction bnCompareTo(a) {\n  var r = this.s - a.s;\n  if (r != 0) return r;\n  var i = this.t;\n  r = i - a.t;\n  if (r != 0) return this.s < 0 ? -r : r;\n\n  while (--i >= 0) {\n    if ((r = this[i] - a[i]) != 0) return r;\n  }\n\n  return 0;\n} // returns bit length of the integer x\n\n\nfunction nbits(x) {\n  var r = 1,\n      t;\n\n  if ((t = x >>> 16) != 0) {\n    x = t;\n    r += 16;\n  }\n\n  if ((t = x >> 8) != 0) {\n    x = t;\n    r += 8;\n  }\n\n  if ((t = x >> 4) != 0) {\n    x = t;\n    r += 4;\n  }\n\n  if ((t = x >> 2) != 0) {\n    x = t;\n    r += 2;\n  }\n\n  if ((t = x >> 1) != 0) {\n    x = t;\n    r += 1;\n  }\n\n  return r;\n} // (public) return the number of bits in \"this\"\n\n\nfunction bnBitLength() {\n  if (this.t <= 0) return 0;\n  return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);\n} // (protected) r = this << n*DB\n\n\nfunction bnpDLShiftTo(n, r) {\n  var i;\n\n  for (i = this.t - 1; i >= 0; --i) {\n    r[i + n] = this[i];\n  }\n\n  for (i = n - 1; i >= 0; --i) {\n    r[i] = 0;\n  }\n\n  r.t = this.t + n;\n  r.s = this.s;\n} // (protected) r = this >> n*DB\n\n\nfunction bnpDRShiftTo(n, r) {\n  for (var i = n; i < this.t; ++i) {\n    r[i - n] = this[i];\n  }\n\n  r.t = Math.max(this.t - n, 0);\n  r.s = this.s;\n} // (protected) r = this << n\n\n\nfunction bnpLShiftTo(n, r) {\n  var bs = n % this.DB;\n  var cbs = this.DB - bs;\n  var bm = (1 << cbs) - 1;\n  var ds = Math.floor(n / this.DB),\n      c = this.s << bs & this.DM,\n      i;\n\n  for (i = this.t - 1; i >= 0; --i) {\n    r[i + ds + 1] = this[i] >> cbs | c;\n    c = (this[i] & bm) << bs;\n  }\n\n  for (i = ds - 1; i >= 0; --i) {\n    r[i] = 0;\n  }\n\n  r[ds] = c;\n  r.t = this.t + ds + 1;\n  r.s = this.s;\n  r.clamp();\n} // (protected) r = this >> n\n\n\nfunction bnpRShiftTo(n, r) {\n  r.s = this.s;\n  var ds = Math.floor(n / this.DB);\n\n  if (ds >= this.t) {\n    r.t = 0;\n    return;\n  }\n\n  var bs = n % this.DB;\n  var cbs = this.DB - bs;\n  var bm = (1 << bs) - 1;\n  r[0] = this[ds] >> bs;\n\n  for (var i = ds + 1; i < this.t; ++i) {\n    r[i - ds - 1] |= (this[i] & bm) << cbs;\n    r[i - ds] = this[i] >> bs;\n  }\n\n  if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;\n  r.t = this.t - ds;\n  r.clamp();\n} // (protected) r = this - a\n\n\nfunction bnpSubTo(a, r) {\n  var i = 0,\n      c = 0,\n      m = Math.min(a.t, this.t);\n\n  while (i < m) {\n    c += this[i] - a[i];\n    r[i++] = c & this.DM;\n    c >>= this.DB;\n  }\n\n  if (a.t < this.t) {\n    c -= a.s;\n\n    while (i < this.t) {\n      c += this[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n\n    c += this.s;\n  } else {\n    c += this.s;\n\n    while (i < a.t) {\n      c -= a[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n\n    c -= a.s;\n  }\n\n  r.s = c < 0 ? -1 : 0;\n  if (c < -1) r[i++] = this.DV + c;else if (c > 0) r[i++] = c;\n  r.t = i;\n  r.clamp();\n} // (protected) r = this * a, r != this,a (HAC 14.12)\n// \"this\" should be the larger one if appropriate.\n\n\nfunction bnpMultiplyTo(a, r) {\n  var x = this.abs(),\n      y = a.abs();\n  var i = x.t;\n  r.t = i + y.t;\n\n  while (--i >= 0) {\n    r[i] = 0;\n  }\n\n  for (i = 0; i < y.t; ++i) {\n    r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);\n  }\n\n  r.s = 0;\n  r.clamp();\n  if (this.s != a.s) BigInteger.ZERO.subTo(r, r);\n} // (protected) r = this^2, r != this (HAC 14.16)\n\n\nfunction bnpSquareTo(r) {\n  var x = this.abs();\n  var i = r.t = 2 * x.t;\n\n  while (--i >= 0) {\n    r[i] = 0;\n  }\n\n  for (i = 0; i < x.t - 1; ++i) {\n    var c = x.am(i, x[i], r, 2 * i, 0, 1);\n\n    if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {\n      r[i + x.t] -= x.DV;\n      r[i + x.t + 1] = 1;\n    }\n  }\n\n  if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);\n  r.s = 0;\n  r.clamp();\n} // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)\n// r != q, this != m.  q or r may be null.\n\n\nfunction bnpDivRemTo(m, q, r) {\n  var pm = m.abs();\n  if (pm.t <= 0) return;\n  var pt = this.abs();\n\n  if (pt.t < pm.t) {\n    if (q != null) q.fromInt(0);\n    if (r != null) this.copyTo(r);\n    return;\n  }\n\n  if (r == null) r = nbi();\n  var y = nbi(),\n      ts = this.s,\n      ms = m.s;\n  var nsh = this.DB - nbits(pm[pm.t - 1]); // normalize modulus\n\n  if (nsh > 0) {\n    pm.lShiftTo(nsh, y);\n    pt.lShiftTo(nsh, r);\n  } else {\n    pm.copyTo(y);\n    pt.copyTo(r);\n  }\n\n  var ys = y.t;\n  var y0 = y[ys - 1];\n  if (y0 == 0) return;\n  var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);\n  var d1 = this.FV / yt,\n      d2 = (1 << this.F1) / yt,\n      e = 1 << this.F2;\n  var i = r.t,\n      j = i - ys,\n      t = q == null ? nbi() : q;\n  y.dlShiftTo(j, t);\n\n  if (r.compareTo(t) >= 0) {\n    r[r.t++] = 1;\n    r.subTo(t, r);\n  }\n\n  BigInteger.ONE.dlShiftTo(ys, t);\n  t.subTo(y, y); // \"negative\" y so we can replace sub with am later\n\n  while (y.t < ys) {\n    y[y.t++] = 0;\n  }\n\n  while (--j >= 0) {\n    // Estimate quotient digit\n    var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);\n\n    if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {\n      // Try it out\n      y.dlShiftTo(j, t);\n      r.subTo(t, r);\n\n      while (r[i] < --qd) {\n        r.subTo(t, r);\n      }\n    }\n  }\n\n  if (q != null) {\n    r.drShiftTo(ys, q);\n    if (ts != ms) BigInteger.ZERO.subTo(q, q);\n  }\n\n  r.t = ys;\n  r.clamp();\n  if (nsh > 0) r.rShiftTo(nsh, r); // Denormalize remainder\n\n  if (ts < 0) BigInteger.ZERO.subTo(r, r);\n} // (public) this mod a\n\n\nfunction bnMod(a) {\n  var r = nbi();\n  this.abs().divRemTo(a, null, r);\n  if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);\n  return r;\n} // Modular reduction using \"classic\" algorithm\n\n\nfunction Classic(m) {\n  this.m = m;\n}\n\nfunction cConvert(x) {\n  if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);else return x;\n}\n\nfunction cRevert(x) {\n  return x;\n}\n\nfunction cReduce(x) {\n  x.divRemTo(this.m, null, x);\n}\n\nfunction cMulTo(x, y, r) {\n  x.multiplyTo(y, r);\n  this.reduce(r);\n}\n\nfunction cSqrTo(x, r) {\n  x.squareTo(r);\n  this.reduce(r);\n}\n\nClassic.prototype.convert = cConvert;\nClassic.prototype.revert = cRevert;\nClassic.prototype.reduce = cReduce;\nClassic.prototype.mulTo = cMulTo;\nClassic.prototype.sqrTo = cSqrTo; // (protected) return \"-1/this % 2^DB\"; useful for Mont. reduction\n// justification:\n//         xy == 1 (mod m)\n//         xy =  1+km\n//   xy(2-xy) = (1+km)(1-km)\n// x[y(2-xy)] = 1-k^2m^2\n// x[y(2-xy)] == 1 (mod m^2)\n// if y is 1/x mod m, then y(2-xy) is 1/x mod m^2\n// should reduce x and y(2-xy) by m^2 at each step to keep size bounded.\n// JS multiply \"overflows\" differently from C/C++, so care is needed here.\n\nfunction bnpInvDigit() {\n  if (this.t < 1) return 0;\n  var x = this[0];\n  if ((x & 1) == 0) return 0;\n  var y = x & 3; // y == 1/x mod 2^2\n\n  y = y * (2 - (x & 0xf) * y) & 0xf; // y == 1/x mod 2^4\n\n  y = y * (2 - (x & 0xff) * y) & 0xff; // y == 1/x mod 2^8\n\n  y = y * (2 - ((x & 0xffff) * y & 0xffff)) & 0xffff; // y == 1/x mod 2^16\n  // last step - calculate inverse mod DV directly;\n  // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints\n\n  y = y * (2 - x * y % this.DV) % this.DV; // y == 1/x mod 2^dbits\n  // we really want the negative inverse, and -DV < y < DV\n\n  return y > 0 ? this.DV - y : -y;\n} // Montgomery reduction\n\n\nfunction Montgomery(m) {\n  this.m = m;\n  this.mp = m.invDigit();\n  this.mpl = this.mp & 0x7fff;\n  this.mph = this.mp >> 15;\n  this.um = (1 << m.DB - 15) - 1;\n  this.mt2 = 2 * m.t;\n} // xR mod m\n\n\nfunction montConvert(x) {\n  var r = nbi();\n  x.abs().dlShiftTo(this.m.t, r);\n  r.divRemTo(this.m, null, r);\n  if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);\n  return r;\n} // x/R mod m\n\n\nfunction montRevert(x) {\n  var r = nbi();\n  x.copyTo(r);\n  this.reduce(r);\n  return r;\n} // x = x/R mod m (HAC 14.32)\n\n\nfunction montReduce(x) {\n  while (x.t <= this.mt2) {\n    // pad x so am has enough room later\n    x[x.t++] = 0;\n  }\n\n  for (var i = 0; i < this.m.t; ++i) {\n    // faster way of calculating u0 = x[i]*mp mod DV\n    var j = x[i] & 0x7fff;\n    var u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM; // use am to combine the multiply-shift-add into one call\n\n    j = i + this.m.t;\n    x[j] += this.m.am(0, u0, x, i, 0, this.m.t); // propagate carry\n\n    while (x[j] >= x.DV) {\n      x[j] -= x.DV;\n      x[++j]++;\n    }\n  }\n\n  x.clamp();\n  x.drShiftTo(this.m.t, x);\n  if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);\n} // r = \"x^2/R mod m\"; x != r\n\n\nfunction montSqrTo(x, r) {\n  x.squareTo(r);\n  this.reduce(r);\n} // r = \"xy/R mod m\"; x,y != r\n\n\nfunction montMulTo(x, y, r) {\n  x.multiplyTo(y, r);\n  this.reduce(r);\n}\n\nMontgomery.prototype.convert = montConvert;\nMontgomery.prototype.revert = montRevert;\nMontgomery.prototype.reduce = montReduce;\nMontgomery.prototype.mulTo = montMulTo;\nMontgomery.prototype.sqrTo = montSqrTo; // (protected) true iff this is even\n\nfunction bnpIsEven() {\n  return (this.t > 0 ? this[0] & 1 : this.s) == 0;\n} // (protected) this^e, e < 2^32, doing sqr and mul with \"r\" (HAC 14.79)\n\n\nfunction bnpExp(e, z) {\n  if (e > 0xffffffff || e < 1) return BigInteger.ONE;\n  var r = nbi(),\n      r2 = nbi(),\n      g = z.convert(this),\n      i = nbits(e) - 1;\n  g.copyTo(r);\n\n  while (--i >= 0) {\n    z.sqrTo(r, r2);\n    if ((e & 1 << i) > 0) z.mulTo(r2, g, r);else {\n      var t = r;\n      r = r2;\n      r2 = t;\n    }\n  }\n\n  return z.revert(r);\n} // (public) this^e % m, 0 <= e < 2^32\n\n\nfunction bnModPowInt(e, m) {\n  var z;\n  if (e < 256 || m.isEven()) z = new Classic(m);else z = new Montgomery(m);\n  return this.exp(e, z);\n} // protected\n\n\nBigInteger.prototype.copyTo = bnpCopyTo;\nBigInteger.prototype.fromInt = bnpFromInt;\nBigInteger.prototype.fromString = bnpFromString;\nBigInteger.prototype.clamp = bnpClamp;\nBigInteger.prototype.dlShiftTo = bnpDLShiftTo;\nBigInteger.prototype.drShiftTo = bnpDRShiftTo;\nBigInteger.prototype.lShiftTo = bnpLShiftTo;\nBigInteger.prototype.rShiftTo = bnpRShiftTo;\nBigInteger.prototype.subTo = bnpSubTo;\nBigInteger.prototype.multiplyTo = bnpMultiplyTo;\nBigInteger.prototype.squareTo = bnpSquareTo;\nBigInteger.prototype.divRemTo = bnpDivRemTo;\nBigInteger.prototype.invDigit = bnpInvDigit;\nBigInteger.prototype.isEven = bnpIsEven;\nBigInteger.prototype.exp = bnpExp; // public\n\nBigInteger.prototype.toString = bnToString;\nBigInteger.prototype.negate = bnNegate;\nBigInteger.prototype.abs = bnAbs;\nBigInteger.prototype.compareTo = bnCompareTo;\nBigInteger.prototype.bitLength = bnBitLength;\nBigInteger.prototype.mod = bnMod;\nBigInteger.prototype.modPowInt = bnModPowInt; // \"constants\"\n\nBigInteger.ZERO = nbv(0);\nBigInteger.ONE = nbv(1); // Copyright (c) 2005-2009  Tom Wu\n// All Rights Reserved.\n// See \"LICENSE\" for details.\n// Extended JavaScript BN functions, required for RSA private ops.\n// Version 1.1: new BigInteger(\"0\", 10) returns \"proper\" zero\n// Version 1.2: square() API, isProbablePrime fix\n// (public)\n\nfunction bnClone() {\n  var r = nbi();\n  this.copyTo(r);\n  return r;\n} // (public) return value as integer\n\n\nfunction bnIntValue() {\n  if (this.s < 0) {\n    if (this.t == 1) return this[0] - this.DV;else if (this.t == 0) return -1;\n  } else if (this.t == 1) return this[0];else if (this.t == 0) return 0; // assumes 16 < DB < 32\n\n\n  return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];\n} // (public) return value as byte\n\n\nfunction bnByteValue() {\n  return this.t == 0 ? this.s : this[0] << 24 >> 24;\n} // (public) return value as short (assumes DB>=16)\n\n\nfunction bnShortValue() {\n  return this.t == 0 ? this.s : this[0] << 16 >> 16;\n} // (protected) return x s.t. r^x < DV\n\n\nfunction bnpChunkSize(r) {\n  return Math.floor(Math.LN2 * this.DB / Math.log(r));\n} // (public) 0 if this == 0, 1 if this > 0\n\n\nfunction bnSigNum() {\n  if (this.s < 0) return -1;else if (this.t <= 0 || this.t == 1 && this[0] <= 0) return 0;else return 1;\n} // (protected) convert to radix string\n\n\nfunction bnpToRadix(b) {\n  if (b == null) b = 10;\n  if (this.signum() == 0 || b < 2 || b > 36) return \"0\";\n  var cs = this.chunkSize(b);\n  var a = Math.pow(b, cs);\n  var d = nbv(a),\n      y = nbi(),\n      z = nbi(),\n      r = \"\";\n  this.divRemTo(d, y, z);\n\n  while (y.signum() > 0) {\n    r = (a + z.intValue()).toString(b).substr(1) + r;\n    y.divRemTo(d, y, z);\n  }\n\n  return z.intValue().toString(b) + r;\n} // (protected) convert from radix string\n\n\nfunction bnpFromRadix(s, b) {\n  this.fromInt(0);\n  if (b == null) b = 10;\n  var cs = this.chunkSize(b);\n  var d = Math.pow(b, cs),\n      mi = false,\n      j = 0,\n      w = 0;\n\n  for (var i = 0; i < s.length; ++i) {\n    var x = intAt(s, i);\n\n    if (x < 0) {\n      if (s.charAt(i) == \"-\" && this.signum() == 0) mi = true;\n      continue;\n    }\n\n    w = b * w + x;\n\n    if (++j >= cs) {\n      this.dMultiply(d);\n      this.dAddOffset(w, 0);\n      j = 0;\n      w = 0;\n    }\n  }\n\n  if (j > 0) {\n    this.dMultiply(Math.pow(b, j));\n    this.dAddOffset(w, 0);\n  }\n\n  if (mi) BigInteger.ZERO.subTo(this, this);\n} // (protected) alternate constructor\n\n\nfunction bnpFromNumber(a, b, c) {\n  if (\"number\" == typeof b) {\n    // new BigInteger(int,int,RNG)\n    if (a < 2) this.fromInt(1);else {\n      this.fromNumber(a, c);\n      if (!this.testBit(a - 1)) // force MSB set\n        this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);\n      if (this.isEven()) this.dAddOffset(1, 0); // force odd\n\n      while (!this.isProbablePrime(b)) {\n        this.dAddOffset(2, 0);\n        if (this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);\n      }\n    }\n  } else {\n    // new BigInteger(int,RNG)\n    var x = new Array(),\n        t = a & 7;\n    x.length = (a >> 3) + 1;\n    b.nextBytes(x);\n    if (t > 0) x[0] &= (1 << t) - 1;else x[0] = 0;\n    this.fromString(x, 256);\n  }\n} // (public) convert to bigendian byte array\n\n\nfunction bnToByteArray() {\n  var i = this.t,\n      r = new Array();\n  r[0] = this.s;\n  var p = this.DB - i * this.DB % 8,\n      d,\n      k = 0;\n\n  if (i-- > 0) {\n    if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p) r[k++] = d | this.s << this.DB - p;\n\n    while (i >= 0) {\n      if (p < 8) {\n        d = (this[i] & (1 << p) - 1) << 8 - p;\n        d |= this[--i] >> (p += this.DB - 8);\n      } else {\n        d = this[i] >> (p -= 8) & 0xff;\n\n        if (p <= 0) {\n          p += this.DB;\n          --i;\n        }\n      }\n\n      if ((d & 0x80) != 0) d |= -256;\n      if (k == 0 && (this.s & 0x80) != (d & 0x80)) ++k;\n      if (k > 0 || d != this.s) r[k++] = d;\n    }\n  }\n\n  return r;\n}\n\nfunction bnEquals(a) {\n  return this.compareTo(a) == 0;\n}\n\nfunction bnMin(a) {\n  return this.compareTo(a) < 0 ? this : a;\n}\n\nfunction bnMax(a) {\n  return this.compareTo(a) > 0 ? this : a;\n} // (protected) r = this op a (bitwise)\n\n\nfunction bnpBitwiseTo(a, op, r) {\n  var i,\n      f,\n      m = Math.min(a.t, this.t);\n\n  for (i = 0; i < m; ++i) {\n    r[i] = op(this[i], a[i]);\n  }\n\n  if (a.t < this.t) {\n    f = a.s & this.DM;\n\n    for (i = m; i < this.t; ++i) {\n      r[i] = op(this[i], f);\n    }\n\n    r.t = this.t;\n  } else {\n    f = this.s & this.DM;\n\n    for (i = m; i < a.t; ++i) {\n      r[i] = op(f, a[i]);\n    }\n\n    r.t = a.t;\n  }\n\n  r.s = op(this.s, a.s);\n  r.clamp();\n} // (public) this & a\n\n\nfunction op_and(x, y) {\n  return x & y;\n}\n\nfunction bnAnd(a) {\n  var r = nbi();\n  this.bitwiseTo(a, op_and, r);\n  return r;\n} // (public) this | a\n\n\nfunction op_or(x, y) {\n  return x | y;\n}\n\nfunction bnOr(a) {\n  var r = nbi();\n  this.bitwiseTo(a, op_or, r);\n  return r;\n} // (public) this ^ a\n\n\nfunction op_xor(x, y) {\n  return x ^ y;\n}\n\nfunction bnXor(a) {\n  var r = nbi();\n  this.bitwiseTo(a, op_xor, r);\n  return r;\n} // (public) this & ~a\n\n\nfunction op_andnot(x, y) {\n  return x & ~y;\n}\n\nfunction bnAndNot(a) {\n  var r = nbi();\n  this.bitwiseTo(a, op_andnot, r);\n  return r;\n} // (public) ~this\n\n\nfunction bnNot() {\n  var r = nbi();\n\n  for (var i = 0; i < this.t; ++i) {\n    r[i] = this.DM & ~this[i];\n  }\n\n  r.t = this.t;\n  r.s = ~this.s;\n  return r;\n} // (public) this << n\n\n\nfunction bnShiftLeft(n) {\n  var r = nbi();\n  if (n < 0) this.rShiftTo(-n, r);else this.lShiftTo(n, r);\n  return r;\n} // (public) this >> n\n\n\nfunction bnShiftRight(n) {\n  var r = nbi();\n  if (n < 0) this.lShiftTo(-n, r);else this.rShiftTo(n, r);\n  return r;\n} // return index of lowest 1-bit in x, x < 2^31\n\n\nfunction lbit(x) {\n  if (x == 0) return -1;\n  var r = 0;\n\n  if ((x & 0xffff) == 0) {\n    x >>= 16;\n    r += 16;\n  }\n\n  if ((x & 0xff) == 0) {\n    x >>= 8;\n    r += 8;\n  }\n\n  if ((x & 0xf) == 0) {\n    x >>= 4;\n    r += 4;\n  }\n\n  if ((x & 3) == 0) {\n    x >>= 2;\n    r += 2;\n  }\n\n  if ((x & 1) == 0) ++r;\n  return r;\n} // (public) returns index of lowest 1-bit (or -1 if none)\n\n\nfunction bnGetLowestSetBit() {\n  for (var i = 0; i < this.t; ++i) {\n    if (this[i] != 0) return i * this.DB + lbit(this[i]);\n  }\n\n  if (this.s < 0) return this.t * this.DB;\n  return -1;\n} // return number of 1 bits in x\n\n\nfunction cbit(x) {\n  var r = 0;\n\n  while (x != 0) {\n    x &= x - 1;\n    ++r;\n  }\n\n  return r;\n} // (public) return number of set bits\n\n\nfunction bnBitCount() {\n  var r = 0,\n      x = this.s & this.DM;\n\n  for (var i = 0; i < this.t; ++i) {\n    r += cbit(this[i] ^ x);\n  }\n\n  return r;\n} // (public) true iff nth bit is set\n\n\nfunction bnTestBit(n) {\n  var j = Math.floor(n / this.DB);\n  if (j >= this.t) return this.s != 0;\n  return (this[j] & 1 << n % this.DB) != 0;\n} // (protected) this op (1<<n)\n\n\nfunction bnpChangeBit(n, op) {\n  var r = BigInteger.ONE.shiftLeft(n);\n  this.bitwiseTo(r, op, r);\n  return r;\n} // (public) this | (1<<n)\n\n\nfunction bnSetBit(n) {\n  return this.changeBit(n, op_or);\n} // (public) this & ~(1<<n)\n\n\nfunction bnClearBit(n) {\n  return this.changeBit(n, op_andnot);\n} // (public) this ^ (1<<n)\n\n\nfunction bnFlipBit(n) {\n  return this.changeBit(n, op_xor);\n} // (protected) r = this + a\n\n\nfunction bnpAddTo(a, r) {\n  var i = 0,\n      c = 0,\n      m = Math.min(a.t, this.t);\n\n  while (i < m) {\n    c += this[i] + a[i];\n    r[i++] = c & this.DM;\n    c >>= this.DB;\n  }\n\n  if (a.t < this.t) {\n    c += a.s;\n\n    while (i < this.t) {\n      c += this[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n\n    c += this.s;\n  } else {\n    c += this.s;\n\n    while (i < a.t) {\n      c += a[i];\n      r[i++] = c & this.DM;\n      c >>= this.DB;\n    }\n\n    c += a.s;\n  }\n\n  r.s = c < 0 ? -1 : 0;\n  if (c > 0) r[i++] = c;else if (c < -1) r[i++] = this.DV + c;\n  r.t = i;\n  r.clamp();\n} // (public) this + a\n\n\nfunction bnAdd(a) {\n  var r = nbi();\n  this.addTo(a, r);\n  return r;\n} // (public) this - a\n\n\nfunction bnSubtract(a) {\n  var r = nbi();\n  this.subTo(a, r);\n  return r;\n} // (public) this * a\n\n\nfunction bnMultiply(a) {\n  var r = nbi();\n  this.multiplyTo(a, r);\n  return r;\n} // (public) this^2\n\n\nfunction bnSquare() {\n  var r = nbi();\n  this.squareTo(r);\n  return r;\n} // (public) this / a\n\n\nfunction bnDivide(a) {\n  var r = nbi();\n  this.divRemTo(a, r, null);\n  return r;\n} // (public) this % a\n\n\nfunction bnRemainder(a) {\n  var r = nbi();\n  this.divRemTo(a, null, r);\n  return r;\n} // (public) [this/a,this%a]\n\n\nfunction bnDivideAndRemainder(a) {\n  var q = nbi(),\n      r = nbi();\n  this.divRemTo(a, q, r);\n  return new Array(q, r);\n} // (protected) this *= n, this >= 0, 1 < n < DV\n\n\nfunction bnpDMultiply(n) {\n  this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);\n  ++this.t;\n  this.clamp();\n} // (protected) this += n << w words, this >= 0\n\n\nfunction bnpDAddOffset(n, w) {\n  if (n == 0) return;\n\n  while (this.t <= w) {\n    this[this.t++] = 0;\n  }\n\n  this[w] += n;\n\n  while (this[w] >= this.DV) {\n    this[w] -= this.DV;\n    if (++w >= this.t) this[this.t++] = 0;\n    ++this[w];\n  }\n} // A \"null\" reducer\n\n\nfunction NullExp() {}\n\nfunction nNop(x) {\n  return x;\n}\n\nfunction nMulTo(x, y, r) {\n  x.multiplyTo(y, r);\n}\n\nfunction nSqrTo(x, r) {\n  x.squareTo(r);\n}\n\nNullExp.prototype.convert = nNop;\nNullExp.prototype.revert = nNop;\nNullExp.prototype.mulTo = nMulTo;\nNullExp.prototype.sqrTo = nSqrTo; // (public) this^e\n\nfunction bnPow(e) {\n  return this.exp(e, new NullExp());\n} // (protected) r = lower n words of \"this * a\", a.t <= n\n// \"this\" should be the larger one if appropriate.\n\n\nfunction bnpMultiplyLowerTo(a, n, r) {\n  var i = Math.min(this.t + a.t, n);\n  r.s = 0; // assumes a,this >= 0\n\n  r.t = i;\n\n  while (i > 0) {\n    r[--i] = 0;\n  }\n\n  var j;\n\n  for (j = r.t - this.t; i < j; ++i) {\n    r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);\n  }\n\n  for (j = Math.min(a.t, n); i < j; ++i) {\n    this.am(0, a[i], r, i, 0, n - i);\n  }\n\n  r.clamp();\n} // (protected) r = \"this * a\" without lower n words, n > 0\n// \"this\" should be the larger one if appropriate.\n\n\nfunction bnpMultiplyUpperTo(a, n, r) {\n  --n;\n  var i = r.t = this.t + a.t - n;\n  r.s = 0; // assumes a,this >= 0\n\n  while (--i >= 0) {\n    r[i] = 0;\n  }\n\n  for (i = Math.max(n - this.t, 0); i < a.t; ++i) {\n    r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);\n  }\n\n  r.clamp();\n  r.drShiftTo(1, r);\n} // Barrett modular reduction\n\n\nfunction Barrett(m) {\n  // setup Barrett\n  this.r2 = nbi();\n  this.q3 = nbi();\n  BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);\n  this.mu = this.r2.divide(m);\n  this.m = m;\n}\n\nfunction barrettConvert(x) {\n  if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);else if (x.compareTo(this.m) < 0) return x;else {\n    var r = nbi();\n    x.copyTo(r);\n    this.reduce(r);\n    return r;\n  }\n}\n\nfunction barrettRevert(x) {\n  return x;\n} // x = x mod m (HAC 14.42)\n\n\nfunction barrettReduce(x) {\n  x.drShiftTo(this.m.t - 1, this.r2);\n\n  if (x.t > this.m.t + 1) {\n    x.t = this.m.t + 1;\n    x.clamp();\n  }\n\n  this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);\n  this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);\n\n  while (x.compareTo(this.r2) < 0) {\n    x.dAddOffset(1, this.m.t + 1);\n  }\n\n  x.subTo(this.r2, x);\n\n  while (x.compareTo(this.m) >= 0) {\n    x.subTo(this.m, x);\n  }\n} // r = x^2 mod m; x != r\n\n\nfunction barrettSqrTo(x, r) {\n  x.squareTo(r);\n  this.reduce(r);\n} // r = x*y mod m; x,y != r\n\n\nfunction barrettMulTo(x, y, r) {\n  x.multiplyTo(y, r);\n  this.reduce(r);\n}\n\nBarrett.prototype.convert = barrettConvert;\nBarrett.prototype.revert = barrettRevert;\nBarrett.prototype.reduce = barrettReduce;\nBarrett.prototype.mulTo = barrettMulTo;\nBarrett.prototype.sqrTo = barrettSqrTo; // (public) this^e % m (HAC 14.85)\n\nfunction bnModPow(e, m) {\n  var i = e.bitLength(),\n      k,\n      r = nbv(1),\n      z;\n  if (i <= 0) return r;else if (i < 18) k = 1;else if (i < 48) k = 3;else if (i < 144) k = 4;else if (i < 768) k = 5;else k = 6;\n  if (i < 8) z = new Classic(m);else if (m.isEven()) z = new Barrett(m);else z = new Montgomery(m); // precomputation\n\n  var g = new Array(),\n      n = 3,\n      k1 = k - 1,\n      km = (1 << k) - 1;\n  g[1] = z.convert(this);\n\n  if (k > 1) {\n    var g2 = nbi();\n    z.sqrTo(g[1], g2);\n\n    while (n <= km) {\n      g[n] = nbi();\n      z.mulTo(g2, g[n - 2], g[n]);\n      n += 2;\n    }\n  }\n\n  var j = e.t - 1,\n      w,\n      is1 = true,\n      r2 = nbi(),\n      t;\n  i = nbits(e[j]) - 1;\n\n  while (j >= 0) {\n    if (i >= k1) w = e[j] >> i - k1 & km;else {\n      w = (e[j] & (1 << i + 1) - 1) << k1 - i;\n      if (j > 0) w |= e[j - 1] >> this.DB + i - k1;\n    }\n    n = k;\n\n    while ((w & 1) == 0) {\n      w >>= 1;\n      --n;\n    }\n\n    if ((i -= n) < 0) {\n      i += this.DB;\n      --j;\n    }\n\n    if (is1) {\n      // ret == 1, don't bother squaring or multiplying it\n      g[w].copyTo(r);\n      is1 = false;\n    } else {\n      while (n > 1) {\n        z.sqrTo(r, r2);\n        z.sqrTo(r2, r);\n        n -= 2;\n      }\n\n      if (n > 0) z.sqrTo(r, r2);else {\n        t = r;\n        r = r2;\n        r2 = t;\n      }\n      z.mulTo(r2, g[w], r);\n    }\n\n    while (j >= 0 && (e[j] & 1 << i) == 0) {\n      z.sqrTo(r, r2);\n      t = r;\n      r = r2;\n      r2 = t;\n\n      if (--i < 0) {\n        i = this.DB - 1;\n        --j;\n      }\n    }\n  }\n\n  return z.revert(r);\n} // (public) gcd(this,a) (HAC 14.54)\n\n\nfunction bnGCD(a) {\n  var x = this.s < 0 ? this.negate() : this.clone();\n  var y = a.s < 0 ? a.negate() : a.clone();\n\n  if (x.compareTo(y) < 0) {\n    var t = x;\n    x = y;\n    y = t;\n  }\n\n  var i = x.getLowestSetBit(),\n      g = y.getLowestSetBit();\n  if (g < 0) return x;\n  if (i < g) g = i;\n\n  if (g > 0) {\n    x.rShiftTo(g, x);\n    y.rShiftTo(g, y);\n  }\n\n  while (x.signum() > 0) {\n    if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);\n    if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);\n\n    if (x.compareTo(y) >= 0) {\n      x.subTo(y, x);\n      x.rShiftTo(1, x);\n    } else {\n      y.subTo(x, y);\n      y.rShiftTo(1, y);\n    }\n  }\n\n  if (g > 0) y.lShiftTo(g, y);\n  return y;\n} // (protected) this % n, n < 2^26\n\n\nfunction bnpModInt(n) {\n  if (n <= 0) return 0;\n  var d = this.DV % n,\n      r = this.s < 0 ? n - 1 : 0;\n  if (this.t > 0) if (d == 0) r = this[0] % n;else for (var i = this.t - 1; i >= 0; --i) {\n    r = (d * r + this[i]) % n;\n  }\n  return r;\n} // (public) 1/this % m (HAC 14.61)\n\n\nfunction bnModInverse(m) {\n  var ac = m.isEven();\n  if (this.isEven() && ac || m.signum() == 0) return BigInteger.ZERO;\n  var u = m.clone(),\n      v = this.clone();\n  var a = nbv(1),\n      b = nbv(0),\n      c = nbv(0),\n      d = nbv(1);\n\n  while (u.signum() != 0) {\n    while (u.isEven()) {\n      u.rShiftTo(1, u);\n\n      if (ac) {\n        if (!a.isEven() || !b.isEven()) {\n          a.addTo(this, a);\n          b.subTo(m, b);\n        }\n\n        a.rShiftTo(1, a);\n      } else if (!b.isEven()) b.subTo(m, b);\n\n      b.rShiftTo(1, b);\n    }\n\n    while (v.isEven()) {\n      v.rShiftTo(1, v);\n\n      if (ac) {\n        if (!c.isEven() || !d.isEven()) {\n          c.addTo(this, c);\n          d.subTo(m, d);\n        }\n\n        c.rShiftTo(1, c);\n      } else if (!d.isEven()) d.subTo(m, d);\n\n      d.rShiftTo(1, d);\n    }\n\n    if (u.compareTo(v) >= 0) {\n      u.subTo(v, u);\n      if (ac) a.subTo(c, a);\n      b.subTo(d, b);\n    } else {\n      v.subTo(u, v);\n      if (ac) c.subTo(a, c);\n      d.subTo(b, d);\n    }\n  }\n\n  if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;\n  if (d.compareTo(m) >= 0) return d.subtract(m);\n  if (d.signum() < 0) d.addTo(m, d);else return d;\n  if (d.signum() < 0) return d.add(m);else return d;\n}\n\nvar lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];\nvar lplim = (1 << 26) / lowprimes[lowprimes.length - 1]; // (public) test primality with certainty >= 1-.5^t\n\nfunction bnIsProbablePrime(t) {\n  var i,\n      x = this.abs();\n\n  if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {\n    for (i = 0; i < lowprimes.length; ++i) {\n      if (x[0] == lowprimes[i]) return true;\n    }\n\n    return false;\n  }\n\n  if (x.isEven()) return false;\n  i = 1;\n\n  while (i < lowprimes.length) {\n    var m = lowprimes[i],\n        j = i + 1;\n\n    while (j < lowprimes.length && m < lplim) {\n      m *= lowprimes[j++];\n    }\n\n    m = x.modInt(m);\n\n    while (i < j) {\n      if (m % lowprimes[i++] == 0) return false;\n    }\n  }\n\n  return x.millerRabin(t);\n} // (protected) true if probably prime (HAC 4.24, Miller-Rabin)\n\n\nfunction bnpMillerRabin(t) {\n  var n1 = this.subtract(BigInteger.ONE);\n  var k = n1.getLowestSetBit();\n  if (k <= 0) return false;\n  var r = n1.shiftRight(k);\n  t = t + 1 >> 1;\n  if (t > lowprimes.length) t = lowprimes.length;\n  var a = nbi();\n\n  for (var i = 0; i < t; ++i) {\n    //Pick bases at random, instead of starting at 2\n    a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);\n    var y = a.modPow(r, this);\n\n    if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {\n      var j = 1;\n\n      while (j++ < k && y.compareTo(n1) != 0) {\n        y = y.modPowInt(2, this);\n        if (y.compareTo(BigInteger.ONE) == 0) return false;\n      }\n\n      if (y.compareTo(n1) != 0) return false;\n    }\n  }\n\n  return true;\n} // protected\n\n\nBigInteger.prototype.chunkSize = bnpChunkSize;\nBigInteger.prototype.toRadix = bnpToRadix;\nBigInteger.prototype.fromRadix = bnpFromRadix;\nBigInteger.prototype.fromNumber = bnpFromNumber;\nBigInteger.prototype.bitwiseTo = bnpBitwiseTo;\nBigInteger.prototype.changeBit = bnpChangeBit;\nBigInteger.prototype.addTo = bnpAddTo;\nBigInteger.prototype.dMultiply = bnpDMultiply;\nBigInteger.prototype.dAddOffset = bnpDAddOffset;\nBigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;\nBigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;\nBigInteger.prototype.modInt = bnpModInt;\nBigInteger.prototype.millerRabin = bnpMillerRabin; // public\n\nBigInteger.prototype.clone = bnClone;\nBigInteger.prototype.intValue = bnIntValue;\nBigInteger.prototype.byteValue = bnByteValue;\nBigInteger.prototype.shortValue = bnShortValue;\nBigInteger.prototype.signum = bnSigNum;\nBigInteger.prototype.toByteArray = bnToByteArray;\nBigInteger.prototype.equals = bnEquals;\nBigInteger.prototype.min = bnMin;\nBigInteger.prototype.max = bnMax;\nBigInteger.prototype.and = bnAnd;\nBigInteger.prototype.or = bnOr;\nBigInteger.prototype.xor = bnXor;\nBigInteger.prototype.andNot = bnAndNot;\nBigInteger.prototype.not = bnNot;\nBigInteger.prototype.shiftLeft = bnShiftLeft;\nBigInteger.prototype.shiftRight = bnShiftRight;\nBigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;\nBigInteger.prototype.bitCount = bnBitCount;\nBigInteger.prototype.testBit = bnTestBit;\nBigInteger.prototype.setBit = bnSetBit;\nBigInteger.prototype.clearBit = bnClearBit;\nBigInteger.prototype.flipBit = bnFlipBit;\nBigInteger.prototype.add = bnAdd;\nBigInteger.prototype.subtract = bnSubtract;\nBigInteger.prototype.multiply = bnMultiply;\nBigInteger.prototype.divide = bnDivide;\nBigInteger.prototype.remainder = bnRemainder;\nBigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;\nBigInteger.prototype.modPow = bnModPow;\nBigInteger.prototype.modInverse = bnModInverse;\nBigInteger.prototype.pow = bnPow;\nBigInteger.prototype.gcd = bnGCD;\nBigInteger.prototype.isProbablePrime = bnIsProbablePrime; // JSBN-specific extension\n\nBigInteger.prototype.square = bnSquare;\nvar Int128 = BigInteger; // BigInteger interfaces not implemented in jsbn:\n// BigInteger(int signum, byte[] magnitude)\n// double doubleValue()\n// float floatValue()\n// int hashCode()\n// long longValue()\n// static BigInteger valueOf(long val)\n// Helper functions to make BigInteger functions callable with two parameters\n// as in original C# Clipper\n\nInt128.prototype.IsNegative = function () {\n  if (this.compareTo(Int128.ZERO) == -1) return true;else return false;\n};\n\nInt128.op_Equality = function (val1, val2) {\n  if (val1.compareTo(val2) == 0) return true;else return false;\n};\n\nInt128.op_Inequality = function (val1, val2) {\n  if (val1.compareTo(val2) != 0) return true;else return false;\n};\n\nInt128.op_GreaterThan = function (val1, val2) {\n  if (val1.compareTo(val2) > 0) return true;else return false;\n};\n\nInt128.op_LessThan = function (val1, val2) {\n  if (val1.compareTo(val2) < 0) return true;else return false;\n};\n\nInt128.op_Addition = function (lhs, rhs) {\n  return new Int128(lhs).add(new Int128(rhs));\n};\n\nInt128.op_Subtraction = function (lhs, rhs) {\n  return new Int128(lhs).subtract(new Int128(rhs));\n};\n\nInt128.Int128Mul = function (lhs, rhs) {\n  return new Int128(lhs).multiply(new Int128(rhs));\n};\n\nInt128.op_Division = function (lhs, rhs) {\n  return lhs.divide(rhs);\n};\n\nInt128.prototype.ToDouble = function () {\n  return parseFloat(this.toString()); // This could be something faster\n}; // end of Int128 section\n\n/*\n// Uncomment the following two lines if you want to use Int128 outside ClipperLib\nif (typeof(document) !== \"undefined\") window.Int128 = Int128;\nelse self.Int128 = Int128;\n*/\n// ---------------------------------------------  \n// Here starts the actual Clipper library:\n// Helper function to support Inheritance in Javascript\n\n\nif (typeof Inherit == 'undefined') {\n  var Inherit = function Inherit(ce, ce2) {\n    var p;\n\n    if (typeof Object.getOwnPropertyNames == 'undefined') {\n      for (p in ce2.prototype) {\n        if (typeof ce.prototype[p] == 'undefined' || ce.prototype[p] == Object.prototype[p]) ce.prototype[p] = ce2.prototype[p];\n      }\n\n      for (p in ce2) {\n        if (typeof ce[p] == 'undefined') ce[p] = ce2[p];\n      }\n\n      ce.$baseCtor = ce2;\n    } else {\n      var props = Object.getOwnPropertyNames(ce2.prototype);\n\n      for (var i = 0; i < props.length; i++) {\n        if (typeof Object.getOwnPropertyDescriptor(ce.prototype, props[i]) == 'undefined') Object.defineProperty(ce.prototype, props[i], Object.getOwnPropertyDescriptor(ce2.prototype, props[i]));\n      }\n\n      for (p in ce2) {\n        if (typeof ce[p] == 'undefined') ce[p] = ce2[p];\n      }\n\n      ce.$baseCtor = ce2;\n    }\n  };\n}\n\nClipperLib.Path = function () {\n  return [];\n};\n\nClipperLib.Paths = function () {\n  return []; // Was previously [[]], but caused problems when pushed\n}; // Preserves the calling way of original C# Clipper\n// Is essential due to compatibility, because DoublePoint is public class in original C# version\n\n\nClipperLib.DoublePoint = function () {\n  var a = arguments;\n  this.X = 0;\n  this.Y = 0; // public DoublePoint(DoublePoint dp)\n  // public DoublePoint(IntPoint ip)\n\n  if (a.length == 1) {\n    this.X = a[0].X;\n    this.Y = a[0].Y;\n  } else if (a.length == 2) {\n    this.X = a[0];\n    this.Y = a[1];\n  }\n}; // This is internal faster function when called without arguments\n\n\nClipperLib.DoublePoint0 = function () {\n  this.X = 0;\n  this.Y = 0;\n}; // This is internal faster function when called with 1 argument (dp or ip)\n\n\nClipperLib.DoublePoint1 = function (dp) {\n  this.X = dp.X;\n  this.Y = dp.Y;\n}; // This is internal faster function when called with 2 arguments (x and y)\n\n\nClipperLib.DoublePoint2 = function (x, y) {\n  this.X = x;\n  this.Y = y;\n}; // PolyTree & PolyNode start\n// -------------------------------\n\n\nClipperLib.PolyNode = function () {\n  this.m_Parent = null;\n  this.m_polygon = new ClipperLib.Path();\n  this.m_Index = 0;\n  this.m_jointype = 0;\n  this.m_endtype = 0;\n  this.m_Childs = [];\n  this.IsOpen = false;\n};\n\nClipperLib.PolyNode.prototype.IsHoleNode = function () {\n  var result = true;\n  var node = this.m_Parent;\n\n  while (node !== null) {\n    result = !result;\n    node = node.m_Parent;\n  }\n\n  return result;\n};\n\nClipperLib.PolyNode.prototype.ChildCount = function () {\n  return this.m_Childs.length;\n};\n\nClipperLib.PolyNode.prototype.Contour = function () {\n  return this.m_polygon;\n};\n\nClipperLib.PolyNode.prototype.AddChild = function (Child) {\n  var cnt = this.m_Childs.length;\n  this.m_Childs.push(Child);\n  Child.m_Parent = this;\n  Child.m_Index = cnt;\n};\n\nClipperLib.PolyNode.prototype.GetNext = function () {\n  if (this.m_Childs.length > 0) return this.m_Childs[0];else return this.GetNextSiblingUp();\n};\n\nClipperLib.PolyNode.prototype.GetNextSiblingUp = function () {\n  if (this.m_Parent === null) return null;else if (this.m_Index == this.m_Parent.m_Childs.length - 1) return this.m_Parent.GetNextSiblingUp();else return this.m_Parent.m_Childs[this.m_Index + 1];\n};\n\nClipperLib.PolyNode.prototype.Childs = function () {\n  return this.m_Childs;\n};\n\nClipperLib.PolyNode.prototype.Parent = function () {\n  return this.m_Parent;\n};\n\nClipperLib.PolyNode.prototype.IsHole = function () {\n  return this.IsHoleNode();\n}; // PolyTree : PolyNode\n\n\nClipperLib.PolyTree = function () {\n  this.m_AllPolys = [];\n  ClipperLib.PolyNode.call(this);\n};\n\nClipperLib.PolyTree.prototype.Clear = function () {\n  for (var i = 0, ilen = this.m_AllPolys.length; i < ilen; i++) {\n    this.m_AllPolys[i] = null;\n  }\n\n  this.m_AllPolys.length = 0;\n  this.m_Childs.length = 0;\n};\n\nClipperLib.PolyTree.prototype.GetFirst = function () {\n  if (this.m_Childs.length > 0) return this.m_Childs[0];else return null;\n};\n\nClipperLib.PolyTree.prototype.Total = function () {\n  return this.m_AllPolys.length;\n};\n\nInherit(ClipperLib.PolyTree, ClipperLib.PolyNode); // -------------------------------\n// PolyTree & PolyNode end\n\nClipperLib.Math_Abs_Int64 = ClipperLib.Math_Abs_Int32 = ClipperLib.Math_Abs_Double = function (a) {\n  return Math.abs(a);\n};\n\nClipperLib.Math_Max_Int32_Int32 = function (a, b) {\n  return Math.max(a, b);\n};\n/*\n-----------------------------------\ncast_32 speedtest: http://jsperf.com/truncate-float-to-integer/2\n-----------------------------------\n*/\n\n\nif (browser.msie || browser.opera || browser.safari) ClipperLib.Cast_Int32 = function (a) {\n  return a | 0;\n};else ClipperLib.Cast_Int32 = function (a) {\n  // eg. browser.chrome || browser.chromium || browser.firefox\n  return ~~a;\n};\n/*\n--------------------------\ncast_64 speedtests: http://jsperf.com/truncate-float-to-integer\nChrome: bitwise_not_floor\nFirefox17: toInteger (typeof test)\nIE9: bitwise_or_floor\nIE7 and IE8: to_parseint\nChromium: to_floor_or_ceil\nFirefox3: to_floor_or_ceil\nFirefox15: to_floor_or_ceil\nOpera: to_floor_or_ceil\nSafari: to_floor_or_ceil\n--------------------------\n*/\n\nif (browser.chrome) ClipperLib.Cast_Int64 = function (a) {\n  if (a < -2147483648 || a > 2147483647) return a < 0 ? Math.ceil(a) : Math.floor(a);else return ~~a;\n};else if (browser.firefox && typeof Number.toInteger == \"function\") ClipperLib.Cast_Int64 = function (a) {\n  return Number.toInteger(a);\n};else if (browser.msie7 || browser.msie8) ClipperLib.Cast_Int64 = function (a) {\n  return parseInt(a, 10);\n};else if (browser.msie) ClipperLib.Cast_Int64 = function (a) {\n  if (a < -2147483648 || a > 2147483647) return a < 0 ? Math.ceil(a) : Math.floor(a);\n  return a | 0;\n}; // eg. browser.chromium || browser.firefox || browser.opera || browser.safari\nelse ClipperLib.Cast_Int64 = function (a) {\n    return a < 0 ? Math.ceil(a) : Math.floor(a);\n  };\n\nClipperLib.Clear = function (a) {\n  a.length = 0;\n}; //ClipperLib.MaxSteps = 64; // How many steps at maximum in arc in BuildArc() function\n\n\nClipperLib.PI = 3.141592653589793;\nClipperLib.PI2 = 2 * 3.141592653589793;\n\nClipperLib.IntPoint = function () {\n  var a = arguments,\n      alen = a.length;\n  this.X = 0;\n  this.Y = 0;\n\n  if (use_xyz) {\n    this.Z = 0;\n\n    if (alen == 3) // public IntPoint(cInt x, cInt y, cInt z = 0)\n      {\n        this.X = a[0];\n        this.Y = a[1];\n        this.Z = a[2];\n      } else if (alen == 2) // public IntPoint(cInt x, cInt y)\n      {\n        this.X = a[0];\n        this.Y = a[1];\n        this.Z = 0;\n      } else if (alen == 1) {\n      if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n        {\n          var dp = a[0];\n          this.X = ClipperLib.Clipper.Round(dp.X);\n          this.Y = ClipperLib.Clipper.Round(dp.Y);\n          this.Z = 0;\n        } else // public IntPoint(IntPoint pt)\n        {\n          var pt = a[0];\n          if (typeof pt.Z == \"undefined\") pt.Z = 0;\n          this.X = pt.X;\n          this.Y = pt.Y;\n          this.Z = pt.Z;\n        }\n    } else // public IntPoint()\n      {\n        this.X = 0;\n        this.Y = 0;\n        this.Z = 0;\n      }\n  } else // if (!use_xyz)\n    {\n      if (alen == 2) // public IntPoint(cInt X, cInt Y)\n        {\n          this.X = a[0];\n          this.Y = a[1];\n        } else if (alen == 1) {\n        if (a[0] instanceof ClipperLib.DoublePoint) // public IntPoint(DoublePoint dp)\n          {\n            var dp = a[0];\n            this.X = ClipperLib.Clipper.Round(dp.X);\n            this.Y = ClipperLib.Clipper.Round(dp.Y);\n          } else // public IntPoint(IntPoint pt)\n          {\n            var pt = a[0];\n            this.X = pt.X;\n            this.Y = pt.Y;\n          }\n      } else // public IntPoint(IntPoint pt)\n        {\n          this.X = 0;\n          this.Y = 0;\n        }\n    }\n};\n\nClipperLib.IntPoint.op_Equality = function (a, b) {\n  //return a == b;\n  return a.X == b.X && a.Y == b.Y;\n};\n\nClipperLib.IntPoint.op_Inequality = function (a, b) {\n  //return a != b;\n  return a.X != b.X || a.Y != b.Y;\n};\n/*\nClipperLib.IntPoint.prototype.Equals = function (obj)\n{\n  if (obj === null)\n      return false;\n  if (obj instanceof ClipperLib.IntPoint)\n  {\n      var a = Cast(obj, ClipperLib.IntPoint);\n      return (this.X == a.X) && (this.Y == a.Y);\n  }\n  else\n      return false;\n};\n*/\n\n\nif (use_xyz) {\n  ClipperLib.IntPoint0 = function () {\n    this.X = 0;\n    this.Y = 0;\n    this.Z = 0;\n  };\n\n  ClipperLib.IntPoint1 = function (pt) {\n    this.X = pt.X;\n    this.Y = pt.Y;\n    this.Z = pt.Z;\n  };\n\n  ClipperLib.IntPoint1dp = function (dp) {\n    this.X = ClipperLib.Clipper.Round(dp.X);\n    this.Y = ClipperLib.Clipper.Round(dp.Y);\n    this.Z = 0;\n  };\n\n  ClipperLib.IntPoint2 = function (x, y) {\n    this.X = x;\n    this.Y = y;\n    this.Z = 0;\n  };\n\n  ClipperLib.IntPoint3 = function (x, y, z) {\n    this.X = x;\n    this.Y = y;\n    this.Z = z;\n  };\n} else // if (!use_xyz)\n  {\n    ClipperLib.IntPoint0 = function () {\n      this.X = 0;\n      this.Y = 0;\n    };\n\n    ClipperLib.IntPoint1 = function (pt) {\n      this.X = pt.X;\n      this.Y = pt.Y;\n    };\n\n    ClipperLib.IntPoint1dp = function (dp) {\n      this.X = ClipperLib.Clipper.Round(dp.X);\n      this.Y = ClipperLib.Clipper.Round(dp.Y);\n    };\n\n    ClipperLib.IntPoint2 = function (x, y) {\n      this.X = x;\n      this.Y = y;\n    };\n  }\n\nClipperLib.IntRect = function () {\n  var a = arguments,\n      alen = a.length;\n\n  if (alen == 4) // function (l, t, r, b)\n    {\n      this.left = a[0];\n      this.top = a[1];\n      this.right = a[2];\n      this.bottom = a[3];\n    } else if (alen == 1) // function (ir)\n    {\n      this.left = ir.left;\n      this.top = ir.top;\n      this.right = ir.right;\n      this.bottom = ir.bottom;\n    } else // function ()\n    {\n      this.left = 0;\n      this.top = 0;\n      this.right = 0;\n      this.bottom = 0;\n    }\n};\n\nClipperLib.IntRect0 = function () {\n  this.left = 0;\n  this.top = 0;\n  this.right = 0;\n  this.bottom = 0;\n};\n\nClipperLib.IntRect1 = function (ir) {\n  this.left = ir.left;\n  this.top = ir.top;\n  this.right = ir.right;\n  this.bottom = ir.bottom;\n};\n\nClipperLib.IntRect4 = function (l, t, r, b) {\n  this.left = l;\n  this.top = t;\n  this.right = r;\n  this.bottom = b;\n};\n\nClipperLib.ClipType = {\n  ctIntersection: 0,\n  ctUnion: 1,\n  ctDifference: 2,\n  ctXor: 3\n};\nClipperLib.PolyType = {\n  ptSubject: 0,\n  ptClip: 1\n};\nClipperLib.PolyFillType = {\n  pftEvenOdd: 0,\n  pftNonZero: 1,\n  pftPositive: 2,\n  pftNegative: 3\n};\nClipperLib.JoinType = {\n  jtSquare: 0,\n  jtRound: 1,\n  jtMiter: 2\n};\nClipperLib.EndType = {\n  etOpenSquare: 0,\n  etOpenRound: 1,\n  etOpenButt: 2,\n  etClosedLine: 3,\n  etClosedPolygon: 4\n};\nif (use_deprecated) ClipperLib.EndType_ = {\n  etSquare: 0,\n  etRound: 1,\n  etButt: 2,\n  etClosed: 3\n};\nClipperLib.EdgeSide = {\n  esLeft: 0,\n  esRight: 1\n};\nClipperLib.Direction = {\n  dRightToLeft: 0,\n  dLeftToRight: 1\n};\n\nClipperLib.TEdge = function () {\n  this.Bot = new ClipperLib.IntPoint();\n  this.Curr = new ClipperLib.IntPoint();\n  this.Top = new ClipperLib.IntPoint();\n  this.Delta = new ClipperLib.IntPoint();\n  this.Dx = 0;\n  this.PolyTyp = ClipperLib.PolyType.ptSubject;\n  this.Side = ClipperLib.EdgeSide.esLeft;\n  this.WindDelta = 0;\n  this.WindCnt = 0;\n  this.WindCnt2 = 0;\n  this.OutIdx = 0;\n  this.Next = null;\n  this.Prev = null;\n  this.NextInLML = null;\n  this.NextInAEL = null;\n  this.PrevInAEL = null;\n  this.NextInSEL = null;\n  this.PrevInSEL = null;\n};\n\nClipperLib.IntersectNode = function () {\n  this.Edge1 = null;\n  this.Edge2 = null;\n  this.Pt = new ClipperLib.IntPoint();\n};\n\nClipperLib.MyIntersectNodeSort = function () {};\n\nClipperLib.MyIntersectNodeSort.Compare = function (node1, node2) {\n  return node2.Pt.Y - node1.Pt.Y;\n};\n\nClipperLib.LocalMinima = function () {\n  this.Y = 0;\n  this.LeftBound = null;\n  this.RightBound = null;\n  this.Next = null;\n};\n\nClipperLib.Scanbeam = function () {\n  this.Y = 0;\n  this.Next = null;\n};\n\nClipperLib.OutRec = function () {\n  this.Idx = 0;\n  this.IsHole = false;\n  this.IsOpen = false;\n  this.FirstLeft = null;\n  this.Pts = null;\n  this.BottomPt = null;\n  this.PolyNode = null;\n};\n\nClipperLib.OutPt = function () {\n  this.Idx = 0;\n  this.Pt = new ClipperLib.IntPoint();\n  this.Next = null;\n  this.Prev = null;\n};\n\nClipperLib.Join = function () {\n  this.OutPt1 = null;\n  this.OutPt2 = null;\n  this.OffPt = new ClipperLib.IntPoint();\n};\n\nClipperLib.ClipperBase = function () {\n  this.m_MinimaList = null;\n  this.m_CurrentLM = null;\n  this.m_edges = new Array();\n  this.m_UseFullRange = false;\n  this.m_HasOpenPaths = false;\n  this.PreserveCollinear = false;\n  this.m_MinimaList = null;\n  this.m_CurrentLM = null;\n  this.m_UseFullRange = false;\n  this.m_HasOpenPaths = false;\n}; // Ranges are in original C# too high for Javascript (in current state 2013 september):\n// protected const double horizontal = -3.4E+38;\n// internal const cInt loRange = 0x3FFFFFFF; // = 1073741823 = sqrt(2^63 -1)/2\n// internal const cInt hiRange = 0x3FFFFFFFFFFFFFFFL; // = 4611686018427387903 = sqrt(2^127 -1)/2\n// So had to adjust them to more suitable for Javascript.\n// If JS some day supports truly 64-bit integers, then these ranges can be as in C#\n// and biginteger library can be more simpler (as then 128bit can be represented as two 64bit numbers)\n\n\nClipperLib.ClipperBase.horizontal = -9007199254740992; //-2^53\n\nClipperLib.ClipperBase.Skip = -2;\nClipperLib.ClipperBase.Unassigned = -1;\nClipperLib.ClipperBase.tolerance = 1E-20;\n\nif (use_int32) {\n  ClipperLib.ClipperBase.loRange = 46340;\n  ClipperLib.ClipperBase.hiRange = 46340;\n} else {\n  ClipperLib.ClipperBase.loRange = 47453132; // sqrt(2^53 -1)/2\n\n  ClipperLib.ClipperBase.hiRange = 4503599627370495; // sqrt(2^106 -1)/2\n}\n\nClipperLib.ClipperBase.near_zero = function (val) {\n  return val > -ClipperLib.ClipperBase.tolerance && val < ClipperLib.ClipperBase.tolerance;\n};\n\nClipperLib.ClipperBase.IsHorizontal = function (e) {\n  return e.Delta.Y === 0;\n};\n\nClipperLib.ClipperBase.prototype.PointIsVertex = function (pt, pp) {\n  var pp2 = pp;\n\n  do {\n    if (ClipperLib.IntPoint.op_Equality(pp2.Pt, pt)) return true;\n    pp2 = pp2.Next;\n  } while (pp2 != pp);\n\n  return false;\n};\n\nClipperLib.ClipperBase.prototype.PointOnLineSegment = function (pt, linePt1, linePt2, UseFullRange) {\n  if (UseFullRange) return pt.X == linePt1.X && pt.Y == linePt1.Y || pt.X == linePt2.X && pt.Y == linePt2.Y || pt.X > linePt1.X == pt.X < linePt2.X && pt.Y > linePt1.Y == pt.Y < linePt2.Y && Int128.op_Equality(Int128.Int128Mul(pt.X - linePt1.X, linePt2.Y - linePt1.Y), Int128.Int128Mul(linePt2.X - linePt1.X, pt.Y - linePt1.Y));else return pt.X == linePt1.X && pt.Y == linePt1.Y || pt.X == linePt2.X && pt.Y == linePt2.Y || pt.X > linePt1.X == pt.X < linePt2.X && pt.Y > linePt1.Y == pt.Y < linePt2.Y && (pt.X - linePt1.X) * (linePt2.Y - linePt1.Y) == (linePt2.X - linePt1.X) * (pt.Y - linePt1.Y);\n};\n\nClipperLib.ClipperBase.prototype.PointOnPolygon = function (pt, pp, UseFullRange) {\n  var pp2 = pp;\n\n  while (true) {\n    if (this.PointOnLineSegment(pt, pp2.Pt, pp2.Next.Pt, UseFullRange)) return true;\n    pp2 = pp2.Next;\n    if (pp2 == pp) break;\n  }\n\n  return false;\n};\n\nClipperLib.ClipperBase.prototype.SlopesEqual = ClipperLib.ClipperBase.SlopesEqual = function () {\n  var a = arguments,\n      alen = a.length;\n  var e1, e2, pt1, pt2, pt3, pt4, UseFullRange;\n\n  if (alen == 3) // function (e1, e2, UseFullRange)\n    {\n      e1 = a[0];\n      e2 = a[1];\n      UseFullRange = a[2];\n      if (UseFullRange) return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));else return ClipperLib.Cast_Int64(e1.Delta.Y * e2.Delta.X) == ClipperLib.Cast_Int64(e1.Delta.X * e2.Delta.Y);\n    } else if (alen == 4) // function (pt1, pt2, pt3, UseFullRange)\n    {\n      pt1 = a[0];\n      pt2 = a[1];\n      pt3 = a[2];\n      UseFullRange = a[3];\n      if (UseFullRange) return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));else return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n    } else // function (pt1, pt2, pt3, pt4, UseFullRange)\n    {\n      pt1 = a[0];\n      pt2 = a[1];\n      pt3 = a[2];\n      pt4 = a[3];\n      UseFullRange = a[4];\n      if (UseFullRange) return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));else return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n    }\n};\n\nClipperLib.ClipperBase.SlopesEqual3 = function (e1, e2, UseFullRange) {\n  if (UseFullRange) return Int128.op_Equality(Int128.Int128Mul(e1.Delta.Y, e2.Delta.X), Int128.Int128Mul(e1.Delta.X, e2.Delta.Y));else return ClipperLib.Cast_Int64(e1.Delta.Y * e2.Delta.X) == ClipperLib.Cast_Int64(e1.Delta.X * e2.Delta.Y);\n};\n\nClipperLib.ClipperBase.SlopesEqual4 = function (pt1, pt2, pt3, UseFullRange) {\n  if (UseFullRange) return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt2.X - pt3.X), Int128.Int128Mul(pt1.X - pt2.X, pt2.Y - pt3.Y));else return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt2.X - pt3.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt2.Y - pt3.Y)) === 0;\n};\n\nClipperLib.ClipperBase.SlopesEqual5 = function (pt1, pt2, pt3, pt4, UseFullRange) {\n  if (UseFullRange) return Int128.op_Equality(Int128.Int128Mul(pt1.Y - pt2.Y, pt3.X - pt4.X), Int128.Int128Mul(pt1.X - pt2.X, pt3.Y - pt4.Y));else return ClipperLib.Cast_Int64((pt1.Y - pt2.Y) * (pt3.X - pt4.X)) - ClipperLib.Cast_Int64((pt1.X - pt2.X) * (pt3.Y - pt4.Y)) === 0;\n};\n\nClipperLib.ClipperBase.prototype.Clear = function () {\n  this.DisposeLocalMinimaList();\n\n  for (var i = 0, ilen = this.m_edges.length; i < ilen; ++i) {\n    for (var j = 0, jlen = this.m_edges[i].length; j < jlen; ++j) {\n      this.m_edges[i][j] = null;\n    }\n\n    ClipperLib.Clear(this.m_edges[i]);\n  }\n\n  ClipperLib.Clear(this.m_edges);\n  this.m_UseFullRange = false;\n  this.m_HasOpenPaths = false;\n};\n\nClipperLib.ClipperBase.prototype.DisposeLocalMinimaList = function () {\n  while (this.m_MinimaList !== null) {\n    var tmpLm = this.m_MinimaList.Next;\n    this.m_MinimaList = null;\n    this.m_MinimaList = tmpLm;\n  }\n\n  this.m_CurrentLM = null;\n};\n\nClipperLib.ClipperBase.prototype.RangeTest = function (Pt, useFullRange) {\n  if (useFullRange.Value) {\n    if (Pt.X > ClipperLib.ClipperBase.hiRange || Pt.Y > ClipperLib.ClipperBase.hiRange || -Pt.X > ClipperLib.ClipperBase.hiRange || -Pt.Y > ClipperLib.ClipperBase.hiRange) ClipperLib.Error(\"Coordinate outside allowed range in RangeTest().\");\n  } else if (Pt.X > ClipperLib.ClipperBase.loRange || Pt.Y > ClipperLib.ClipperBase.loRange || -Pt.X > ClipperLib.ClipperBase.loRange || -Pt.Y > ClipperLib.ClipperBase.loRange) {\n    useFullRange.Value = true;\n    this.RangeTest(Pt, useFullRange);\n  }\n};\n\nClipperLib.ClipperBase.prototype.InitEdge = function (e, eNext, ePrev, pt) {\n  e.Next = eNext;\n  e.Prev = ePrev; //e.Curr = pt;\n\n  e.Curr.X = pt.X;\n  e.Curr.Y = pt.Y;\n  e.OutIdx = -1;\n};\n\nClipperLib.ClipperBase.prototype.InitEdge2 = function (e, polyType) {\n  if (e.Curr.Y >= e.Next.Curr.Y) {\n    //e.Bot = e.Curr;\n    e.Bot.X = e.Curr.X;\n    e.Bot.Y = e.Curr.Y; //e.Top = e.Next.Curr;\n\n    e.Top.X = e.Next.Curr.X;\n    e.Top.Y = e.Next.Curr.Y;\n  } else {\n    //e.Top = e.Curr;\n    e.Top.X = e.Curr.X;\n    e.Top.Y = e.Curr.Y; //e.Bot = e.Next.Curr;\n\n    e.Bot.X = e.Next.Curr.X;\n    e.Bot.Y = e.Next.Curr.Y;\n  }\n\n  this.SetDx(e);\n  e.PolyTyp = polyType;\n};\n\nClipperLib.ClipperBase.prototype.FindNextLocMin = function (E) {\n  var E2;\n\n  for (;;) {\n    while (ClipperLib.IntPoint.op_Inequality(E.Bot, E.Prev.Bot) || ClipperLib.IntPoint.op_Equality(E.Curr, E.Top)) {\n      E = E.Next;\n    }\n\n    if (E.Dx != ClipperLib.ClipperBase.horizontal && E.Prev.Dx != ClipperLib.ClipperBase.horizontal) break;\n\n    while (E.Prev.Dx == ClipperLib.ClipperBase.horizontal) {\n      E = E.Prev;\n    }\n\n    E2 = E;\n\n    while (E.Dx == ClipperLib.ClipperBase.horizontal) {\n      E = E.Next;\n    }\n\n    if (E.Top.Y == E.Prev.Bot.Y) continue; //ie just an intermediate horz.\n\n    if (E2.Prev.Bot.X < E.Bot.X) E = E2;\n    break;\n  }\n\n  return E;\n};\n\nClipperLib.ClipperBase.prototype.ProcessBound = function (E, IsClockwise) {\n  var EStart = E,\n      Result = E;\n  var Horz;\n  var StartX;\n\n  if (E.Dx == ClipperLib.ClipperBase.horizontal) {\n    //it's possible for adjacent overlapping horz edges to start heading left\n    //before finishing right, so ...\n    if (IsClockwise) StartX = E.Prev.Bot.X;else StartX = E.Next.Bot.X;\n    if (E.Bot.X != StartX) this.ReverseHorizontal(E);\n  }\n\n  if (Result.OutIdx != ClipperLib.ClipperBase.Skip) {\n    if (IsClockwise) {\n      while (Result.Top.Y == Result.Next.Bot.Y && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip) {\n        Result = Result.Next;\n      }\n\n      if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Next.OutIdx != ClipperLib.ClipperBase.Skip) {\n        //nb: at the top of a bound, horizontals are added to the bound\n        //only when the preceding edge attaches to the horizontal's left vertex\n        //unless a Skip edge is encountered when that becomes the top divide\n        Horz = Result;\n\n        while (Horz.Prev.Dx == ClipperLib.ClipperBase.horizontal) {\n          Horz = Horz.Prev;\n        }\n\n        if (Horz.Prev.Top.X == Result.Next.Top.X) {\n          if (!IsClockwise) Result = Horz.Prev;\n        } else if (Horz.Prev.Top.X > Result.Next.Top.X) Result = Horz.Prev;\n      }\n\n      while (E != Result) {\n        E.NextInLML = E.Next;\n        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X) this.ReverseHorizontal(E);\n        E = E.Next;\n      }\n\n      if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Prev.Top.X) this.ReverseHorizontal(E);\n      Result = Result.Next; //move to the edge just beyond current bound\n    } else {\n      while (Result.Top.Y == Result.Prev.Bot.Y && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip) {\n        Result = Result.Prev;\n      }\n\n      if (Result.Dx == ClipperLib.ClipperBase.horizontal && Result.Prev.OutIdx != ClipperLib.ClipperBase.Skip) {\n        Horz = Result;\n\n        while (Horz.Next.Dx == ClipperLib.ClipperBase.horizontal) {\n          Horz = Horz.Next;\n        }\n\n        if (Horz.Next.Top.X == Result.Prev.Top.X) {\n          if (!IsClockwise) Result = Horz.Next;\n        } else if (Horz.Next.Top.X > Result.Prev.Top.X) Result = Horz.Next;\n      }\n\n      while (E != Result) {\n        E.NextInLML = E.Prev;\n        if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X) this.ReverseHorizontal(E);\n        E = E.Prev;\n      }\n\n      if (E.Dx == ClipperLib.ClipperBase.horizontal && E != EStart && E.Bot.X != E.Next.Top.X) this.ReverseHorizontal(E);\n      Result = Result.Prev; //move to the edge just beyond current bound\n    }\n  }\n\n  if (Result.OutIdx == ClipperLib.ClipperBase.Skip) {\n    //if edges still remain in the current bound beyond the skip edge then\n    //create another LocMin and call ProcessBound once more\n    E = Result;\n\n    if (IsClockwise) {\n      while (E.Top.Y == E.Next.Bot.Y) {\n        E = E.Next;\n      } //don't include top horizontals when parsing a bound a second time,\n      //they will be contained in the opposite bound ...\n\n\n      while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) {\n        E = E.Prev;\n      }\n    } else {\n      while (E.Top.Y == E.Prev.Bot.Y) {\n        E = E.Prev;\n      }\n\n      while (E != Result && E.Dx == ClipperLib.ClipperBase.horizontal) {\n        E = E.Next;\n      }\n    }\n\n    if (E == Result) {\n      if (IsClockwise) Result = E.Next;else Result = E.Prev;\n    } else {\n      //there are more edges in the bound beyond result starting with E\n      if (IsClockwise) E = Result.Next;else E = Result.Prev;\n      var locMin = new ClipperLib.LocalMinima();\n      locMin.Next = null;\n      locMin.Y = E.Bot.Y;\n      locMin.LeftBound = null;\n      locMin.RightBound = E;\n      locMin.RightBound.WindDelta = 0;\n      Result = this.ProcessBound(locMin.RightBound, IsClockwise);\n      this.InsertLocalMinima(locMin);\n    }\n  }\n\n  return Result;\n};\n\nClipperLib.ClipperBase.prototype.AddPath = function (pg, polyType, Closed) {\n  if (use_lines) {\n    if (!Closed && polyType == ClipperLib.PolyType.ptClip) ClipperLib.Error(\"AddPath: Open paths must be subject.\");\n  } else {\n    if (!Closed) ClipperLib.Error(\"AddPath: Open paths have been disabled.\");\n  }\n\n  var highI = pg.length - 1;\n  if (Closed) while (highI > 0 && ClipperLib.IntPoint.op_Equality(pg[highI], pg[0])) {\n    --highI;\n  }\n\n  while (highI > 0 && ClipperLib.IntPoint.op_Equality(pg[highI], pg[highI - 1])) {\n    --highI;\n  }\n\n  if (Closed && highI < 2 || !Closed && highI < 1) return false; //create a new edge array ...\n\n  var edges = new Array();\n\n  for (var i = 0; i <= highI; i++) {\n    edges.push(new ClipperLib.TEdge());\n  }\n\n  var IsFlat = true; //1. Basic (first) edge initialization ...\n  //edges[1].Curr = pg[1];\n\n  edges[1].Curr.X = pg[1].X;\n  edges[1].Curr.Y = pg[1].Y;\n  var $1 = {\n    Value: this.m_UseFullRange\n  };\n  this.RangeTest(pg[0], $1);\n  this.m_UseFullRange = $1.Value;\n  $1.Value = this.m_UseFullRange;\n  this.RangeTest(pg[highI], $1);\n  this.m_UseFullRange = $1.Value;\n  this.InitEdge(edges[0], edges[1], edges[highI], pg[0]);\n  this.InitEdge(edges[highI], edges[0], edges[highI - 1], pg[highI]);\n\n  for (var i = highI - 1; i >= 1; --i) {\n    $1.Value = this.m_UseFullRange;\n    this.RangeTest(pg[i], $1);\n    this.m_UseFullRange = $1.Value;\n    this.InitEdge(edges[i], edges[i + 1], edges[i - 1], pg[i]);\n  }\n\n  var eStart = edges[0]; //2. Remove duplicate vertices, and (when closed) collinear edges ...\n\n  var E = eStart,\n      eLoopStop = eStart;\n\n  for (;;) {\n    if (ClipperLib.IntPoint.op_Equality(E.Curr, E.Next.Curr)) {\n      if (E == E.Next) break;\n      if (E == eStart) eStart = E.Next;\n      E = this.RemoveEdge(E);\n      eLoopStop = E;\n      continue;\n    }\n\n    if (E.Prev == E.Next) break;else if (Closed && ClipperLib.ClipperBase.SlopesEqual(E.Prev.Curr, E.Curr, E.Next.Curr, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(E.Prev.Curr, E.Curr, E.Next.Curr))) {\n      //Collinear edges are allowed for open paths but in closed paths\n      //the default is to merge adjacent collinear edges into a single edge.\n      //However, if the PreserveCollinear property is enabled, only overlapping\n      //collinear edges (ie spikes) will be removed from closed paths.\n      if (E == eStart) eStart = E.Next;\n      E = this.RemoveEdge(E);\n      E = E.Prev;\n      eLoopStop = E;\n      continue;\n    }\n    E = E.Next;\n    if (E == eLoopStop) break;\n  }\n\n  if (!Closed && E == E.Next || Closed && E.Prev == E.Next) return false;\n\n  if (!Closed) {\n    this.m_HasOpenPaths = true;\n    eStart.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n  } //3. Do second stage of edge initialization ...\n\n\n  var eHighest = eStart;\n  E = eStart;\n\n  do {\n    this.InitEdge2(E, polyType);\n    E = E.Next;\n    if (IsFlat && E.Curr.Y != eStart.Curr.Y) IsFlat = false;\n  } while (E != eStart); //4. Finally, add edge bounds to LocalMinima list ...\n  //Totally flat paths must be handled differently when adding them\n  //to LocalMinima list to avoid endless loops etc ...\n\n\n  if (IsFlat) {\n    if (Closed) return false;\n    E.Prev.OutIdx = ClipperLib.ClipperBase.Skip;\n    if (E.Prev.Bot.X < E.Prev.Top.X) this.ReverseHorizontal(E.Prev);\n    var locMin = new ClipperLib.LocalMinima();\n    locMin.Next = null;\n    locMin.Y = E.Bot.Y;\n    locMin.LeftBound = null;\n    locMin.RightBound = E;\n    locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n    locMin.RightBound.WindDelta = 0;\n\n    while (E.Next.OutIdx != ClipperLib.ClipperBase.Skip) {\n      E.NextInLML = E.Next;\n      if (E.Bot.X != E.Prev.Top.X) this.ReverseHorizontal(E);\n      E = E.Next;\n    }\n\n    this.InsertLocalMinima(locMin);\n    this.m_edges.push(edges);\n    return true;\n  }\n\n  this.m_edges.push(edges);\n  var clockwise;\n  var EMin = null;\n\n  for (;;) {\n    E = this.FindNextLocMin(E);\n    if (E == EMin) break;else if (EMin == null) EMin = E; //E and E.Prev now share a local minima (left aligned if horizontal).\n    //Compare their slopes to find which starts which bound ...\n\n    var locMin = new ClipperLib.LocalMinima();\n    locMin.Next = null;\n    locMin.Y = E.Bot.Y;\n\n    if (E.Dx < E.Prev.Dx) {\n      locMin.LeftBound = E.Prev;\n      locMin.RightBound = E;\n      clockwise = false; //Q.nextInLML = Q.prev\n    } else {\n      locMin.LeftBound = E;\n      locMin.RightBound = E.Prev;\n      clockwise = true; //Q.nextInLML = Q.next\n    }\n\n    locMin.LeftBound.Side = ClipperLib.EdgeSide.esLeft;\n    locMin.RightBound.Side = ClipperLib.EdgeSide.esRight;\n    if (!Closed) locMin.LeftBound.WindDelta = 0;else if (locMin.LeftBound.Next == locMin.RightBound) locMin.LeftBound.WindDelta = -1;else locMin.LeftBound.WindDelta = 1;\n    locMin.RightBound.WindDelta = -locMin.LeftBound.WindDelta;\n    E = this.ProcessBound(locMin.LeftBound, clockwise);\n    var E2 = this.ProcessBound(locMin.RightBound, !clockwise);\n    if (locMin.LeftBound.OutIdx == ClipperLib.ClipperBase.Skip) locMin.LeftBound = null;else if (locMin.RightBound.OutIdx == ClipperLib.ClipperBase.Skip) locMin.RightBound = null;\n    this.InsertLocalMinima(locMin);\n    if (!clockwise) E = E2;\n  }\n\n  return true;\n};\n\nClipperLib.ClipperBase.prototype.AddPaths = function (ppg, polyType, closed) {\n  //  console.log(\"-------------------------------------------\");\n  //  console.log(JSON.stringify(ppg));\n  var result = false;\n\n  for (var i = 0, ilen = ppg.length; i < ilen; ++i) {\n    if (this.AddPath(ppg[i], polyType, closed)) result = true;\n  }\n\n  return result;\n}; //------------------------------------------------------------------------------\n\n\nClipperLib.ClipperBase.prototype.Pt2IsBetweenPt1AndPt3 = function (pt1, pt2, pt3) {\n  if (ClipperLib.IntPoint.op_Equality(pt1, pt3) || ClipperLib.IntPoint.op_Equality(pt1, pt2) || ClipperLib.IntPoint.op_Equality(pt3, pt2)) return false;else if (pt1.X != pt3.X) return pt2.X > pt1.X == pt2.X < pt3.X;else return pt2.Y > pt1.Y == pt2.Y < pt3.Y;\n};\n\nClipperLib.ClipperBase.prototype.RemoveEdge = function (e) {\n  //removes e from double_linked_list (but without removing from memory)\n  e.Prev.Next = e.Next;\n  e.Next.Prev = e.Prev;\n  var result = e.Next;\n  e.Prev = null; //flag as removed (see ClipperBase.Clear)\n\n  return result;\n};\n\nClipperLib.ClipperBase.prototype.SetDx = function (e) {\n  e.Delta.X = e.Top.X - e.Bot.X;\n  e.Delta.Y = e.Top.Y - e.Bot.Y;\n  if (e.Delta.Y === 0) e.Dx = ClipperLib.ClipperBase.horizontal;else e.Dx = e.Delta.X / e.Delta.Y;\n};\n\nClipperLib.ClipperBase.prototype.InsertLocalMinima = function (newLm) {\n  if (this.m_MinimaList === null) {\n    this.m_MinimaList = newLm;\n  } else if (newLm.Y >= this.m_MinimaList.Y) {\n    newLm.Next = this.m_MinimaList;\n    this.m_MinimaList = newLm;\n  } else {\n    var tmpLm = this.m_MinimaList;\n\n    while (tmpLm.Next !== null && newLm.Y < tmpLm.Next.Y) {\n      tmpLm = tmpLm.Next;\n    }\n\n    newLm.Next = tmpLm.Next;\n    tmpLm.Next = newLm;\n  }\n};\n\nClipperLib.ClipperBase.prototype.PopLocalMinima = function () {\n  if (this.m_CurrentLM === null) return;\n  this.m_CurrentLM = this.m_CurrentLM.Next;\n};\n\nClipperLib.ClipperBase.prototype.ReverseHorizontal = function (e) {\n  //swap horizontal edges' top and bottom x's so they follow the natural\n  //progression of the bounds - ie so their xbots will align with the\n  //adjoining lower edge. [Helpful in the ProcessHorizontal() method.]\n  var tmp = e.Top.X;\n  e.Top.X = e.Bot.X;\n  e.Bot.X = tmp;\n\n  if (use_xyz) {\n    tmp = e.Top.Z;\n    e.Top.Z = e.Bot.Z;\n    e.Bot.Z = tmp;\n  }\n};\n\nClipperLib.ClipperBase.prototype.Reset = function () {\n  this.m_CurrentLM = this.m_MinimaList;\n  if (this.m_CurrentLM == null) return; //ie nothing to process\n  //reset all edges ...\n\n  var lm = this.m_MinimaList;\n\n  while (lm != null) {\n    var e = lm.LeftBound;\n\n    if (e != null) {\n      //e.Curr = e.Bot;\n      e.Curr.X = e.Bot.X;\n      e.Curr.Y = e.Bot.Y;\n      e.Side = ClipperLib.EdgeSide.esLeft;\n      e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n    }\n\n    e = lm.RightBound;\n\n    if (e != null) {\n      //e.Curr = e.Bot;\n      e.Curr.X = e.Bot.X;\n      e.Curr.Y = e.Bot.Y;\n      e.Side = ClipperLib.EdgeSide.esRight;\n      e.OutIdx = ClipperLib.ClipperBase.Unassigned;\n    }\n\n    lm = lm.Next;\n  }\n};\n\nClipperLib.Clipper = function (InitOptions) // public Clipper(int InitOptions = 0)\n{\n  if (typeof InitOptions == \"undefined\") InitOptions = 0;\n  this.m_PolyOuts = null;\n  this.m_ClipType = ClipperLib.ClipType.ctIntersection;\n  this.m_Scanbeam = null;\n  this.m_ActiveEdges = null;\n  this.m_SortedEdges = null;\n  this.m_IntersectList = null;\n  this.m_IntersectNodeComparer = null;\n  this.m_ExecuteLocked = false;\n  this.m_ClipFillType = ClipperLib.PolyFillType.pftEvenOdd;\n  this.m_SubjFillType = ClipperLib.PolyFillType.pftEvenOdd;\n  this.m_Joins = null;\n  this.m_GhostJoins = null;\n  this.m_UsingPolyTree = false;\n  this.ReverseSolution = false;\n  this.StrictlySimple = false;\n  ClipperLib.ClipperBase.call(this);\n  this.m_Scanbeam = null;\n  this.m_ActiveEdges = null;\n  this.m_SortedEdges = null;\n  this.m_IntersectList = new Array();\n  this.m_IntersectNodeComparer = ClipperLib.MyIntersectNodeSort.Compare;\n  this.m_ExecuteLocked = false;\n  this.m_UsingPolyTree = false;\n  this.m_PolyOuts = new Array();\n  this.m_Joins = new Array();\n  this.m_GhostJoins = new Array();\n  this.ReverseSolution = (1 & InitOptions) !== 0;\n  this.StrictlySimple = (2 & InitOptions) !== 0;\n  this.PreserveCollinear = (4 & InitOptions) !== 0;\n\n  if (use_xyz) {\n    this.ZFillFunction = null; // function (IntPoint vert1, IntPoint vert2, ref IntPoint intersectPt);\n  }\n};\n\nClipperLib.Clipper.ioReverseSolution = 1;\nClipperLib.Clipper.ioStrictlySimple = 2;\nClipperLib.Clipper.ioPreserveCollinear = 4;\n\nClipperLib.Clipper.prototype.Clear = function () {\n  if (this.m_edges.length === 0) return; //avoids problems with ClipperBase destructor\n\n  this.DisposeAllPolyPts();\n  ClipperLib.ClipperBase.prototype.Clear.call(this);\n};\n\nClipperLib.Clipper.prototype.DisposeScanbeamList = function () {\n  while (this.m_Scanbeam !== null) {\n    var sb2 = this.m_Scanbeam.Next;\n    this.m_Scanbeam = null;\n    this.m_Scanbeam = sb2;\n  }\n};\n\nClipperLib.Clipper.prototype.Reset = function () {\n  ClipperLib.ClipperBase.prototype.Reset.call(this);\n  this.m_Scanbeam = null;\n  this.m_ActiveEdges = null;\n  this.m_SortedEdges = null;\n  var lm = this.m_MinimaList;\n\n  while (lm !== null) {\n    this.InsertScanbeam(lm.Y);\n    lm = lm.Next;\n  }\n};\n\nClipperLib.Clipper.prototype.InsertScanbeam = function (Y) {\n  if (this.m_Scanbeam === null) {\n    this.m_Scanbeam = new ClipperLib.Scanbeam();\n    this.m_Scanbeam.Next = null;\n    this.m_Scanbeam.Y = Y;\n  } else if (Y > this.m_Scanbeam.Y) {\n    var newSb = new ClipperLib.Scanbeam();\n    newSb.Y = Y;\n    newSb.Next = this.m_Scanbeam;\n    this.m_Scanbeam = newSb;\n  } else {\n    var sb2 = this.m_Scanbeam;\n\n    while (sb2.Next !== null && Y <= sb2.Next.Y) {\n      sb2 = sb2.Next;\n    }\n\n    if (Y == sb2.Y) return; //ie ignores duplicates\n\n    var newSb = new ClipperLib.Scanbeam();\n    newSb.Y = Y;\n    newSb.Next = sb2.Next;\n    sb2.Next = newSb;\n  }\n}; // ************************************\n\n\nClipperLib.Clipper.prototype.Execute = function () {\n  var a = arguments,\n      alen = a.length,\n      ispolytree = a[1] instanceof ClipperLib.PolyTree;\n\n  if (alen == 4 && !ispolytree) // function (clipType, solution, subjFillType, clipFillType)\n    {\n      var clipType = a[0],\n          solution = a[1],\n          subjFillType = a[2],\n          clipFillType = a[3];\n      if (this.m_ExecuteLocked) return false;\n      if (this.m_HasOpenPaths) ClipperLib.Error(\"Error: PolyTree struct is need for open path clipping.\");\n      this.m_ExecuteLocked = true;\n      ClipperLib.Clear(solution);\n      this.m_SubjFillType = subjFillType;\n      this.m_ClipFillType = clipFillType;\n      this.m_ClipType = clipType;\n      this.m_UsingPolyTree = false;\n\n      try {\n        var succeeded = this.ExecuteInternal(); //build the return polygons ...\n\n        if (succeeded) this.BuildResult(solution);\n      } finally {\n        this.DisposeAllPolyPts();\n        this.m_ExecuteLocked = false;\n      }\n\n      return succeeded;\n    } else if (alen == 4 && ispolytree) // function (clipType, polytree, subjFillType, clipFillType)\n    {\n      var clipType = a[0],\n          polytree = a[1],\n          subjFillType = a[2],\n          clipFillType = a[3];\n      if (this.m_ExecuteLocked) return false;\n      this.m_ExecuteLocked = true;\n      this.m_SubjFillType = subjFillType;\n      this.m_ClipFillType = clipFillType;\n      this.m_ClipType = clipType;\n      this.m_UsingPolyTree = true;\n\n      try {\n        var succeeded = this.ExecuteInternal(); //build the return polygons ...\n\n        if (succeeded) this.BuildResult2(polytree);\n      } finally {\n        this.DisposeAllPolyPts();\n        this.m_ExecuteLocked = false;\n      }\n\n      return succeeded;\n    } else if (alen == 2 && !ispolytree) // function (clipType, solution)\n    {\n      var clipType = a[0],\n          solution = a[1];\n      return this.Execute(clipType, solution, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n    } else if (alen == 2 && ispolytree) // function (clipType, polytree)\n    {\n      var clipType = a[0],\n          polytree = a[1];\n      return this.Execute(clipType, polytree, ClipperLib.PolyFillType.pftEvenOdd, ClipperLib.PolyFillType.pftEvenOdd);\n    }\n};\n\nClipperLib.Clipper.prototype.FixHoleLinkage = function (outRec) {\n  //skip if an outermost polygon or\n  //already already points to the correct FirstLeft ...\n  if (outRec.FirstLeft === null || outRec.IsHole != outRec.FirstLeft.IsHole && outRec.FirstLeft.Pts !== null) return;\n  var orfl = outRec.FirstLeft;\n\n  while (orfl !== null && (orfl.IsHole == outRec.IsHole || orfl.Pts === null)) {\n    orfl = orfl.FirstLeft;\n  }\n\n  outRec.FirstLeft = orfl;\n};\n\nClipperLib.Clipper.prototype.ExecuteInternal = function () {\n  try {\n    this.Reset();\n    if (this.m_CurrentLM === null) return false;\n    var botY = this.PopScanbeam();\n\n    do {\n      this.InsertLocalMinimaIntoAEL(botY);\n      ClipperLib.Clear(this.m_GhostJoins);\n      this.ProcessHorizontals(false);\n      if (this.m_Scanbeam === null) break;\n      var topY = this.PopScanbeam(); //console.log(\"botY:\" + botY + \", topY:\" + topY);\n\n      if (!this.ProcessIntersections(botY, topY)) return false;\n      this.ProcessEdgesAtTopOfScanbeam(topY);\n      botY = topY;\n    } while (this.m_Scanbeam !== null || this.m_CurrentLM !== null); //fix orientations ...\n\n\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++) {\n      var outRec = this.m_PolyOuts[i];\n      if (outRec.Pts === null || outRec.IsOpen) continue;\n      if ((outRec.IsHole ^ this.ReverseSolution) == this.Area(outRec) > 0) this.ReversePolyPtLinks(outRec.Pts);\n    }\n\n    this.JoinCommonEdges();\n\n    for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++) {\n      var outRec = this.m_PolyOuts[i];\n      if (outRec.Pts !== null && !outRec.IsOpen) this.FixupOutPolygon(outRec);\n    }\n\n    if (this.StrictlySimple) this.DoSimplePolygons();\n    return true;\n  } finally {\n    ClipperLib.Clear(this.m_Joins);\n    ClipperLib.Clear(this.m_GhostJoins);\n  }\n};\n\nClipperLib.Clipper.prototype.PopScanbeam = function () {\n  var Y = this.m_Scanbeam.Y;\n  var sb2 = this.m_Scanbeam;\n  this.m_Scanbeam = this.m_Scanbeam.Next;\n  sb2 = null;\n  return Y;\n};\n\nClipperLib.Clipper.prototype.DisposeAllPolyPts = function () {\n  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; ++i) {\n    this.DisposeOutRec(i);\n  }\n\n  ClipperLib.Clear(this.m_PolyOuts);\n};\n\nClipperLib.Clipper.prototype.DisposeOutRec = function (index) {\n  var outRec = this.m_PolyOuts[index];\n  if (outRec.Pts !== null) this.DisposeOutPts(outRec.Pts);\n  outRec = null;\n  this.m_PolyOuts[index] = null;\n};\n\nClipperLib.Clipper.prototype.DisposeOutPts = function (pp) {\n  if (pp === null) return;\n  var tmpPp = null;\n  pp.Prev.Next = null;\n\n  while (pp !== null) {\n    tmpPp = pp;\n    pp = pp.Next;\n    tmpPp = null;\n  }\n};\n\nClipperLib.Clipper.prototype.AddJoin = function (Op1, Op2, OffPt) {\n  var j = new ClipperLib.Join();\n  j.OutPt1 = Op1;\n  j.OutPt2 = Op2; //j.OffPt = OffPt;\n\n  j.OffPt.X = OffPt.X;\n  j.OffPt.Y = OffPt.Y;\n  this.m_Joins.push(j);\n};\n\nClipperLib.Clipper.prototype.AddGhostJoin = function (Op, OffPt) {\n  var j = new ClipperLib.Join();\n  j.OutPt1 = Op; //j.OffPt = OffPt;\n\n  j.OffPt.X = OffPt.X;\n  j.OffPt.Y = OffPt.Y;\n  this.m_GhostJoins.push(j);\n};\n\nif (use_xyz) {\n  ClipperLib.Clipper.prototype.SetZ = function (pt, e) {\n    pt.Z = 0;\n\n    if (this.ZFillFunction !== null) {\n      //put the 'preferred' point as first parameter ...\n      if (e.OutIdx < 0) this.ZFillFunction(e.Bot, e.Top, pt); //outside a path so presume entering\n      else this.ZFillFunction(e.Top, e.Bot, pt); //inside a path so presume exiting\n    }\n  }; //------------------------------------------------------------------------------\n\n}\n\nClipperLib.Clipper.prototype.InsertLocalMinimaIntoAEL = function (botY) {\n  while (this.m_CurrentLM !== null && this.m_CurrentLM.Y == botY) {\n    var lb = this.m_CurrentLM.LeftBound;\n    var rb = this.m_CurrentLM.RightBound;\n    this.PopLocalMinima();\n    var Op1 = null;\n\n    if (lb === null) {\n      this.InsertEdgeIntoAEL(rb, null);\n      this.SetWindingCount(rb);\n      if (this.IsContributing(rb)) Op1 = this.AddOutPt(rb, rb.Bot);\n    } else if (rb == null) {\n      this.InsertEdgeIntoAEL(lb, null);\n      this.SetWindingCount(lb);\n      if (this.IsContributing(lb)) Op1 = this.AddOutPt(lb, lb.Bot);\n      this.InsertScanbeam(lb.Top.Y);\n    } else {\n      this.InsertEdgeIntoAEL(lb, null);\n      this.InsertEdgeIntoAEL(rb, lb);\n      this.SetWindingCount(lb);\n      rb.WindCnt = lb.WindCnt;\n      rb.WindCnt2 = lb.WindCnt2;\n      if (this.IsContributing(lb)) Op1 = this.AddLocalMinPoly(lb, rb, lb.Bot);\n      this.InsertScanbeam(lb.Top.Y);\n    }\n\n    if (rb != null) {\n      if (ClipperLib.ClipperBase.IsHorizontal(rb)) this.AddEdgeToSEL(rb);else this.InsertScanbeam(rb.Top.Y);\n    }\n\n    if (lb == null || rb == null) continue; //if output polygons share an Edge with a horizontal rb, they'll need joining later ...\n\n    if (Op1 !== null && ClipperLib.ClipperBase.IsHorizontal(rb) && this.m_GhostJoins.length > 0 && rb.WindDelta !== 0) {\n      for (var i = 0, ilen = this.m_GhostJoins.length; i < ilen; i++) {\n        //if the horizontal Rb and a 'ghost' horizontal overlap, then convert\n        //the 'ghost' join to a real join ready for later ...\n        var j = this.m_GhostJoins[i];\n        if (this.HorzSegmentsOverlap(j.OutPt1.Pt, j.OffPt, rb.Bot, rb.Top)) this.AddJoin(j.OutPt1, Op1, j.OffPt);\n      }\n    }\n\n    if (lb.OutIdx >= 0 && lb.PrevInAEL !== null && lb.PrevInAEL.Curr.X == lb.Bot.X && lb.PrevInAEL.OutIdx >= 0 && ClipperLib.ClipperBase.SlopesEqual(lb.PrevInAEL, lb, this.m_UseFullRange) && lb.WindDelta !== 0 && lb.PrevInAEL.WindDelta !== 0) {\n      var Op2 = this.AddOutPt(lb.PrevInAEL, lb.Bot);\n      this.AddJoin(Op1, Op2, lb.Top);\n    }\n\n    if (lb.NextInAEL != rb) {\n      if (rb.OutIdx >= 0 && rb.PrevInAEL.OutIdx >= 0 && ClipperLib.ClipperBase.SlopesEqual(rb.PrevInAEL, rb, this.m_UseFullRange) && rb.WindDelta !== 0 && rb.PrevInAEL.WindDelta !== 0) {\n        var Op2 = this.AddOutPt(rb.PrevInAEL, rb.Bot);\n        this.AddJoin(Op1, Op2, rb.Top);\n      }\n\n      var e = lb.NextInAEL;\n      if (e !== null) while (e != rb) {\n        //nb: For calculating winding counts etc, IntersectEdges() assumes\n        //that param1 will be to the right of param2 ABOVE the intersection ...\n        this.IntersectEdges(rb, e, lb.Curr, false); //order important here\n\n        e = e.NextInAEL;\n      }\n    }\n  }\n};\n\nClipperLib.Clipper.prototype.InsertEdgeIntoAEL = function (edge, startEdge) {\n  if (this.m_ActiveEdges === null) {\n    edge.PrevInAEL = null;\n    edge.NextInAEL = null;\n    this.m_ActiveEdges = edge;\n  } else if (startEdge === null && this.E2InsertsBeforeE1(this.m_ActiveEdges, edge)) {\n    edge.PrevInAEL = null;\n    edge.NextInAEL = this.m_ActiveEdges;\n    this.m_ActiveEdges.PrevInAEL = edge;\n    this.m_ActiveEdges = edge;\n  } else {\n    if (startEdge === null) startEdge = this.m_ActiveEdges;\n\n    while (startEdge.NextInAEL !== null && !this.E2InsertsBeforeE1(startEdge.NextInAEL, edge)) {\n      startEdge = startEdge.NextInAEL;\n    }\n\n    edge.NextInAEL = startEdge.NextInAEL;\n    if (startEdge.NextInAEL !== null) startEdge.NextInAEL.PrevInAEL = edge;\n    edge.PrevInAEL = startEdge;\n    startEdge.NextInAEL = edge;\n  }\n};\n\nClipperLib.Clipper.prototype.E2InsertsBeforeE1 = function (e1, e2) {\n  if (e2.Curr.X == e1.Curr.X) {\n    if (e2.Top.Y > e1.Top.Y) return e2.Top.X < ClipperLib.Clipper.TopX(e1, e2.Top.Y);else return e1.Top.X > ClipperLib.Clipper.TopX(e2, e1.Top.Y);\n  } else return e2.Curr.X < e1.Curr.X;\n};\n\nClipperLib.Clipper.prototype.IsEvenOddFillType = function (edge) {\n  if (edge.PolyTyp == ClipperLib.PolyType.ptSubject) return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;else return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;\n};\n\nClipperLib.Clipper.prototype.IsEvenOddAltFillType = function (edge) {\n  if (edge.PolyTyp == ClipperLib.PolyType.ptSubject) return this.m_ClipFillType == ClipperLib.PolyFillType.pftEvenOdd;else return this.m_SubjFillType == ClipperLib.PolyFillType.pftEvenOdd;\n};\n\nClipperLib.Clipper.prototype.IsContributing = function (edge) {\n  var pft, pft2;\n\n  if (edge.PolyTyp == ClipperLib.PolyType.ptSubject) {\n    pft = this.m_SubjFillType;\n    pft2 = this.m_ClipFillType;\n  } else {\n    pft = this.m_ClipFillType;\n    pft2 = this.m_SubjFillType;\n  }\n\n  switch (pft) {\n    case ClipperLib.PolyFillType.pftEvenOdd:\n      if (edge.WindDelta === 0 && edge.WindCnt != 1) return false;\n      break;\n\n    case ClipperLib.PolyFillType.pftNonZero:\n      if (Math.abs(edge.WindCnt) != 1) return false;\n      break;\n\n    case ClipperLib.PolyFillType.pftPositive:\n      if (edge.WindCnt != 1) return false;\n      break;\n\n    default:\n      if (edge.WindCnt != -1) return false;\n      break;\n  }\n\n  switch (this.m_ClipType) {\n    case ClipperLib.ClipType.ctIntersection:\n      switch (pft2) {\n        case ClipperLib.PolyFillType.pftEvenOdd:\n        case ClipperLib.PolyFillType.pftNonZero:\n          return edge.WindCnt2 !== 0;\n\n        case ClipperLib.PolyFillType.pftPositive:\n          return edge.WindCnt2 > 0;\n\n        default:\n          return edge.WindCnt2 < 0;\n      }\n\n    case ClipperLib.ClipType.ctUnion:\n      switch (pft2) {\n        case ClipperLib.PolyFillType.pftEvenOdd:\n        case ClipperLib.PolyFillType.pftNonZero:\n          return edge.WindCnt2 === 0;\n\n        case ClipperLib.PolyFillType.pftPositive:\n          return edge.WindCnt2 <= 0;\n\n        default:\n          return edge.WindCnt2 >= 0;\n      }\n\n    case ClipperLib.ClipType.ctDifference:\n      if (edge.PolyTyp == ClipperLib.PolyType.ptSubject) switch (pft2) {\n        case ClipperLib.PolyFillType.pftEvenOdd:\n        case ClipperLib.PolyFillType.pftNonZero:\n          return edge.WindCnt2 === 0;\n\n        case ClipperLib.PolyFillType.pftPositive:\n          return edge.WindCnt2 <= 0;\n\n        default:\n          return edge.WindCnt2 >= 0;\n      } else switch (pft2) {\n        case ClipperLib.PolyFillType.pftEvenOdd:\n        case ClipperLib.PolyFillType.pftNonZero:\n          return edge.WindCnt2 !== 0;\n\n        case ClipperLib.PolyFillType.pftPositive:\n          return edge.WindCnt2 > 0;\n\n        default:\n          return edge.WindCnt2 < 0;\n      }\n\n    case ClipperLib.ClipType.ctXor:\n      if (edge.WindDelta === 0) switch (pft2) {\n        case ClipperLib.PolyFillType.pftEvenOdd:\n        case ClipperLib.PolyFillType.pftNonZero:\n          return edge.WindCnt2 === 0;\n\n        case ClipperLib.PolyFillType.pftPositive:\n          return edge.WindCnt2 <= 0;\n\n        default:\n          return edge.WindCnt2 >= 0;\n      } else return true;\n  }\n\n  return true;\n};\n\nClipperLib.Clipper.prototype.SetWindingCount = function (edge) {\n  var e = edge.PrevInAEL; //find the edge of the same polytype that immediately preceeds 'edge' in AEL\n\n  while (e !== null && (e.PolyTyp != edge.PolyTyp || e.WindDelta === 0)) {\n    e = e.PrevInAEL;\n  }\n\n  if (e === null) {\n    edge.WindCnt = edge.WindDelta === 0 ? 1 : edge.WindDelta;\n    edge.WindCnt2 = 0;\n    e = this.m_ActiveEdges; //ie get ready to calc WindCnt2\n  } else if (edge.WindDelta === 0 && this.m_ClipType != ClipperLib.ClipType.ctUnion) {\n    edge.WindCnt = 1;\n    edge.WindCnt2 = e.WindCnt2;\n    e = e.NextInAEL; //ie get ready to calc WindCnt2\n  } else if (this.IsEvenOddFillType(edge)) {\n    //EvenOdd filling ...\n    if (edge.WindDelta === 0) {\n      //are we inside a subj polygon ...\n      var Inside = true;\n      var e2 = e.PrevInAEL;\n\n      while (e2 !== null) {\n        if (e2.PolyTyp == e.PolyTyp && e2.WindDelta !== 0) Inside = !Inside;\n        e2 = e2.PrevInAEL;\n      }\n\n      edge.WindCnt = Inside ? 0 : 1;\n    } else {\n      edge.WindCnt = edge.WindDelta;\n    }\n\n    edge.WindCnt2 = e.WindCnt2;\n    e = e.NextInAEL; //ie get ready to calc WindCnt2\n  } else {\n    //nonZero, Positive or Negative filling ...\n    if (e.WindCnt * e.WindDelta < 0) {\n      //prev edge is 'decreasing' WindCount (WC) toward zero\n      //so we're outside the previous polygon ...\n      if (Math.abs(e.WindCnt) > 1) {\n        //outside prev poly but still inside another.\n        //when reversing direction of prev poly use the same WC \n        if (e.WindDelta * edge.WindDelta < 0) edge.WindCnt = e.WindCnt;else edge.WindCnt = e.WindCnt + edge.WindDelta;\n      } else edge.WindCnt = edge.WindDelta === 0 ? 1 : edge.WindDelta;\n    } else {\n      //prev edge is 'increasing' WindCount (WC) away from zero\n      //so we're inside the previous polygon ...\n      if (edge.WindDelta === 0) edge.WindCnt = e.WindCnt < 0 ? e.WindCnt - 1 : e.WindCnt + 1;else if (e.WindDelta * edge.WindDelta < 0) edge.WindCnt = e.WindCnt;else edge.WindCnt = e.WindCnt + edge.WindDelta;\n    }\n\n    edge.WindCnt2 = e.WindCnt2;\n    e = e.NextInAEL; //ie get ready to calc WindCnt2\n  } //update WindCnt2 ...\n\n\n  if (this.IsEvenOddAltFillType(edge)) {\n    //EvenOdd filling ...\n    while (e != edge) {\n      if (e.WindDelta !== 0) edge.WindCnt2 = edge.WindCnt2 === 0 ? 1 : 0;\n      e = e.NextInAEL;\n    }\n  } else {\n    //nonZero, Positive or Negative filling ...\n    while (e != edge) {\n      edge.WindCnt2 += e.WindDelta;\n      e = e.NextInAEL;\n    }\n  }\n};\n\nClipperLib.Clipper.prototype.AddEdgeToSEL = function (edge) {\n  //SEL pointers in PEdge are reused to build a list of horizontal edges.\n  //However, we don't need to worry about order with horizontal edge processing.\n  if (this.m_SortedEdges === null) {\n    this.m_SortedEdges = edge;\n    edge.PrevInSEL = null;\n    edge.NextInSEL = null;\n  } else {\n    edge.NextInSEL = this.m_SortedEdges;\n    edge.PrevInSEL = null;\n    this.m_SortedEdges.PrevInSEL = edge;\n    this.m_SortedEdges = edge;\n  }\n};\n\nClipperLib.Clipper.prototype.CopyAELToSEL = function () {\n  var e = this.m_ActiveEdges;\n  this.m_SortedEdges = e;\n\n  while (e !== null) {\n    e.PrevInSEL = e.PrevInAEL;\n    e.NextInSEL = e.NextInAEL;\n    e = e.NextInAEL;\n  }\n};\n\nClipperLib.Clipper.prototype.SwapPositionsInAEL = function (edge1, edge2) {\n  //check that one or other edge hasn't already been removed from AEL ...\n  if (edge1.NextInAEL == edge1.PrevInAEL || edge2.NextInAEL == edge2.PrevInAEL) return;\n\n  if (edge1.NextInAEL == edge2) {\n    var next = edge2.NextInAEL;\n    if (next !== null) next.PrevInAEL = edge1;\n    var prev = edge1.PrevInAEL;\n    if (prev !== null) prev.NextInAEL = edge2;\n    edge2.PrevInAEL = prev;\n    edge2.NextInAEL = edge1;\n    edge1.PrevInAEL = edge2;\n    edge1.NextInAEL = next;\n  } else if (edge2.NextInAEL == edge1) {\n    var next = edge1.NextInAEL;\n    if (next !== null) next.PrevInAEL = edge2;\n    var prev = edge2.PrevInAEL;\n    if (prev !== null) prev.NextInAEL = edge1;\n    edge1.PrevInAEL = prev;\n    edge1.NextInAEL = edge2;\n    edge2.PrevInAEL = edge1;\n    edge2.NextInAEL = next;\n  } else {\n    var next = edge1.NextInAEL;\n    var prev = edge1.PrevInAEL;\n    edge1.NextInAEL = edge2.NextInAEL;\n    if (edge1.NextInAEL !== null) edge1.NextInAEL.PrevInAEL = edge1;\n    edge1.PrevInAEL = edge2.PrevInAEL;\n    if (edge1.PrevInAEL !== null) edge1.PrevInAEL.NextInAEL = edge1;\n    edge2.NextInAEL = next;\n    if (edge2.NextInAEL !== null) edge2.NextInAEL.PrevInAEL = edge2;\n    edge2.PrevInAEL = prev;\n    if (edge2.PrevInAEL !== null) edge2.PrevInAEL.NextInAEL = edge2;\n  }\n\n  if (edge1.PrevInAEL === null) this.m_ActiveEdges = edge1;else if (edge2.PrevInAEL === null) this.m_ActiveEdges = edge2;\n};\n\nClipperLib.Clipper.prototype.SwapPositionsInSEL = function (edge1, edge2) {\n  if (edge1.NextInSEL === null && edge1.PrevInSEL === null) return;\n  if (edge2.NextInSEL === null && edge2.PrevInSEL === null) return;\n\n  if (edge1.NextInSEL == edge2) {\n    var next = edge2.NextInSEL;\n    if (next !== null) next.PrevInSEL = edge1;\n    var prev = edge1.PrevInSEL;\n    if (prev !== null) prev.NextInSEL = edge2;\n    edge2.PrevInSEL = prev;\n    edge2.NextInSEL = edge1;\n    edge1.PrevInSEL = edge2;\n    edge1.NextInSEL = next;\n  } else if (edge2.NextInSEL == edge1) {\n    var next = edge1.NextInSEL;\n    if (next !== null) next.PrevInSEL = edge2;\n    var prev = edge2.PrevInSEL;\n    if (prev !== null) prev.NextInSEL = edge1;\n    edge1.PrevInSEL = prev;\n    edge1.NextInSEL = edge2;\n    edge2.PrevInSEL = edge1;\n    edge2.NextInSEL = next;\n  } else {\n    var next = edge1.NextInSEL;\n    var prev = edge1.PrevInSEL;\n    edge1.NextInSEL = edge2.NextInSEL;\n    if (edge1.NextInSEL !== null) edge1.NextInSEL.PrevInSEL = edge1;\n    edge1.PrevInSEL = edge2.PrevInSEL;\n    if (edge1.PrevInSEL !== null) edge1.PrevInSEL.NextInSEL = edge1;\n    edge2.NextInSEL = next;\n    if (edge2.NextInSEL !== null) edge2.NextInSEL.PrevInSEL = edge2;\n    edge2.PrevInSEL = prev;\n    if (edge2.PrevInSEL !== null) edge2.PrevInSEL.NextInSEL = edge2;\n  }\n\n  if (edge1.PrevInSEL === null) this.m_SortedEdges = edge1;else if (edge2.PrevInSEL === null) this.m_SortedEdges = edge2;\n};\n\nClipperLib.Clipper.prototype.AddLocalMaxPoly = function (e1, e2, pt) {\n  this.AddOutPt(e1, pt);\n  if (e2.WindDelta == 0) this.AddOutPt(e2, pt);\n\n  if (e1.OutIdx == e2.OutIdx) {\n    e1.OutIdx = -1;\n    e2.OutIdx = -1;\n  } else if (e1.OutIdx < e2.OutIdx) this.AppendPolygon(e1, e2);else this.AppendPolygon(e2, e1);\n};\n\nClipperLib.Clipper.prototype.AddLocalMinPoly = function (e1, e2, pt) {\n  var result;\n  var e, prevE;\n\n  if (ClipperLib.ClipperBase.IsHorizontal(e2) || e1.Dx > e2.Dx) {\n    result = this.AddOutPt(e1, pt);\n    e2.OutIdx = e1.OutIdx;\n    e1.Side = ClipperLib.EdgeSide.esLeft;\n    e2.Side = ClipperLib.EdgeSide.esRight;\n    e = e1;\n    if (e.PrevInAEL == e2) prevE = e2.PrevInAEL;else prevE = e.PrevInAEL;\n  } else {\n    result = this.AddOutPt(e2, pt);\n    e1.OutIdx = e2.OutIdx;\n    e1.Side = ClipperLib.EdgeSide.esRight;\n    e2.Side = ClipperLib.EdgeSide.esLeft;\n    e = e2;\n    if (e.PrevInAEL == e1) prevE = e1.PrevInAEL;else prevE = e.PrevInAEL;\n  }\n\n  if (prevE !== null && prevE.OutIdx >= 0 && ClipperLib.Clipper.TopX(prevE, pt.Y) == ClipperLib.Clipper.TopX(e, pt.Y) && ClipperLib.ClipperBase.SlopesEqual(e, prevE, this.m_UseFullRange) && e.WindDelta !== 0 && prevE.WindDelta !== 0) {\n    var outPt = this.AddOutPt(prevE, pt);\n    this.AddJoin(result, outPt, e.Top);\n  }\n\n  return result;\n};\n\nClipperLib.Clipper.prototype.CreateOutRec = function () {\n  var result = new ClipperLib.OutRec();\n  result.Idx = -1;\n  result.IsHole = false;\n  result.IsOpen = false;\n  result.FirstLeft = null;\n  result.Pts = null;\n  result.BottomPt = null;\n  result.PolyNode = null;\n  this.m_PolyOuts.push(result);\n  result.Idx = this.m_PolyOuts.length - 1;\n  return result;\n};\n\nClipperLib.Clipper.prototype.AddOutPt = function (e, pt) {\n  var ToFront = e.Side == ClipperLib.EdgeSide.esLeft;\n\n  if (e.OutIdx < 0) {\n    var outRec = this.CreateOutRec();\n    outRec.IsOpen = e.WindDelta === 0;\n    var newOp = new ClipperLib.OutPt();\n    outRec.Pts = newOp;\n    newOp.Idx = outRec.Idx; //newOp.Pt = pt;\n\n    newOp.Pt.X = pt.X;\n    newOp.Pt.Y = pt.Y;\n    newOp.Next = newOp;\n    newOp.Prev = newOp;\n    if (!outRec.IsOpen) this.SetHoleState(e, outRec);\n\n    if (use_xyz) {\n      if (ClipperLib.IntPoint.op_Equality(pt, e.Bot)) {\n        //newOp.Pt = e.Bot;\n        newOp.Pt.X = e.Bot.X;\n        newOp.Pt.Y = e.Bot.Y;\n        newOp.Pt.Z = e.Bot.Z;\n      } else if (ClipperLib.IntPoint.op_Equality(pt, e.Top)) {\n        //newOp.Pt = e.Top;\n        newOp.Pt.X = e.Top.X;\n        newOp.Pt.Y = e.Top.Y;\n        newOp.Pt.Z = e.Top.Z;\n      } else this.SetZ(newOp.Pt, e);\n    }\n\n    e.OutIdx = outRec.Idx; //nb: do this after SetZ !\n\n    return newOp;\n  } else {\n    var outRec = this.m_PolyOuts[e.OutIdx]; //OutRec.Pts is the 'Left-most' point & OutRec.Pts.Prev is the 'Right-most'\n\n    var op = outRec.Pts;\n    if (ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Pt)) return op;else if (!ToFront && ClipperLib.IntPoint.op_Equality(pt, op.Prev.Pt)) return op.Prev;\n    var newOp = new ClipperLib.OutPt();\n    newOp.Idx = outRec.Idx; //newOp.Pt = pt;\n\n    newOp.Pt.X = pt.X;\n    newOp.Pt.Y = pt.Y;\n    newOp.Next = op;\n    newOp.Prev = op.Prev;\n    newOp.Prev.Next = newOp;\n    op.Prev = newOp;\n    if (ToFront) outRec.Pts = newOp;\n\n    if (use_xyz) {\n      if (ClipperLib.IntPoint.op_Equality(pt, e.Bot)) {\n        //newOp.Pt = e.Bot;\n        newOp.Pt.X = e.Bot.X;\n        newOp.Pt.Y = e.Bot.Y;\n        newOp.Pt.Z = e.Bot.Z;\n      } else if (ClipperLib.IntPoint.op_Equality(pt, e.Top)) {\n        //newOp.Pt = e.Top;\n        newOp.Pt.X = e.Top.X;\n        newOp.Pt.Y = e.Top.Y;\n        newOp.Pt.Z = e.Top.Z;\n      } else this.SetZ(newOp.Pt, e);\n    }\n\n    return newOp;\n  }\n};\n\nClipperLib.Clipper.prototype.SwapPoints = function (pt1, pt2) {\n  var tmp = new ClipperLib.IntPoint(pt1.Value); //pt1.Value = pt2.Value;\n\n  pt1.Value.X = pt2.Value.X;\n  pt1.Value.Y = pt2.Value.Y; //pt2.Value = tmp;\n\n  pt2.Value.X = tmp.X;\n  pt2.Value.Y = tmp.Y;\n};\n\nClipperLib.Clipper.prototype.HorzSegmentsOverlap = function (Pt1a, Pt1b, Pt2a, Pt2b) {\n  //precondition: both segments are horizontal\n  if (Pt1a.X > Pt2a.X == Pt1a.X < Pt2b.X) return true;else if (Pt1b.X > Pt2a.X == Pt1b.X < Pt2b.X) return true;else if (Pt2a.X > Pt1a.X == Pt2a.X < Pt1b.X) return true;else if (Pt2b.X > Pt1a.X == Pt2b.X < Pt1b.X) return true;else if (Pt1a.X == Pt2a.X && Pt1b.X == Pt2b.X) return true;else if (Pt1a.X == Pt2b.X && Pt1b.X == Pt2a.X) return true;else return false;\n};\n\nClipperLib.Clipper.prototype.InsertPolyPtBetween = function (p1, p2, pt) {\n  var result = new ClipperLib.OutPt(); //result.Pt = pt;\n\n  result.Pt.X = pt.X;\n  result.Pt.Y = pt.Y;\n\n  if (p2 == p1.Next) {\n    p1.Next = result;\n    p2.Prev = result;\n    result.Next = p2;\n    result.Prev = p1;\n  } else {\n    p2.Next = result;\n    p1.Prev = result;\n    result.Next = p1;\n    result.Prev = p2;\n  }\n\n  return result;\n};\n\nClipperLib.Clipper.prototype.SetHoleState = function (e, outRec) {\n  var isHole = false;\n  var e2 = e.PrevInAEL;\n\n  while (e2 !== null) {\n    if (e2.OutIdx >= 0 && e2.WindDelta != 0) {\n      isHole = !isHole;\n      if (outRec.FirstLeft === null) outRec.FirstLeft = this.m_PolyOuts[e2.OutIdx];\n    }\n\n    e2 = e2.PrevInAEL;\n  }\n\n  if (isHole) outRec.IsHole = true;\n};\n\nClipperLib.Clipper.prototype.GetDx = function (pt1, pt2) {\n  if (pt1.Y == pt2.Y) return ClipperLib.ClipperBase.horizontal;else return (pt2.X - pt1.X) / (pt2.Y - pt1.Y);\n};\n\nClipperLib.Clipper.prototype.FirstIsBottomPt = function (btmPt1, btmPt2) {\n  var p = btmPt1.Prev;\n\n  while (ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt) && p != btmPt1) {\n    p = p.Prev;\n  }\n\n  var dx1p = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n  p = btmPt1.Next;\n\n  while (ClipperLib.IntPoint.op_Equality(p.Pt, btmPt1.Pt) && p != btmPt1) {\n    p = p.Next;\n  }\n\n  var dx1n = Math.abs(this.GetDx(btmPt1.Pt, p.Pt));\n  p = btmPt2.Prev;\n\n  while (ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt) && p != btmPt2) {\n    p = p.Prev;\n  }\n\n  var dx2p = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n  p = btmPt2.Next;\n\n  while (ClipperLib.IntPoint.op_Equality(p.Pt, btmPt2.Pt) && p != btmPt2) {\n    p = p.Next;\n  }\n\n  var dx2n = Math.abs(this.GetDx(btmPt2.Pt, p.Pt));\n  return dx1p >= dx2p && dx1p >= dx2n || dx1n >= dx2p && dx1n >= dx2n;\n};\n\nClipperLib.Clipper.prototype.GetBottomPt = function (pp) {\n  var dups = null;\n  var p = pp.Next;\n\n  while (p != pp) {\n    if (p.Pt.Y > pp.Pt.Y) {\n      pp = p;\n      dups = null;\n    } else if (p.Pt.Y == pp.Pt.Y && p.Pt.X <= pp.Pt.X) {\n      if (p.Pt.X < pp.Pt.X) {\n        dups = null;\n        pp = p;\n      } else {\n        if (p.Next != pp && p.Prev != pp) dups = p;\n      }\n    }\n\n    p = p.Next;\n  }\n\n  if (dups !== null) {\n    //there appears to be at least 2 vertices at bottomPt so ...\n    while (dups != p) {\n      if (!this.FirstIsBottomPt(p, dups)) pp = dups;\n      dups = dups.Next;\n\n      while (ClipperLib.IntPoint.op_Inequality(dups.Pt, pp.Pt)) {\n        dups = dups.Next;\n      }\n    }\n  }\n\n  return pp;\n};\n\nClipperLib.Clipper.prototype.GetLowermostRec = function (outRec1, outRec2) {\n  //work out which polygon fragment has the correct hole state ...\n  if (outRec1.BottomPt === null) outRec1.BottomPt = this.GetBottomPt(outRec1.Pts);\n  if (outRec2.BottomPt === null) outRec2.BottomPt = this.GetBottomPt(outRec2.Pts);\n  var bPt1 = outRec1.BottomPt;\n  var bPt2 = outRec2.BottomPt;\n  if (bPt1.Pt.Y > bPt2.Pt.Y) return outRec1;else if (bPt1.Pt.Y < bPt2.Pt.Y) return outRec2;else if (bPt1.Pt.X < bPt2.Pt.X) return outRec1;else if (bPt1.Pt.X > bPt2.Pt.X) return outRec2;else if (bPt1.Next == bPt1) return outRec2;else if (bPt2.Next == bPt2) return outRec1;else if (this.FirstIsBottomPt(bPt1, bPt2)) return outRec1;else return outRec2;\n};\n\nClipperLib.Clipper.prototype.Param1RightOfParam2 = function (outRec1, outRec2) {\n  do {\n    outRec1 = outRec1.FirstLeft;\n    if (outRec1 == outRec2) return true;\n  } while (outRec1 !== null);\n\n  return false;\n};\n\nClipperLib.Clipper.prototype.GetOutRec = function (idx) {\n  var outrec = this.m_PolyOuts[idx];\n\n  while (outrec != this.m_PolyOuts[outrec.Idx]) {\n    outrec = this.m_PolyOuts[outrec.Idx];\n  }\n\n  return outrec;\n};\n\nClipperLib.Clipper.prototype.AppendPolygon = function (e1, e2) {\n  //get the start and ends of both output polygons ...\n  var outRec1 = this.m_PolyOuts[e1.OutIdx];\n  var outRec2 = this.m_PolyOuts[e2.OutIdx];\n  var holeStateRec;\n  if (this.Param1RightOfParam2(outRec1, outRec2)) holeStateRec = outRec2;else if (this.Param1RightOfParam2(outRec2, outRec1)) holeStateRec = outRec1;else holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n  var p1_lft = outRec1.Pts;\n  var p1_rt = p1_lft.Prev;\n  var p2_lft = outRec2.Pts;\n  var p2_rt = p2_lft.Prev;\n  var side; //join e2 poly onto e1 poly and delete pointers to e2 ...\n\n  if (e1.Side == ClipperLib.EdgeSide.esLeft) {\n    if (e2.Side == ClipperLib.EdgeSide.esLeft) {\n      //z y x a b c\n      this.ReversePolyPtLinks(p2_lft);\n      p2_lft.Next = p1_lft;\n      p1_lft.Prev = p2_lft;\n      p1_rt.Next = p2_rt;\n      p2_rt.Prev = p1_rt;\n      outRec1.Pts = p2_rt;\n    } else {\n      //x y z a b c\n      p2_rt.Next = p1_lft;\n      p1_lft.Prev = p2_rt;\n      p2_lft.Prev = p1_rt;\n      p1_rt.Next = p2_lft;\n      outRec1.Pts = p2_lft;\n    }\n\n    side = ClipperLib.EdgeSide.esLeft;\n  } else {\n    if (e2.Side == ClipperLib.EdgeSide.esRight) {\n      //a b c z y x\n      this.ReversePolyPtLinks(p2_lft);\n      p1_rt.Next = p2_rt;\n      p2_rt.Prev = p1_rt;\n      p2_lft.Next = p1_lft;\n      p1_lft.Prev = p2_lft;\n    } else {\n      //a b c x y z\n      p1_rt.Next = p2_lft;\n      p2_lft.Prev = p1_rt;\n      p1_lft.Prev = p2_rt;\n      p2_rt.Next = p1_lft;\n    }\n\n    side = ClipperLib.EdgeSide.esRight;\n  }\n\n  outRec1.BottomPt = null;\n\n  if (holeStateRec == outRec2) {\n    if (outRec2.FirstLeft != outRec1) outRec1.FirstLeft = outRec2.FirstLeft;\n    outRec1.IsHole = outRec2.IsHole;\n  }\n\n  outRec2.Pts = null;\n  outRec2.BottomPt = null;\n  outRec2.FirstLeft = outRec1;\n  var OKIdx = e1.OutIdx;\n  var ObsoleteIdx = e2.OutIdx;\n  e1.OutIdx = -1; //nb: safe because we only get here via AddLocalMaxPoly\n\n  e2.OutIdx = -1;\n  var e = this.m_ActiveEdges;\n\n  while (e !== null) {\n    if (e.OutIdx == ObsoleteIdx) {\n      e.OutIdx = OKIdx;\n      e.Side = side;\n      break;\n    }\n\n    e = e.NextInAEL;\n  }\n\n  outRec2.Idx = outRec1.Idx;\n};\n\nClipperLib.Clipper.prototype.ReversePolyPtLinks = function (pp) {\n  if (pp === null) return;\n  var pp1;\n  var pp2;\n  pp1 = pp;\n\n  do {\n    pp2 = pp1.Next;\n    pp1.Next = pp1.Prev;\n    pp1.Prev = pp2;\n    pp1 = pp2;\n  } while (pp1 != pp);\n};\n\nClipperLib.Clipper.SwapSides = function (edge1, edge2) {\n  var side = edge1.Side;\n  edge1.Side = edge2.Side;\n  edge2.Side = side;\n};\n\nClipperLib.Clipper.SwapPolyIndexes = function (edge1, edge2) {\n  var outIdx = edge1.OutIdx;\n  edge1.OutIdx = edge2.OutIdx;\n  edge2.OutIdx = outIdx;\n};\n\nClipperLib.Clipper.prototype.IntersectEdges = function (e1, e2, pt, protect) {\n  //e1 will be to the left of e2 BELOW the intersection. Therefore e1 is before\n  //e2 in AEL except when e1 is being inserted at the intersection point ...\n  var e1stops = !protect && e1.NextInLML === null && e1.Top.X == pt.X && e1.Top.Y == pt.Y;\n  var e2stops = !protect && e2.NextInLML === null && e2.Top.X == pt.X && e2.Top.Y == pt.Y;\n  var e1Contributing = e1.OutIdx >= 0;\n  var e2Contributing = e2.OutIdx >= 0;\n\n  if (use_lines) {\n    //if either edge is on an OPEN path ...\n    if (e1.WindDelta === 0 || e2.WindDelta === 0) {\n      //ignore subject-subject open path intersections UNLESS they\n      //are both open paths, AND they are both 'contributing maximas' ...\n      if (e1.WindDelta === 0 && e2.WindDelta === 0) {\n        if ((e1stops || e2stops) && e1Contributing && e2Contributing) this.AddLocalMaxPoly(e1, e2, pt);\n      } //if intersecting a subj line with a subj poly ...\n      else if (e1.PolyTyp == e2.PolyTyp && e1.WindDelta != e2.WindDelta && this.m_ClipType == ClipperLib.ClipType.ctUnion) {\n          if (e1.WindDelta === 0) {\n            if (e2Contributing) {\n              this.AddOutPt(e1, pt);\n              if (e1Contributing) e1.OutIdx = -1;\n            }\n          } else {\n            if (e1Contributing) {\n              this.AddOutPt(e2, pt);\n              if (e2Contributing) e2.OutIdx = -1;\n            }\n          }\n        } else if (e1.PolyTyp != e2.PolyTyp) {\n          if (e1.WindDelta === 0 && Math.abs(e2.WindCnt) == 1 && (this.m_ClipType != ClipperLib.ClipType.ctUnion || e2.WindCnt2 === 0)) {\n            this.AddOutPt(e1, pt);\n            if (e1Contributing) e1.OutIdx = -1;\n          } else if (e2.WindDelta === 0 && Math.abs(e1.WindCnt) == 1 && (this.m_ClipType != ClipperLib.ClipType.ctUnion || e1.WindCnt2 === 0)) {\n            this.AddOutPt(e2, pt);\n            if (e2Contributing) e2.OutIdx = -1;\n          }\n        }\n\n      if (e1stops) if (e1.OutIdx < 0) this.DeleteFromAEL(e1);else ClipperLib.Error(\"Error intersecting polylines\");\n      if (e2stops) if (e2.OutIdx < 0) this.DeleteFromAEL(e2);else ClipperLib.Error(\"Error intersecting polylines\");\n      return;\n    }\n  } //update winding counts...\n  //assumes that e1 will be to the Right of e2 ABOVE the intersection\n\n\n  if (e1.PolyTyp == e2.PolyTyp) {\n    if (this.IsEvenOddFillType(e1)) {\n      var oldE1WindCnt = e1.WindCnt;\n      e1.WindCnt = e2.WindCnt;\n      e2.WindCnt = oldE1WindCnt;\n    } else {\n      if (e1.WindCnt + e2.WindDelta === 0) e1.WindCnt = -e1.WindCnt;else e1.WindCnt += e2.WindDelta;\n      if (e2.WindCnt - e1.WindDelta === 0) e2.WindCnt = -e2.WindCnt;else e2.WindCnt -= e1.WindDelta;\n    }\n  } else {\n    if (!this.IsEvenOddFillType(e2)) e1.WindCnt2 += e2.WindDelta;else e1.WindCnt2 = e1.WindCnt2 === 0 ? 1 : 0;\n    if (!this.IsEvenOddFillType(e1)) e2.WindCnt2 -= e1.WindDelta;else e2.WindCnt2 = e2.WindCnt2 === 0 ? 1 : 0;\n  }\n\n  var e1FillType, e2FillType, e1FillType2, e2FillType2;\n\n  if (e1.PolyTyp == ClipperLib.PolyType.ptSubject) {\n    e1FillType = this.m_SubjFillType;\n    e1FillType2 = this.m_ClipFillType;\n  } else {\n    e1FillType = this.m_ClipFillType;\n    e1FillType2 = this.m_SubjFillType;\n  }\n\n  if (e2.PolyTyp == ClipperLib.PolyType.ptSubject) {\n    e2FillType = this.m_SubjFillType;\n    e2FillType2 = this.m_ClipFillType;\n  } else {\n    e2FillType = this.m_ClipFillType;\n    e2FillType2 = this.m_SubjFillType;\n  }\n\n  var e1Wc, e2Wc;\n\n  switch (e1FillType) {\n    case ClipperLib.PolyFillType.pftPositive:\n      e1Wc = e1.WindCnt;\n      break;\n\n    case ClipperLib.PolyFillType.pftNegative:\n      e1Wc = -e1.WindCnt;\n      break;\n\n    default:\n      e1Wc = Math.abs(e1.WindCnt);\n      break;\n  }\n\n  switch (e2FillType) {\n    case ClipperLib.PolyFillType.pftPositive:\n      e2Wc = e2.WindCnt;\n      break;\n\n    case ClipperLib.PolyFillType.pftNegative:\n      e2Wc = -e2.WindCnt;\n      break;\n\n    default:\n      e2Wc = Math.abs(e2.WindCnt);\n      break;\n  }\n\n  if (e1Contributing && e2Contributing) {\n    if (e1stops || e2stops || e1Wc !== 0 && e1Wc != 1 || e2Wc !== 0 && e2Wc != 1 || e1.PolyTyp != e2.PolyTyp && this.m_ClipType != ClipperLib.ClipType.ctXor) this.AddLocalMaxPoly(e1, e2, pt);else {\n      this.AddOutPt(e1, pt);\n      this.AddOutPt(e2, pt);\n      ClipperLib.Clipper.SwapSides(e1, e2);\n      ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n    }\n  } else if (e1Contributing) {\n    if (e2Wc === 0 || e2Wc == 1) {\n      this.AddOutPt(e1, pt);\n      ClipperLib.Clipper.SwapSides(e1, e2);\n      ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n    }\n  } else if (e2Contributing) {\n    if (e1Wc === 0 || e1Wc == 1) {\n      this.AddOutPt(e2, pt);\n      ClipperLib.Clipper.SwapSides(e1, e2);\n      ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n    }\n  } else if ((e1Wc === 0 || e1Wc == 1) && (e2Wc === 0 || e2Wc == 1) && !e1stops && !e2stops) {\n    //neither edge is currently contributing ...\n    var e1Wc2, e2Wc2;\n\n    switch (e1FillType2) {\n      case ClipperLib.PolyFillType.pftPositive:\n        e1Wc2 = e1.WindCnt2;\n        break;\n\n      case ClipperLib.PolyFillType.pftNegative:\n        e1Wc2 = -e1.WindCnt2;\n        break;\n\n      default:\n        e1Wc2 = Math.abs(e1.WindCnt2);\n        break;\n    }\n\n    switch (e2FillType2) {\n      case ClipperLib.PolyFillType.pftPositive:\n        e2Wc2 = e2.WindCnt2;\n        break;\n\n      case ClipperLib.PolyFillType.pftNegative:\n        e2Wc2 = -e2.WindCnt2;\n        break;\n\n      default:\n        e2Wc2 = Math.abs(e2.WindCnt2);\n        break;\n    }\n\n    if (e1.PolyTyp != e2.PolyTyp) this.AddLocalMinPoly(e1, e2, pt);else if (e1Wc == 1 && e2Wc == 1) switch (this.m_ClipType) {\n      case ClipperLib.ClipType.ctIntersection:\n        if (e1Wc2 > 0 && e2Wc2 > 0) this.AddLocalMinPoly(e1, e2, pt);\n        break;\n\n      case ClipperLib.ClipType.ctUnion:\n        if (e1Wc2 <= 0 && e2Wc2 <= 0) this.AddLocalMinPoly(e1, e2, pt);\n        break;\n\n      case ClipperLib.ClipType.ctDifference:\n        if (e1.PolyTyp == ClipperLib.PolyType.ptClip && e1Wc2 > 0 && e2Wc2 > 0 || e1.PolyTyp == ClipperLib.PolyType.ptSubject && e1Wc2 <= 0 && e2Wc2 <= 0) this.AddLocalMinPoly(e1, e2, pt);\n        break;\n\n      case ClipperLib.ClipType.ctXor:\n        this.AddLocalMinPoly(e1, e2, pt);\n        break;\n    } else ClipperLib.Clipper.SwapSides(e1, e2);\n  }\n\n  if (e1stops != e2stops && (e1stops && e1.OutIdx >= 0 || e2stops && e2.OutIdx >= 0)) {\n    ClipperLib.Clipper.SwapSides(e1, e2);\n    ClipperLib.Clipper.SwapPolyIndexes(e1, e2);\n  } //finally, delete any non-contributing maxima edges  ...\n\n\n  if (e1stops) this.DeleteFromAEL(e1);\n  if (e2stops) this.DeleteFromAEL(e2);\n};\n\nClipperLib.Clipper.prototype.DeleteFromAEL = function (e) {\n  var AelPrev = e.PrevInAEL;\n  var AelNext = e.NextInAEL;\n  if (AelPrev === null && AelNext === null && e != this.m_ActiveEdges) return; //already deleted\n\n  if (AelPrev !== null) AelPrev.NextInAEL = AelNext;else this.m_ActiveEdges = AelNext;\n  if (AelNext !== null) AelNext.PrevInAEL = AelPrev;\n  e.NextInAEL = null;\n  e.PrevInAEL = null;\n};\n\nClipperLib.Clipper.prototype.DeleteFromSEL = function (e) {\n  var SelPrev = e.PrevInSEL;\n  var SelNext = e.NextInSEL;\n  if (SelPrev === null && SelNext === null && e != this.m_SortedEdges) return; //already deleted\n\n  if (SelPrev !== null) SelPrev.NextInSEL = SelNext;else this.m_SortedEdges = SelNext;\n  if (SelNext !== null) SelNext.PrevInSEL = SelPrev;\n  e.NextInSEL = null;\n  e.PrevInSEL = null;\n};\n\nClipperLib.Clipper.prototype.UpdateEdgeIntoAEL = function (e) {\n  if (e.NextInLML === null) ClipperLib.Error(\"UpdateEdgeIntoAEL: invalid call\");\n  var AelPrev = e.PrevInAEL;\n  var AelNext = e.NextInAEL;\n  e.NextInLML.OutIdx = e.OutIdx;\n  if (AelPrev !== null) AelPrev.NextInAEL = e.NextInLML;else this.m_ActiveEdges = e.NextInLML;\n  if (AelNext !== null) AelNext.PrevInAEL = e.NextInLML;\n  e.NextInLML.Side = e.Side;\n  e.NextInLML.WindDelta = e.WindDelta;\n  e.NextInLML.WindCnt = e.WindCnt;\n  e.NextInLML.WindCnt2 = e.WindCnt2;\n  e = e.NextInLML; //    e.Curr = e.Bot;\n\n  e.Curr.X = e.Bot.X;\n  e.Curr.Y = e.Bot.Y;\n  e.PrevInAEL = AelPrev;\n  e.NextInAEL = AelNext;\n  if (!ClipperLib.ClipperBase.IsHorizontal(e)) this.InsertScanbeam(e.Top.Y);\n  return e;\n};\n\nClipperLib.Clipper.prototype.ProcessHorizontals = function (isTopOfScanbeam) {\n  var horzEdge = this.m_SortedEdges;\n\n  while (horzEdge !== null) {\n    this.DeleteFromSEL(horzEdge);\n    this.ProcessHorizontal(horzEdge, isTopOfScanbeam);\n    horzEdge = this.m_SortedEdges;\n  }\n};\n\nClipperLib.Clipper.prototype.GetHorzDirection = function (HorzEdge, $var) {\n  if (HorzEdge.Bot.X < HorzEdge.Top.X) {\n    $var.Left = HorzEdge.Bot.X;\n    $var.Right = HorzEdge.Top.X;\n    $var.Dir = ClipperLib.Direction.dLeftToRight;\n  } else {\n    $var.Left = HorzEdge.Top.X;\n    $var.Right = HorzEdge.Bot.X;\n    $var.Dir = ClipperLib.Direction.dRightToLeft;\n  }\n};\n\nClipperLib.Clipper.prototype.PrepareHorzJoins = function (horzEdge, isTopOfScanbeam) {\n  //get the last Op for this horizontal edge\n  //the point may be anywhere along the horizontal ...\n  var outPt = this.m_PolyOuts[horzEdge.OutIdx].Pts;\n  if (horzEdge.Side != ClipperLib.EdgeSide.esLeft) outPt = outPt.Prev; //First, match up overlapping horizontal edges (eg when one polygon's\n  //intermediate horz edge overlaps an intermediate horz edge of another, or\n  //when one polygon sits on top of another) ...\n  //for (var i = 0, ilen = this.m_GhostJoins.length; i < ilen; ++i) {\n  //  var j = this.m_GhostJoins[i];\n  //  if (this.HorzSegmentsOverlap(j.OutPt1.Pt, j.OffPt, horzEdge.Bot, horzEdge.Top))\n  //    this.AddJoin(j.OutPt1, outPt, j.OffPt);\n  //}\n  //Also, since horizontal edges at the top of one SB are often removed from\n  //the AEL before we process the horizontal edges at the bottom of the next,\n  //we need to create 'ghost' Join records of 'contrubuting' horizontals that\n  //we can compare with horizontals at the bottom of the next SB.\n\n  if (isTopOfScanbeam) if (ClipperLib.IntPoint.op_Equality(outPt.Pt, horzEdge.Top)) this.AddGhostJoin(outPt, horzEdge.Bot);else this.AddGhostJoin(outPt, horzEdge.Top);\n};\n\nClipperLib.Clipper.prototype.ProcessHorizontal = function (horzEdge, isTopOfScanbeam) {\n  var $var = {\n    Dir: null,\n    Left: null,\n    Right: null\n  };\n  this.GetHorzDirection(horzEdge, $var);\n  var dir = $var.Dir;\n  var horzLeft = $var.Left;\n  var horzRight = $var.Right;\n  var eLastHorz = horzEdge,\n      eMaxPair = null;\n\n  while (eLastHorz.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(eLastHorz.NextInLML)) {\n    eLastHorz = eLastHorz.NextInLML;\n  }\n\n  if (eLastHorz.NextInLML === null) eMaxPair = this.GetMaximaPair(eLastHorz);\n\n  for (;;) {\n    var IsLastHorz = horzEdge == eLastHorz;\n    var e = this.GetNextInAEL(horzEdge, dir);\n\n    while (e !== null) {\n      //Break if we've got to the end of an intermediate horizontal edge ...\n      //nb: Smaller Dx's are to the right of larger Dx's ABOVE the horizontal.\n      if (e.Curr.X == horzEdge.Top.X && horzEdge.NextInLML !== null && e.Dx < horzEdge.NextInLML.Dx) break;\n      var eNext = this.GetNextInAEL(e, dir); //saves eNext for later\n\n      if (dir == ClipperLib.Direction.dLeftToRight && e.Curr.X <= horzRight || dir == ClipperLib.Direction.dRightToLeft && e.Curr.X >= horzLeft) {\n        if (horzEdge.OutIdx >= 0 && horzEdge.WindDelta != 0) this.PrepareHorzJoins(horzEdge, isTopOfScanbeam); //so far we're still in range of the horizontal Edge  but make sure\n        //we're at the last of consec. horizontals when matching with eMaxPair\n\n        if (e == eMaxPair && IsLastHorz) {\n          if (dir == ClipperLib.Direction.dLeftToRight) this.IntersectEdges(horzEdge, e, e.Top, false);else this.IntersectEdges(e, horzEdge, e.Top, false);\n          if (eMaxPair.OutIdx >= 0) ClipperLib.Error(\"ProcessHorizontal error\");\n          return;\n        } else if (dir == ClipperLib.Direction.dLeftToRight) {\n          var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n          this.IntersectEdges(horzEdge, e, Pt, true);\n        } else {\n          var Pt = new ClipperLib.IntPoint(e.Curr.X, horzEdge.Curr.Y);\n          this.IntersectEdges(e, horzEdge, Pt, true);\n        }\n\n        this.SwapPositionsInAEL(horzEdge, e);\n      } else if (dir == ClipperLib.Direction.dLeftToRight && e.Curr.X >= horzRight || dir == ClipperLib.Direction.dRightToLeft && e.Curr.X <= horzLeft) break;\n\n      e = eNext;\n    } //end while\n\n\n    if (horzEdge.OutIdx >= 0 && horzEdge.WindDelta !== 0) this.PrepareHorzJoins(horzEdge, isTopOfScanbeam);\n\n    if (horzEdge.NextInLML !== null && ClipperLib.ClipperBase.IsHorizontal(horzEdge.NextInLML)) {\n      horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n      if (horzEdge.OutIdx >= 0) this.AddOutPt(horzEdge, horzEdge.Bot);\n      var $var = {\n        Dir: dir,\n        Left: horzLeft,\n        Right: horzRight\n      };\n      this.GetHorzDirection(horzEdge, $var);\n      dir = $var.Dir;\n      horzLeft = $var.Left;\n      horzRight = $var.Right;\n    } else break;\n  } //end for (;;)\n\n\n  if (horzEdge.NextInLML !== null) {\n    if (horzEdge.OutIdx >= 0) {\n      var op1 = this.AddOutPt(horzEdge, horzEdge.Top);\n      horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n      if (horzEdge.WindDelta === 0) return; //nb: HorzEdge is no longer horizontal here\n\n      var ePrev = horzEdge.PrevInAEL;\n      var eNext = horzEdge.NextInAEL;\n\n      if (ePrev !== null && ePrev.Curr.X == horzEdge.Bot.X && ePrev.Curr.Y == horzEdge.Bot.Y && ePrev.WindDelta !== 0 && ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y && ClipperLib.ClipperBase.SlopesEqual(horzEdge, ePrev, this.m_UseFullRange)) {\n        var op2 = this.AddOutPt(ePrev, horzEdge.Bot);\n        this.AddJoin(op1, op2, horzEdge.Top);\n      } else if (eNext !== null && eNext.Curr.X == horzEdge.Bot.X && eNext.Curr.Y == horzEdge.Bot.Y && eNext.WindDelta !== 0 && eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y && ClipperLib.ClipperBase.SlopesEqual(horzEdge, eNext, this.m_UseFullRange)) {\n        var op2 = this.AddOutPt(eNext, horzEdge.Bot);\n        this.AddJoin(op1, op2, horzEdge.Top);\n      }\n    } else horzEdge = this.UpdateEdgeIntoAEL(horzEdge);\n  } else if (eMaxPair !== null) {\n    if (eMaxPair.OutIdx >= 0) {\n      if (dir == ClipperLib.Direction.dLeftToRight) this.IntersectEdges(horzEdge, eMaxPair, horzEdge.Top, false);else this.IntersectEdges(eMaxPair, horzEdge, horzEdge.Top, false);\n      if (eMaxPair.OutIdx >= 0) ClipperLib.Error(\"ProcessHorizontal error\");\n    } else {\n      this.DeleteFromAEL(horzEdge);\n      this.DeleteFromAEL(eMaxPair);\n    }\n  } else {\n    if (horzEdge.OutIdx >= 0) this.AddOutPt(horzEdge, horzEdge.Top);\n    this.DeleteFromAEL(horzEdge);\n  }\n};\n\nClipperLib.Clipper.prototype.GetNextInAEL = function (e, Direction) {\n  return Direction == ClipperLib.Direction.dLeftToRight ? e.NextInAEL : e.PrevInAEL;\n};\n\nClipperLib.Clipper.prototype.IsMinima = function (e) {\n  return e !== null && e.Prev.NextInLML != e && e.Next.NextInLML != e;\n};\n\nClipperLib.Clipper.prototype.IsMaxima = function (e, Y) {\n  return e !== null && e.Top.Y == Y && e.NextInLML === null;\n};\n\nClipperLib.Clipper.prototype.IsIntermediate = function (e, Y) {\n  return e.Top.Y == Y && e.NextInLML !== null;\n};\n\nClipperLib.Clipper.prototype.GetMaximaPair = function (e) {\n  var result = null;\n  if (ClipperLib.IntPoint.op_Equality(e.Next.Top, e.Top) && e.Next.NextInLML === null) result = e.Next;else if (ClipperLib.IntPoint.op_Equality(e.Prev.Top, e.Top) && e.Prev.NextInLML === null) result = e.Prev;\n  if (result !== null && (result.OutIdx == -2 || result.NextInAEL == result.PrevInAEL && !ClipperLib.ClipperBase.IsHorizontal(result))) return null;\n  return result;\n};\n\nClipperLib.Clipper.prototype.ProcessIntersections = function (botY, topY) {\n  if (this.m_ActiveEdges == null) return true;\n\n  try {\n    this.BuildIntersectList(botY, topY);\n    if (this.m_IntersectList.length == 0) return true;\n    if (this.m_IntersectList.length == 1 || this.FixupIntersectionOrder()) this.ProcessIntersectList();else return false;\n  } catch ($$e2) {\n    this.m_SortedEdges = null;\n    this.m_IntersectList.length = 0;\n    ClipperLib.Error(\"ProcessIntersections error\");\n  }\n\n  this.m_SortedEdges = null;\n  return true;\n};\n\nClipperLib.Clipper.prototype.BuildIntersectList = function (botY, topY) {\n  if (this.m_ActiveEdges === null) return; //prepare for sorting ...\n\n  var e = this.m_ActiveEdges; //console.log(JSON.stringify(JSON.decycle( e )));\n\n  this.m_SortedEdges = e;\n\n  while (e !== null) {\n    e.PrevInSEL = e.PrevInAEL;\n    e.NextInSEL = e.NextInAEL;\n    e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n    e = e.NextInAEL;\n  } //bubblesort ...\n\n\n  var isModified = true;\n\n  while (isModified && this.m_SortedEdges !== null) {\n    isModified = false;\n    e = this.m_SortedEdges;\n\n    while (e.NextInSEL !== null) {\n      var eNext = e.NextInSEL;\n      var pt = new ClipperLib.IntPoint(); //console.log(\"e.Curr.X: \" + e.Curr.X + \" eNext.Curr.X\" + eNext.Curr.X);\n\n      if (e.Curr.X > eNext.Curr.X) {\n        if (!this.IntersectPoint(e, eNext, pt) && e.Curr.X > eNext.Curr.X + 1) {\n          //console.log(\"e.Curr.X: \"+JSON.stringify(JSON.decycle( e.Curr.X )));\n          //console.log(\"eNext.Curr.X+1: \"+JSON.stringify(JSON.decycle( eNext.Curr.X+1)));\n          ClipperLib.Error(\"Intersection error\");\n        }\n\n        if (pt.Y > botY) {\n          pt.Y = botY;\n          if (Math.abs(e.Dx) > Math.abs(eNext.Dx)) pt.X = ClipperLib.Clipper.TopX(eNext, botY);else pt.X = ClipperLib.Clipper.TopX(e, botY);\n        }\n\n        var newNode = new ClipperLib.IntersectNode();\n        newNode.Edge1 = e;\n        newNode.Edge2 = eNext; //newNode.Pt = pt;\n\n        newNode.Pt.X = pt.X;\n        newNode.Pt.Y = pt.Y;\n        this.m_IntersectList.push(newNode);\n        this.SwapPositionsInSEL(e, eNext);\n        isModified = true;\n      } else e = eNext;\n    }\n\n    if (e.PrevInSEL !== null) e.PrevInSEL.NextInSEL = null;else break;\n  }\n\n  this.m_SortedEdges = null;\n};\n\nClipperLib.Clipper.prototype.EdgesAdjacent = function (inode) {\n  return inode.Edge1.NextInSEL == inode.Edge2 || inode.Edge1.PrevInSEL == inode.Edge2;\n};\n\nClipperLib.Clipper.IntersectNodeSort = function (node1, node2) {\n  //the following typecast is safe because the differences in Pt.Y will\n  //be limited to the height of the scanbeam.\n  return node2.Pt.Y - node1.Pt.Y;\n};\n\nClipperLib.Clipper.prototype.FixupIntersectionOrder = function () {\n  //pre-condition: intersections are sorted bottom-most first.\n  //Now it's crucial that intersections are made only between adjacent edges,\n  //so to ensure this the order of intersections may need adjusting ...\n  this.m_IntersectList.sort(this.m_IntersectNodeComparer);\n  this.CopyAELToSEL();\n  var cnt = this.m_IntersectList.length;\n\n  for (var i = 0; i < cnt; i++) {\n    if (!this.EdgesAdjacent(this.m_IntersectList[i])) {\n      var j = i + 1;\n\n      while (j < cnt && !this.EdgesAdjacent(this.m_IntersectList[j])) {\n        j++;\n      }\n\n      if (j == cnt) return false;\n      var tmp = this.m_IntersectList[i];\n      this.m_IntersectList[i] = this.m_IntersectList[j];\n      this.m_IntersectList[j] = tmp;\n    }\n\n    this.SwapPositionsInSEL(this.m_IntersectList[i].Edge1, this.m_IntersectList[i].Edge2);\n  }\n\n  return true;\n};\n\nClipperLib.Clipper.prototype.ProcessIntersectList = function () {\n  for (var i = 0, ilen = this.m_IntersectList.length; i < ilen; i++) {\n    var iNode = this.m_IntersectList[i];\n    this.IntersectEdges(iNode.Edge1, iNode.Edge2, iNode.Pt, true);\n    this.SwapPositionsInAEL(iNode.Edge1, iNode.Edge2);\n  }\n\n  this.m_IntersectList.length = 0;\n};\n/*\n--------------------------------\nRound speedtest: http://jsperf.com/fastest-round\n--------------------------------\n*/\n\n\nvar R1 = function R1(a) {\n  return a < 0 ? Math.ceil(a - 0.5) : Math.round(a);\n};\n\nvar R2 = function R2(a) {\n  return a < 0 ? Math.ceil(a - 0.5) : Math.floor(a + 0.5);\n};\n\nvar R3 = function R3(a) {\n  return a < 0 ? -Math.round(Math.abs(a)) : Math.round(a);\n};\n\nvar R4 = function R4(a) {\n  if (a < 0) {\n    a -= 0.5;\n    return a < -2147483648 ? Math.ceil(a) : a | 0;\n  } else {\n    a += 0.5;\n    return a > 2147483647 ? Math.floor(a) : a | 0;\n  }\n};\n\nif (browser.msie) ClipperLib.Clipper.Round = R1;else if (browser.chromium) ClipperLib.Clipper.Round = R3;else if (browser.safari) ClipperLib.Clipper.Round = R4;else ClipperLib.Clipper.Round = R2; // eg. browser.chrome || browser.firefox || browser.opera\n\nClipperLib.Clipper.TopX = function (edge, currentY) {\n  //if (edge.Bot == edge.Curr) alert (\"edge.Bot = edge.Curr\");\n  //if (edge.Bot == edge.Top) alert (\"edge.Bot = edge.Top\");\n  if (currentY == edge.Top.Y) return edge.Top.X;\n  return edge.Bot.X + ClipperLib.Clipper.Round(edge.Dx * (currentY - edge.Bot.Y));\n};\n\nClipperLib.Clipper.prototype.IntersectPoint = function (edge1, edge2, ip) {\n  ip.X = 0;\n  ip.Y = 0;\n  var b1, b2; //nb: with very large coordinate values, it's possible for SlopesEqual() to \n  //return false but for the edge.Dx value be equal due to double precision rounding.\n\n  if (ClipperLib.ClipperBase.SlopesEqual(edge1, edge2, this.m_UseFullRange) || edge1.Dx == edge2.Dx) {\n    if (edge2.Bot.Y > edge1.Bot.Y) {\n      ip.X = edge2.Bot.X;\n      ip.Y = edge2.Bot.Y;\n    } else {\n      ip.X = edge1.Bot.X;\n      ip.Y = edge1.Bot.Y;\n    }\n\n    return false;\n  } else if (edge1.Delta.X === 0) {\n    ip.X = edge1.Bot.X;\n\n    if (ClipperLib.ClipperBase.IsHorizontal(edge2)) {\n      ip.Y = edge2.Bot.Y;\n    } else {\n      b2 = edge2.Bot.Y - edge2.Bot.X / edge2.Dx;\n      ip.Y = ClipperLib.Clipper.Round(ip.X / edge2.Dx + b2);\n    }\n  } else if (edge2.Delta.X === 0) {\n    ip.X = edge2.Bot.X;\n\n    if (ClipperLib.ClipperBase.IsHorizontal(edge1)) {\n      ip.Y = edge1.Bot.Y;\n    } else {\n      b1 = edge1.Bot.Y - edge1.Bot.X / edge1.Dx;\n      ip.Y = ClipperLib.Clipper.Round(ip.X / edge1.Dx + b1);\n    }\n  } else {\n    b1 = edge1.Bot.X - edge1.Bot.Y * edge1.Dx;\n    b2 = edge2.Bot.X - edge2.Bot.Y * edge2.Dx;\n    var q = (b2 - b1) / (edge1.Dx - edge2.Dx);\n    ip.Y = ClipperLib.Clipper.Round(q);\n    if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx)) ip.X = ClipperLib.Clipper.Round(edge1.Dx * q + b1);else ip.X = ClipperLib.Clipper.Round(edge2.Dx * q + b2);\n  }\n\n  if (ip.Y < edge1.Top.Y || ip.Y < edge2.Top.Y) {\n    if (edge1.Top.Y > edge2.Top.Y) {\n      ip.Y = edge1.Top.Y;\n      ip.X = ClipperLib.Clipper.TopX(edge2, edge1.Top.Y);\n      return ip.X < edge1.Top.X;\n    } else ip.Y = edge2.Top.Y;\n\n    if (Math.abs(edge1.Dx) < Math.abs(edge2.Dx)) ip.X = ClipperLib.Clipper.TopX(edge1, ip.Y);else ip.X = ClipperLib.Clipper.TopX(edge2, ip.Y);\n  }\n\n  return true;\n};\n\nClipperLib.Clipper.prototype.ProcessEdgesAtTopOfScanbeam = function (topY) {\n  var e = this.m_ActiveEdges;\n\n  while (e !== null) {\n    //1. process maxima, treating them as if they're 'bent' horizontal edges,\n    //   but exclude maxima with horizontal edges. nb: e can't be a horizontal.\n    var IsMaximaEdge = this.IsMaxima(e, topY);\n\n    if (IsMaximaEdge) {\n      var eMaxPair = this.GetMaximaPair(e);\n      IsMaximaEdge = eMaxPair === null || !ClipperLib.ClipperBase.IsHorizontal(eMaxPair);\n    }\n\n    if (IsMaximaEdge) {\n      var ePrev = e.PrevInAEL;\n      this.DoMaxima(e);\n      if (ePrev === null) e = this.m_ActiveEdges;else e = ePrev.NextInAEL;\n    } else {\n      //2. promote horizontal edges, otherwise update Curr.X and Curr.Y ...\n      if (this.IsIntermediate(e, topY) && ClipperLib.ClipperBase.IsHorizontal(e.NextInLML)) {\n        e = this.UpdateEdgeIntoAEL(e);\n        if (e.OutIdx >= 0) this.AddOutPt(e, e.Bot);\n        this.AddEdgeToSEL(e);\n      } else {\n        e.Curr.X = ClipperLib.Clipper.TopX(e, topY);\n        e.Curr.Y = topY;\n      }\n\n      if (this.StrictlySimple) {\n        var ePrev = e.PrevInAEL;\n\n        if (e.OutIdx >= 0 && e.WindDelta !== 0 && ePrev !== null && ePrev.OutIdx >= 0 && ePrev.Curr.X == e.Curr.X && ePrev.WindDelta !== 0) {\n          var op = this.AddOutPt(ePrev, e.Curr);\n          var op2 = this.AddOutPt(e, e.Curr);\n          this.AddJoin(op, op2, e.Curr); //StrictlySimple (type-3) join\n        }\n      }\n\n      e = e.NextInAEL;\n    }\n  } //3. Process horizontals at the Top of the scanbeam ...\n\n\n  this.ProcessHorizontals(true); //4. Promote intermediate vertices ...\n\n  e = this.m_ActiveEdges;\n\n  while (e !== null) {\n    if (this.IsIntermediate(e, topY)) {\n      var op = null;\n      if (e.OutIdx >= 0) op = this.AddOutPt(e, e.Top);\n      e = this.UpdateEdgeIntoAEL(e); //if output polygons share an edge, they'll need joining later ...\n\n      var ePrev = e.PrevInAEL;\n      var eNext = e.NextInAEL;\n\n      if (ePrev !== null && ePrev.Curr.X == e.Bot.X && ePrev.Curr.Y == e.Bot.Y && op !== null && ePrev.OutIdx >= 0 && ePrev.Curr.Y > ePrev.Top.Y && ClipperLib.ClipperBase.SlopesEqual(e, ePrev, this.m_UseFullRange) && e.WindDelta !== 0 && ePrev.WindDelta !== 0) {\n        var op2 = this.AddOutPt(ePrev, e.Bot);\n        this.AddJoin(op, op2, e.Top);\n      } else if (eNext !== null && eNext.Curr.X == e.Bot.X && eNext.Curr.Y == e.Bot.Y && op !== null && eNext.OutIdx >= 0 && eNext.Curr.Y > eNext.Top.Y && ClipperLib.ClipperBase.SlopesEqual(e, eNext, this.m_UseFullRange) && e.WindDelta !== 0 && eNext.WindDelta !== 0) {\n        var op2 = this.AddOutPt(eNext, e.Bot);\n        this.AddJoin(op, op2, e.Top);\n      }\n    }\n\n    e = e.NextInAEL;\n  }\n};\n\nClipperLib.Clipper.prototype.DoMaxima = function (e) {\n  var eMaxPair = this.GetMaximaPair(e);\n\n  if (eMaxPair === null) {\n    if (e.OutIdx >= 0) this.AddOutPt(e, e.Top);\n    this.DeleteFromAEL(e);\n    return;\n  }\n\n  var eNext = e.NextInAEL;\n  var use_lines = true;\n\n  while (eNext !== null && eNext != eMaxPair) {\n    this.IntersectEdges(e, eNext, e.Top, true);\n    this.SwapPositionsInAEL(e, eNext);\n    eNext = e.NextInAEL;\n  }\n\n  if (e.OutIdx == -1 && eMaxPair.OutIdx == -1) {\n    this.DeleteFromAEL(e);\n    this.DeleteFromAEL(eMaxPair);\n  } else if (e.OutIdx >= 0 && eMaxPair.OutIdx >= 0) {\n    this.IntersectEdges(e, eMaxPair, e.Top, false);\n  } else if (use_lines && e.WindDelta === 0) {\n    if (e.OutIdx >= 0) {\n      this.AddOutPt(e, e.Top);\n      e.OutIdx = -1;\n    }\n\n    this.DeleteFromAEL(e);\n\n    if (eMaxPair.OutIdx >= 0) {\n      this.AddOutPt(eMaxPair, e.Top);\n      eMaxPair.OutIdx = -1;\n    }\n\n    this.DeleteFromAEL(eMaxPair);\n  } else ClipperLib.Error(\"DoMaxima error\");\n};\n\nClipperLib.Clipper.ReversePaths = function (polys) {\n  for (var i = 0, len = polys.length; i < len; i++) {\n    polys[i].reverse();\n  }\n};\n\nClipperLib.Clipper.Orientation = function (poly) {\n  return ClipperLib.Clipper.Area(poly) >= 0;\n};\n\nClipperLib.Clipper.prototype.PointCount = function (pts) {\n  if (pts === null) return 0;\n  var result = 0;\n  var p = pts;\n\n  do {\n    result++;\n    p = p.Next;\n  } while (p != pts);\n\n  return result;\n};\n\nClipperLib.Clipper.prototype.BuildResult = function (polyg) {\n  ClipperLib.Clear(polyg);\n\n  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++) {\n    var outRec = this.m_PolyOuts[i];\n    if (outRec.Pts === null) continue;\n    var p = outRec.Pts.Prev;\n    var cnt = this.PointCount(p);\n    if (cnt < 2) continue;\n    var pg = new Array(cnt);\n\n    for (var j = 0; j < cnt; j++) {\n      pg[j] = p.Pt;\n      p = p.Prev;\n    }\n\n    polyg.push(pg);\n  }\n};\n\nClipperLib.Clipper.prototype.BuildResult2 = function (polytree) {\n  polytree.Clear(); //add each output polygon/contour to polytree ...\n  //polytree.m_AllPolys.set_Capacity(this.m_PolyOuts.length);\n\n  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++) {\n    var outRec = this.m_PolyOuts[i];\n    var cnt = this.PointCount(outRec.Pts);\n    if (outRec.IsOpen && cnt < 2 || !outRec.IsOpen && cnt < 3) continue;\n    this.FixHoleLinkage(outRec);\n    var pn = new ClipperLib.PolyNode();\n    polytree.m_AllPolys.push(pn);\n    outRec.PolyNode = pn;\n    pn.m_polygon.length = cnt;\n    var op = outRec.Pts.Prev;\n\n    for (var j = 0; j < cnt; j++) {\n      pn.m_polygon[j] = op.Pt;\n      op = op.Prev;\n    }\n  } //fixup PolyNode links etc ...\n  //polytree.m_Childs.set_Capacity(this.m_PolyOuts.length);\n\n\n  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++) {\n    var outRec = this.m_PolyOuts[i];\n    if (outRec.PolyNode === null) continue;else if (outRec.IsOpen) {\n      outRec.PolyNode.IsOpen = true;\n      polytree.AddChild(outRec.PolyNode);\n    } else if (outRec.FirstLeft !== null && outRec.FirstLeft.PolyNode != null) outRec.FirstLeft.PolyNode.AddChild(outRec.PolyNode);else polytree.AddChild(outRec.PolyNode);\n  }\n};\n\nClipperLib.Clipper.prototype.FixupOutPolygon = function (outRec) {\n  //FixupOutPolygon() - removes duplicate points and simplifies consecutive\n  //parallel edges by removing the middle vertex.\n  var lastOK = null;\n  outRec.BottomPt = null;\n  var pp = outRec.Pts;\n\n  for (;;) {\n    if (pp.Prev == pp || pp.Prev == pp.Next) {\n      this.DisposeOutPts(pp);\n      outRec.Pts = null;\n      return;\n    } //test for duplicate points and collinear edges ...\n\n\n    if (ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Next.Pt) || ClipperLib.IntPoint.op_Equality(pp.Pt, pp.Prev.Pt) || ClipperLib.ClipperBase.SlopesEqual(pp.Prev.Pt, pp.Pt, pp.Next.Pt, this.m_UseFullRange) && (!this.PreserveCollinear || !this.Pt2IsBetweenPt1AndPt3(pp.Prev.Pt, pp.Pt, pp.Next.Pt))) {\n      lastOK = null;\n      var tmp = pp;\n      pp.Prev.Next = pp.Next;\n      pp.Next.Prev = pp.Prev;\n      pp = pp.Prev;\n      tmp = null;\n    } else if (pp == lastOK) break;else {\n      if (lastOK === null) lastOK = pp;\n      pp = pp.Next;\n    }\n  }\n\n  outRec.Pts = pp;\n};\n\nClipperLib.Clipper.prototype.DupOutPt = function (outPt, InsertAfter) {\n  var result = new ClipperLib.OutPt(); //result.Pt = outPt.Pt;\n\n  result.Pt.X = outPt.Pt.X;\n  result.Pt.Y = outPt.Pt.Y;\n  result.Idx = outPt.Idx;\n\n  if (InsertAfter) {\n    result.Next = outPt.Next;\n    result.Prev = outPt;\n    outPt.Next.Prev = result;\n    outPt.Next = result;\n  } else {\n    result.Prev = outPt.Prev;\n    result.Next = outPt;\n    outPt.Prev.Next = result;\n    outPt.Prev = result;\n  }\n\n  return result;\n};\n\nClipperLib.Clipper.prototype.GetOverlap = function (a1, a2, b1, b2, $val) {\n  if (a1 < a2) {\n    if (b1 < b2) {\n      $val.Left = Math.max(a1, b1);\n      $val.Right = Math.min(a2, b2);\n    } else {\n      $val.Left = Math.max(a1, b2);\n      $val.Right = Math.min(a2, b1);\n    }\n  } else {\n    if (b1 < b2) {\n      $val.Left = Math.max(a2, b1);\n      $val.Right = Math.min(a1, b2);\n    } else {\n      $val.Left = Math.max(a2, b2);\n      $val.Right = Math.min(a1, b1);\n    }\n  }\n\n  return $val.Left < $val.Right;\n};\n\nClipperLib.Clipper.prototype.JoinHorz = function (op1, op1b, op2, op2b, Pt, DiscardLeft) {\n  var Dir1 = op1.Pt.X > op1b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight;\n  var Dir2 = op2.Pt.X > op2b.Pt.X ? ClipperLib.Direction.dRightToLeft : ClipperLib.Direction.dLeftToRight;\n  if (Dir1 == Dir2) return false; //When DiscardLeft, we want Op1b to be on the Left of Op1, otherwise we\n  //want Op1b to be on the Right. (And likewise with Op2 and Op2b.)\n  //So, to facilitate this while inserting Op1b and Op2b ...\n  //when DiscardLeft, make sure we're AT or RIGHT of Pt before adding Op1b,\n  //otherwise make sure we're AT or LEFT of Pt. (Likewise with Op2b.)\n\n  if (Dir1 == ClipperLib.Direction.dLeftToRight) {\n    while (op1.Next.Pt.X <= Pt.X && op1.Next.Pt.X >= op1.Pt.X && op1.Next.Pt.Y == Pt.Y) {\n      op1 = op1.Next;\n    }\n\n    if (DiscardLeft && op1.Pt.X != Pt.X) op1 = op1.Next;\n    op1b = this.DupOutPt(op1, !DiscardLeft);\n\n    if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt)) {\n      op1 = op1b; //op1.Pt = Pt;\n\n      op1.Pt.X = Pt.X;\n      op1.Pt.Y = Pt.Y;\n      op1b = this.DupOutPt(op1, !DiscardLeft);\n    }\n  } else {\n    while (op1.Next.Pt.X >= Pt.X && op1.Next.Pt.X <= op1.Pt.X && op1.Next.Pt.Y == Pt.Y) {\n      op1 = op1.Next;\n    }\n\n    if (!DiscardLeft && op1.Pt.X != Pt.X) op1 = op1.Next;\n    op1b = this.DupOutPt(op1, DiscardLeft);\n\n    if (ClipperLib.IntPoint.op_Inequality(op1b.Pt, Pt)) {\n      op1 = op1b; //op1.Pt = Pt;\n\n      op1.Pt.X = Pt.X;\n      op1.Pt.Y = Pt.Y;\n      op1b = this.DupOutPt(op1, DiscardLeft);\n    }\n  }\n\n  if (Dir2 == ClipperLib.Direction.dLeftToRight) {\n    while (op2.Next.Pt.X <= Pt.X && op2.Next.Pt.X >= op2.Pt.X && op2.Next.Pt.Y == Pt.Y) {\n      op2 = op2.Next;\n    }\n\n    if (DiscardLeft && op2.Pt.X != Pt.X) op2 = op2.Next;\n    op2b = this.DupOutPt(op2, !DiscardLeft);\n\n    if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt)) {\n      op2 = op2b; //op2.Pt = Pt;\n\n      op2.Pt.X = Pt.X;\n      op2.Pt.Y = Pt.Y;\n      op2b = this.DupOutPt(op2, !DiscardLeft);\n    }\n  } else {\n    while (op2.Next.Pt.X >= Pt.X && op2.Next.Pt.X <= op2.Pt.X && op2.Next.Pt.Y == Pt.Y) {\n      op2 = op2.Next;\n    }\n\n    if (!DiscardLeft && op2.Pt.X != Pt.X) op2 = op2.Next;\n    op2b = this.DupOutPt(op2, DiscardLeft);\n\n    if (ClipperLib.IntPoint.op_Inequality(op2b.Pt, Pt)) {\n      op2 = op2b; //op2.Pt = Pt;\n\n      op2.Pt.X = Pt.X;\n      op2.Pt.Y = Pt.Y;\n      op2b = this.DupOutPt(op2, DiscardLeft);\n    }\n  }\n\n  if (Dir1 == ClipperLib.Direction.dLeftToRight == DiscardLeft) {\n    op1.Prev = op2;\n    op2.Next = op1;\n    op1b.Next = op2b;\n    op2b.Prev = op1b;\n  } else {\n    op1.Next = op2;\n    op2.Prev = op1;\n    op1b.Prev = op2b;\n    op2b.Next = op1b;\n  }\n\n  return true;\n};\n\nClipperLib.Clipper.prototype.JoinPoints = function (j, outRec1, outRec2) {\n  var op1 = j.OutPt1,\n      op1b = new ClipperLib.OutPt();\n  var op2 = j.OutPt2,\n      op2b = new ClipperLib.OutPt(); //There are 3 kinds of joins for output polygons ...\n  //1. Horizontal joins where Join.OutPt1 & Join.OutPt2 are a vertices anywhere\n  //along (horizontal) collinear edges (& Join.OffPt is on the same horizontal).\n  //2. Non-horizontal joins where Join.OutPt1 & Join.OutPt2 are at the same\n  //location at the Bottom of the overlapping segment (& Join.OffPt is above).\n  //3. StrictlySimple joins where edges touch but are not collinear and where\n  //Join.OutPt1, Join.OutPt2 & Join.OffPt all share the same point.\n\n  var isHorizontal = j.OutPt1.Pt.Y == j.OffPt.Y;\n\n  if (isHorizontal && ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt1.Pt) && ClipperLib.IntPoint.op_Equality(j.OffPt, j.OutPt2.Pt)) {\n    //Strictly Simple join ...\n    op1b = j.OutPt1.Next;\n\n    while (op1b != op1 && ClipperLib.IntPoint.op_Equality(op1b.Pt, j.OffPt)) {\n      op1b = op1b.Next;\n    }\n\n    var reverse1 = op1b.Pt.Y > j.OffPt.Y;\n    op2b = j.OutPt2.Next;\n\n    while (op2b != op2 && ClipperLib.IntPoint.op_Equality(op2b.Pt, j.OffPt)) {\n      op2b = op2b.Next;\n    }\n\n    var reverse2 = op2b.Pt.Y > j.OffPt.Y;\n    if (reverse1 == reverse2) return false;\n\n    if (reverse1) {\n      op1b = this.DupOutPt(op1, false);\n      op2b = this.DupOutPt(op2, true);\n      op1.Prev = op2;\n      op2.Next = op1;\n      op1b.Next = op2b;\n      op2b.Prev = op1b;\n      j.OutPt1 = op1;\n      j.OutPt2 = op1b;\n      return true;\n    } else {\n      op1b = this.DupOutPt(op1, true);\n      op2b = this.DupOutPt(op2, false);\n      op1.Next = op2;\n      op2.Prev = op1;\n      op1b.Prev = op2b;\n      op2b.Next = op1b;\n      j.OutPt1 = op1;\n      j.OutPt2 = op1b;\n      return true;\n    }\n  } else if (isHorizontal) {\n    //treat horizontal joins differently to non-horizontal joins since with\n    //them we're not yet sure where the overlapping is. OutPt1.Pt & OutPt2.Pt\n    //may be anywhere along the horizontal edge.\n    op1b = op1;\n\n    while (op1.Prev.Pt.Y == op1.Pt.Y && op1.Prev != op1b && op1.Prev != op2) {\n      op1 = op1.Prev;\n    }\n\n    while (op1b.Next.Pt.Y == op1b.Pt.Y && op1b.Next != op1 && op1b.Next != op2) {\n      op1b = op1b.Next;\n    }\n\n    if (op1b.Next == op1 || op1b.Next == op2) return false; //a flat 'polygon'\n\n    op2b = op2;\n\n    while (op2.Prev.Pt.Y == op2.Pt.Y && op2.Prev != op2b && op2.Prev != op1b) {\n      op2 = op2.Prev;\n    }\n\n    while (op2b.Next.Pt.Y == op2b.Pt.Y && op2b.Next != op2 && op2b.Next != op1) {\n      op2b = op2b.Next;\n    }\n\n    if (op2b.Next == op2 || op2b.Next == op1) return false; //a flat 'polygon'\n    //Op1 -. Op1b & Op2 -. Op2b are the extremites of the horizontal edges\n\n    var $val = {\n      Left: null,\n      Right: null\n    };\n    if (!this.GetOverlap(op1.Pt.X, op1b.Pt.X, op2.Pt.X, op2b.Pt.X, $val)) return false;\n    var Left = $val.Left;\n    var Right = $val.Right; //DiscardLeftSide: when overlapping edges are joined, a spike will created\n    //which needs to be cleaned up. However, we don't want Op1 or Op2 caught up\n    //on the discard Side as either may still be needed for other joins ...\n\n    var Pt = new ClipperLib.IntPoint();\n    var DiscardLeftSide;\n\n    if (op1.Pt.X >= Left && op1.Pt.X <= Right) {\n      //Pt = op1.Pt;\n      Pt.X = op1.Pt.X;\n      Pt.Y = op1.Pt.Y;\n      DiscardLeftSide = op1.Pt.X > op1b.Pt.X;\n    } else if (op2.Pt.X >= Left && op2.Pt.X <= Right) {\n      //Pt = op2.Pt;\n      Pt.X = op2.Pt.X;\n      Pt.Y = op2.Pt.Y;\n      DiscardLeftSide = op2.Pt.X > op2b.Pt.X;\n    } else if (op1b.Pt.X >= Left && op1b.Pt.X <= Right) {\n      //Pt = op1b.Pt;\n      Pt.X = op1b.Pt.X;\n      Pt.Y = op1b.Pt.Y;\n      DiscardLeftSide = op1b.Pt.X > op1.Pt.X;\n    } else {\n      //Pt = op2b.Pt;\n      Pt.X = op2b.Pt.X;\n      Pt.Y = op2b.Pt.Y;\n      DiscardLeftSide = op2b.Pt.X > op2.Pt.X;\n    }\n\n    j.OutPt1 = op1;\n    j.OutPt2 = op2;\n    return this.JoinHorz(op1, op1b, op2, op2b, Pt, DiscardLeftSide);\n  } else {\n    //nb: For non-horizontal joins ...\n    //    1. Jr.OutPt1.Pt.Y == Jr.OutPt2.Pt.Y\n    //    2. Jr.OutPt1.Pt > Jr.OffPt.Y\n    //make sure the polygons are correctly oriented ...\n    op1b = op1.Next;\n\n    while (ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt) && op1b != op1) {\n      op1b = op1b.Next;\n    }\n\n    var Reverse1 = op1b.Pt.Y > op1.Pt.Y || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange);\n\n    if (Reverse1) {\n      op1b = op1.Prev;\n\n      while (ClipperLib.IntPoint.op_Equality(op1b.Pt, op1.Pt) && op1b != op1) {\n        op1b = op1b.Prev;\n      }\n\n      if (op1b.Pt.Y > op1.Pt.Y || !ClipperLib.ClipperBase.SlopesEqual(op1.Pt, op1b.Pt, j.OffPt, this.m_UseFullRange)) return false;\n    }\n\n    op2b = op2.Next;\n\n    while (ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt) && op2b != op2) {\n      op2b = op2b.Next;\n    }\n\n    var Reverse2 = op2b.Pt.Y > op2.Pt.Y || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange);\n\n    if (Reverse2) {\n      op2b = op2.Prev;\n\n      while (ClipperLib.IntPoint.op_Equality(op2b.Pt, op2.Pt) && op2b != op2) {\n        op2b = op2b.Prev;\n      }\n\n      if (op2b.Pt.Y > op2.Pt.Y || !ClipperLib.ClipperBase.SlopesEqual(op2.Pt, op2b.Pt, j.OffPt, this.m_UseFullRange)) return false;\n    }\n\n    if (op1b == op1 || op2b == op2 || op1b == op2b || outRec1 == outRec2 && Reverse1 == Reverse2) return false;\n\n    if (Reverse1) {\n      op1b = this.DupOutPt(op1, false);\n      op2b = this.DupOutPt(op2, true);\n      op1.Prev = op2;\n      op2.Next = op1;\n      op1b.Next = op2b;\n      op2b.Prev = op1b;\n      j.OutPt1 = op1;\n      j.OutPt2 = op1b;\n      return true;\n    } else {\n      op1b = this.DupOutPt(op1, true);\n      op2b = this.DupOutPt(op2, false);\n      op1.Next = op2;\n      op2.Prev = op1;\n      op1b.Prev = op2b;\n      op2b.Next = op1b;\n      j.OutPt1 = op1;\n      j.OutPt2 = op1b;\n      return true;\n    }\n  }\n};\n\nClipperLib.Clipper.GetBounds = function (paths) {\n  var i = 0,\n      cnt = paths.length;\n\n  while (i < cnt && paths[i].length == 0) {\n    i++;\n  }\n\n  if (i == cnt) return new ClipperLib.IntRect(0, 0, 0, 0);\n  var result = new ClipperLib.IntRect();\n  result.left = paths[i][0].X;\n  result.right = result.left;\n  result.top = paths[i][0].Y;\n  result.bottom = result.top;\n\n  for (; i < cnt; i++) {\n    for (var j = 0, jlen = paths[i].length; j < jlen; j++) {\n      if (paths[i][j].X < result.left) result.left = paths[i][j].X;else if (paths[i][j].X > result.right) result.right = paths[i][j].X;\n      if (paths[i][j].Y < result.top) result.top = paths[i][j].Y;else if (paths[i][j].Y > result.bottom) result.bottom = paths[i][j].Y;\n    }\n  }\n\n  return result;\n};\n\nClipperLib.Clipper.prototype.GetBounds2 = function (ops) {\n  var opStart = ops;\n  var result = new ClipperLib.IntRect();\n  result.left = ops.Pt.X;\n  result.right = ops.Pt.X;\n  result.top = ops.Pt.Y;\n  result.bottom = ops.Pt.Y;\n  ops = ops.Next;\n\n  while (ops != opStart) {\n    if (ops.Pt.X < result.left) result.left = ops.Pt.X;\n    if (ops.Pt.X > result.right) result.right = ops.Pt.X;\n    if (ops.Pt.Y < result.top) result.top = ops.Pt.Y;\n    if (ops.Pt.Y > result.bottom) result.bottom = ops.Pt.Y;\n    ops = ops.Next;\n  }\n\n  return result;\n};\n\nClipperLib.Clipper.PointInPolygon = function (pt, path) {\n  //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n  //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n  var result = 0,\n      cnt = path.length;\n  if (cnt < 3) return 0;\n  var ip = path[0];\n\n  for (var i = 1; i <= cnt; ++i) {\n    var ipNext = i == cnt ? path[0] : path[i];\n\n    if (ipNext.Y == pt.Y) {\n      if (ipNext.X == pt.X || ip.Y == pt.Y && ipNext.X > pt.X == ip.X < pt.X) return -1;\n    }\n\n    if (ip.Y < pt.Y != ipNext.Y < pt.Y) {\n      if (ip.X >= pt.X) {\n        if (ipNext.X > pt.X) result = 1 - result;else {\n          var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n          if (d == 0) return -1;else if (d > 0 == ipNext.Y > ip.Y) result = 1 - result;\n        }\n      } else {\n        if (ipNext.X > pt.X) {\n          var d = (ip.X - pt.X) * (ipNext.Y - pt.Y) - (ipNext.X - pt.X) * (ip.Y - pt.Y);\n          if (d == 0) return -1;else if (d > 0 == ipNext.Y > ip.Y) result = 1 - result;\n        }\n      }\n    }\n\n    ip = ipNext;\n  }\n\n  return result;\n};\n\nClipperLib.Clipper.prototype.PointInPolygon = function (pt, op) {\n  //returns 0 if false, +1 if true, -1 if pt ON polygon boundary\n  //http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.88.5498&rep=rep1&type=pdf\n  var result = 0;\n  var startOp = op;\n\n  for (;;) {\n    var poly0x = op.Pt.X,\n        poly0y = op.Pt.Y;\n    var poly1x = op.Next.Pt.X,\n        poly1y = op.Next.Pt.Y;\n\n    if (poly1y == pt.Y) {\n      if (poly1x == pt.X || poly0y == pt.Y && poly1x > pt.X == poly0x < pt.X) return -1;\n    }\n\n    if (poly0y < pt.Y != poly1y < pt.Y) {\n      if (poly0x >= pt.X) {\n        if (poly1x > pt.X) result = 1 - result;else {\n          var d = (poly0x - pt.X) * (poly1y - pt.Y) - (poly1x - pt.X) * (poly0y - pt.Y);\n          if (d == 0) return -1;\n          if (d > 0 == poly1y > poly0y) result = 1 - result;\n        }\n      } else {\n        if (poly1x > pt.X) {\n          var d = (poly0x - pt.X) * (poly1y - pt.Y) - (poly1x - pt.X) * (poly0y - pt.Y);\n          if (d == 0) return -1;\n          if (d > 0 == poly1y > poly0y) result = 1 - result;\n        }\n      }\n    }\n\n    op = op.Next;\n    if (startOp == op) break;\n  }\n\n  return result;\n};\n\nClipperLib.Clipper.prototype.Poly2ContainsPoly1 = function (outPt1, outPt2) {\n  var op = outPt1;\n\n  do {\n    var res = this.PointInPolygon(op.Pt, outPt2);\n    if (res >= 0) return res != 0;\n    op = op.Next;\n  } while (op != outPt1);\n\n  return true;\n};\n\nClipperLib.Clipper.prototype.FixupFirstLefts1 = function (OldOutRec, NewOutRec) {\n  for (var i = 0, ilen = this.m_PolyOuts.length; i < ilen; i++) {\n    var outRec = this.m_PolyOuts[i];\n\n    if (outRec.Pts !== null && outRec.FirstLeft == OldOutRec) {\n      if (this.Poly2ContainsPoly1(outRec.Pts, NewOutRec.Pts)) outRec.FirstLeft = NewOutRec;\n    }\n  }\n};\n\nClipperLib.Clipper.prototype.FixupFirstLefts2 = function (OldOutRec, NewOutRec) {\n  for (var $i2 = 0, $t2 = this.m_PolyOuts, $l2 = $t2.length, outRec = $t2[$i2]; $i2 < $l2; $i2++, outRec = $t2[$i2]) {\n    if (outRec.FirstLeft == OldOutRec) outRec.FirstLeft = NewOutRec;\n  }\n};\n\nClipperLib.Clipper.ParseFirstLeft = function (FirstLeft) {\n  while (FirstLeft != null && FirstLeft.Pts == null) {\n    FirstLeft = FirstLeft.FirstLeft;\n  }\n\n  return FirstLeft;\n};\n\nClipperLib.Clipper.prototype.JoinCommonEdges = function () {\n  for (var i = 0, ilen = this.m_Joins.length; i < ilen; i++) {\n    var join = this.m_Joins[i];\n    var outRec1 = this.GetOutRec(join.OutPt1.Idx);\n    var outRec2 = this.GetOutRec(join.OutPt2.Idx);\n    if (outRec1.Pts == null || outRec2.Pts == null) continue; //get the polygon fragment with the correct hole state (FirstLeft)\n    //before calling JoinPoints() ...\n\n    var holeStateRec;\n    if (outRec1 == outRec2) holeStateRec = outRec1;else if (this.Param1RightOfParam2(outRec1, outRec2)) holeStateRec = outRec2;else if (this.Param1RightOfParam2(outRec2, outRec1)) holeStateRec = outRec1;else holeStateRec = this.GetLowermostRec(outRec1, outRec2);\n    if (!this.JoinPoints(join, outRec1, outRec2)) continue;\n\n    if (outRec1 == outRec2) {\n      //instead of joining two polygons, we've just created a new one by\n      //splitting one polygon into two.\n      outRec1.Pts = join.OutPt1;\n      outRec1.BottomPt = null;\n      outRec2 = this.CreateOutRec();\n      outRec2.Pts = join.OutPt2; //update all OutRec2.Pts Idx's ...\n\n      this.UpdateOutPtIdxs(outRec2); //We now need to check every OutRec.FirstLeft pointer. If it points\n      //to OutRec1 it may need to point to OutRec2 instead ...\n\n      if (this.m_UsingPolyTree) for (var j = 0, jlen = this.m_PolyOuts.length; j < jlen - 1; j++) {\n        var oRec = this.m_PolyOuts[j];\n        if (oRec.Pts == null || ClipperLib.Clipper.ParseFirstLeft(oRec.FirstLeft) != outRec1 || oRec.IsHole == outRec1.IsHole) continue;\n        if (this.Poly2ContainsPoly1(oRec.Pts, join.OutPt2)) oRec.FirstLeft = outRec2;\n      }\n\n      if (this.Poly2ContainsPoly1(outRec2.Pts, outRec1.Pts)) {\n        //outRec2 is contained by outRec1 ...\n        outRec2.IsHole = !outRec1.IsHole;\n        outRec2.FirstLeft = outRec1; //fixup FirstLeft pointers that may need reassigning to OutRec1\n\n        if (this.m_UsingPolyTree) this.FixupFirstLefts2(outRec2, outRec1);\n        if ((outRec2.IsHole ^ this.ReverseSolution) == this.Area(outRec2) > 0) this.ReversePolyPtLinks(outRec2.Pts);\n      } else if (this.Poly2ContainsPoly1(outRec1.Pts, outRec2.Pts)) {\n        //outRec1 is contained by outRec2 ...\n        outRec2.IsHole = outRec1.IsHole;\n        outRec1.IsHole = !outRec2.IsHole;\n        outRec2.FirstLeft = outRec1.FirstLeft;\n        outRec1.FirstLeft = outRec2; //fixup FirstLeft pointers that may need reassigning to OutRec1\n\n        if (this.m_UsingPolyTree) this.FixupFirstLefts2(outRec1, outRec2);\n        if ((outRec1.IsHole ^ this.ReverseSolution) == this.Area(outRec1) > 0) this.ReversePolyPtLinks(outRec1.Pts);\n      } else {\n        //the 2 polygons are completely separate ...\n        outRec2.IsHole = outRec1.IsHole;\n        outRec2.FirstLeft = outRec1.FirstLeft; //fixup FirstLeft pointers that may need reassigning to OutRec2\n\n        if (this.m_UsingPolyTree) this.FixupFirstLefts1(outRec1, outRec2);\n      }\n    } else {\n      //joined 2 polygons together ...\n      outRec2.Pts = null;\n      outRec2.BottomPt = null;\n      outRec2.Idx = outRec1.Idx;\n      outRec1.IsHole = holeStateRec.IsHole;\n      if (holeStateRec == outRec2) outRec1.FirstLeft = outRec2.FirstLeft;\n      outRec2.FirstLeft = outRec1; //fixup FirstLeft pointers that may need reassigning to OutRec1\n\n      if (this.m_UsingPolyTree) this.FixupFirstLefts2(outRec2, outRec1);\n    }\n  }\n};\n\nClipperLib.Clipper.prototype.UpdateOutPtIdxs = function (outrec) {\n  var op = outrec.Pts;\n\n  do {\n    op.Idx = outrec.Idx;\n    op = op.Prev;\n  } while (op != outrec.Pts);\n};\n\nClipperLib.Clipper.prototype.DoSimplePolygons = function () {\n  var i = 0;\n\n  while (i < this.m_PolyOuts.length) {\n    var outrec = this.m_PolyOuts[i++];\n    var op = outrec.Pts;\n    if (op === null) continue;\n\n    do //for each Pt in Polygon until duplicate found do ...\n    {\n      var op2 = op.Next;\n\n      while (op2 != outrec.Pts) {\n        if (ClipperLib.IntPoint.op_Equality(op.Pt, op2.Pt) && op2.Next != op && op2.Prev != op) {\n          //split the polygon into two ...\n          var op3 = op.Prev;\n          var op4 = op2.Prev;\n          op.Prev = op4;\n          op4.Next = op;\n          op2.Prev = op3;\n          op3.Next = op2;\n          outrec.Pts = op;\n          var outrec2 = this.CreateOutRec();\n          outrec2.Pts = op2;\n          this.UpdateOutPtIdxs(outrec2);\n\n          if (this.Poly2ContainsPoly1(outrec2.Pts, outrec.Pts)) {\n            //OutRec2 is contained by OutRec1 ...\n            outrec2.IsHole = !outrec.IsHole;\n            outrec2.FirstLeft = outrec;\n          } else if (this.Poly2ContainsPoly1(outrec.Pts, outrec2.Pts)) {\n            //OutRec1 is contained by OutRec2 ...\n            outrec2.IsHole = outrec.IsHole;\n            outrec.IsHole = !outrec2.IsHole;\n            outrec2.FirstLeft = outrec.FirstLeft;\n            outrec.FirstLeft = outrec2;\n          } else {\n            //the 2 polygons are separate ...\n            outrec2.IsHole = outrec.IsHole;\n            outrec2.FirstLeft = outrec.FirstLeft;\n          }\n\n          op2 = op; //ie get ready for the next iteration\n        }\n\n        op2 = op2.Next;\n      }\n\n      op = op.Next;\n    } while (op != outrec.Pts);\n  }\n};\n\nClipperLib.Clipper.Area = function (poly) {\n  var cnt = poly.length;\n  if (cnt < 3) return 0;\n  var a = 0;\n\n  for (var i = 0, j = cnt - 1; i < cnt; ++i) {\n    a += (poly[j].X + poly[i].X) * (poly[j].Y - poly[i].Y);\n    j = i;\n  }\n\n  return -a * 0.5;\n};\n\nClipperLib.Clipper.prototype.Area = function (outRec) {\n  var op = outRec.Pts;\n  if (op == null) return 0;\n  var a = 0;\n\n  do {\n    a = a + (op.Prev.Pt.X + op.Pt.X) * (op.Prev.Pt.Y - op.Pt.Y);\n    op = op.Next;\n  } while (op != outRec.Pts);\n\n  return a * 0.5;\n};\n\nif (use_deprecated) {\n  ClipperLib.Clipper.OffsetPaths = function (polys, delta, jointype, endtype, MiterLimit) {\n    var result = new ClipperLib.Paths();\n    var co = new ClipperLib.ClipperOffset(MiterLimit, MiterLimit);\n    co.AddPaths(polys, jointype, endtype);\n    co.Execute(result, delta);\n    return result;\n  };\n}\n\nClipperLib.Clipper.SimplifyPolygon = function (poly, fillType) {\n  var result = new Array();\n  var c = new ClipperLib.Clipper(0);\n  c.StrictlySimple = true;\n  c.AddPath(poly, ClipperLib.PolyType.ptSubject, true);\n  c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n  return result;\n};\n\nClipperLib.Clipper.SimplifyPolygons = function (polys, fillType) {\n  if (typeof fillType == \"undefined\") fillType = ClipperLib.PolyFillType.pftEvenOdd;\n  var result = new Array();\n  var c = new ClipperLib.Clipper(0);\n  c.StrictlySimple = true;\n  c.AddPaths(polys, ClipperLib.PolyType.ptSubject, true);\n  c.Execute(ClipperLib.ClipType.ctUnion, result, fillType, fillType);\n  return result;\n};\n\nClipperLib.Clipper.DistanceSqrd = function (pt1, pt2) {\n  var dx = pt1.X - pt2.X;\n  var dy = pt1.Y - pt2.Y;\n  return dx * dx + dy * dy;\n};\n\nClipperLib.Clipper.DistanceFromLineSqrd = function (pt, ln1, ln2) {\n  //The equation of a line in general form (Ax + By + C = 0)\n  //given 2 points (x�,y�) & (x�,y�) is ...\n  //(y� - y�)x + (x� - x�)y + (y� - y�)x� - (x� - x�)y� = 0\n  //A = (y� - y�); B = (x� - x�); C = (y� - y�)x� - (x� - x�)y�\n  //perpendicular distance of point (x�,y�) = (Ax� + By� + C)/Sqrt(A� + B�)\n  //see http://en.wikipedia.org/wiki/Perpendicular_distance\n  var A = ln1.Y - ln2.Y;\n  var B = ln2.X - ln1.X;\n  var C = A * ln1.X + B * ln1.Y;\n  C = A * pt.X + B * pt.Y - C;\n  return C * C / (A * A + B * B);\n};\n\nClipperLib.Clipper.SlopesNearCollinear = function (pt1, pt2, pt3, distSqrd) {\n  return ClipperLib.Clipper.DistanceFromLineSqrd(pt2, pt1, pt3) < distSqrd;\n};\n\nClipperLib.Clipper.PointsAreClose = function (pt1, pt2, distSqrd) {\n  var dx = pt1.X - pt2.X;\n  var dy = pt1.Y - pt2.Y;\n  return dx * dx + dy * dy <= distSqrd;\n}; //------------------------------------------------------------------------------\n\n\nClipperLib.Clipper.ExcludeOp = function (op) {\n  var result = op.Prev;\n  result.Next = op.Next;\n  op.Next.Prev = result;\n  result.Idx = 0;\n  return result;\n};\n\nClipperLib.Clipper.CleanPolygon = function (path, distance) {\n  if (typeof distance == \"undefined\") distance = 1.415; //distance = proximity in units/pixels below which vertices will be stripped. \n  //Default ~= sqrt(2) so when adjacent vertices or semi-adjacent vertices have \n  //both x & y coords within 1 unit, then the second vertex will be stripped.\n\n  var cnt = path.length;\n  if (cnt == 0) return new Array();\n  var outPts = new Array(cnt);\n\n  for (var i = 0; i < cnt; ++i) {\n    outPts[i] = new ClipperLib.OutPt();\n  }\n\n  for (var i = 0; i < cnt; ++i) {\n    outPts[i].Pt = path[i];\n    outPts[i].Next = outPts[(i + 1) % cnt];\n    outPts[i].Next.Prev = outPts[i];\n    outPts[i].Idx = 0;\n  }\n\n  var distSqrd = distance * distance;\n  var op = outPts[0];\n\n  while (op.Idx == 0 && op.Next != op.Prev) {\n    if (ClipperLib.Clipper.PointsAreClose(op.Pt, op.Prev.Pt, distSqrd)) {\n      op = ClipperLib.Clipper.ExcludeOp(op);\n      cnt--;\n    } else if (ClipperLib.Clipper.PointsAreClose(op.Prev.Pt, op.Next.Pt, distSqrd)) {\n      ClipperLib.Clipper.ExcludeOp(op.Next);\n      op = ClipperLib.Clipper.ExcludeOp(op);\n      cnt -= 2;\n    } else if (ClipperLib.Clipper.SlopesNearCollinear(op.Prev.Pt, op.Pt, op.Next.Pt, distSqrd)) {\n      op = ClipperLib.Clipper.ExcludeOp(op);\n      cnt--;\n    } else {\n      op.Idx = 1;\n      op = op.Next;\n    }\n  }\n\n  if (cnt < 3) cnt = 0;\n  var result = new Array(cnt);\n\n  for (var i = 0; i < cnt; ++i) {\n    result[i] = new ClipperLib.IntPoint(op.Pt);\n    op = op.Next;\n  }\n\n  outPts = null;\n  return result;\n};\n\nClipperLib.Clipper.CleanPolygons = function (polys, distance) {\n  var result = new Array(polys.length);\n\n  for (var i = 0, ilen = polys.length; i < ilen; i++) {\n    result[i] = ClipperLib.Clipper.CleanPolygon(polys[i], distance);\n  }\n\n  return result;\n};\n\nClipperLib.Clipper.Minkowski = function (pattern, path, IsSum, IsClosed) {\n  var delta = IsClosed ? 1 : 0;\n  var polyCnt = pattern.length;\n  var pathCnt = path.length;\n  var result = new Array();\n  if (IsSum) for (var i = 0; i < pathCnt; i++) {\n    var p = new Array(polyCnt);\n\n    for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j]) {\n      p[j] = new ClipperLib.IntPoint(path[i].X + ip.X, path[i].Y + ip.Y);\n    }\n\n    result.push(p);\n  } else for (var i = 0; i < pathCnt; i++) {\n    var p = new Array(polyCnt);\n\n    for (var j = 0, jlen = pattern.length, ip = pattern[j]; j < jlen; j++, ip = pattern[j]) {\n      p[j] = new ClipperLib.IntPoint(path[i].X - ip.X, path[i].Y - ip.Y);\n    }\n\n    result.push(p);\n  }\n  var quads = new Array();\n\n  for (var i = 0; i < pathCnt - 1 + delta; i++) {\n    for (var j = 0; j < polyCnt; j++) {\n      var quad = new Array();\n      quad.push(result[i % pathCnt][j % polyCnt]);\n      quad.push(result[(i + 1) % pathCnt][j % polyCnt]);\n      quad.push(result[(i + 1) % pathCnt][(j + 1) % polyCnt]);\n      quad.push(result[i % pathCnt][(j + 1) % polyCnt]);\n      if (!ClipperLib.Clipper.Orientation(quad)) quad.reverse();\n      quads.push(quad);\n    }\n  }\n\n  var c = new ClipperLib.Clipper(0);\n  c.AddPaths(quads, ClipperLib.PolyType.ptSubject, true);\n  c.Execute(ClipperLib.ClipType.ctUnion, result, ClipperLib.PolyFillType.pftNonZero, ClipperLib.PolyFillType.pftNonZero);\n  return result;\n};\n\nClipperLib.Clipper.MinkowskiSum = function () {\n  var a = arguments,\n      alen = a.length;\n\n  if (alen == 3) // MinkowskiSum(Path pattern, path, pathIsClosed)\n    {\n      var pattern = a[0],\n          path = a[1],\n          pathIsClosed = a[2];\n      return ClipperLib.Clipper.Minkowski(pattern, path, true, pathIsClosed);\n    } else if (alen == 4) // MinkowskiSum(pattern, paths, pathFillType, pathIsClosed)\n    {\n      var pattern = a[0],\n          paths = a[1],\n          pathFillType = a[2],\n          pathIsClosed = a[3];\n      var c = new ClipperLib.Clipper(),\n          tmp;\n\n      for (var i = 0, ilen = paths.length; i < ilen; ++i) {\n        var tmp = ClipperLib.Clipper.Minkowski(pattern, paths[i], true, pathIsClosed);\n        c.AddPaths(tmp, ClipperLib.PolyType.ptSubject, true);\n      }\n\n      if (pathIsClosed) c.AddPaths(paths, ClipperLib.PolyType.ptClip, true);\n      var solution = new ClipperLib.Paths();\n      c.Execute(ClipperLib.ClipType.ctUnion, solution, pathFillType, pathFillType);\n      return solution;\n    }\n};\n\nClipperLib.Clipper.MinkowskiDiff = function (pattern, path, pathIsClosed) {\n  return ClipperLib.Clipper.Minkowski(pattern, path, false, pathIsClosed);\n};\n\nClipperLib.Clipper.PolyTreeToPaths = function (polytree) {\n  var result = new Array(); //result.set_Capacity(polytree.get_Total());\n\n  ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntAny, result);\n  return result;\n};\n\nClipperLib.Clipper.AddPolyNodeToPaths = function (polynode, nt, paths) {\n  var match = true;\n\n  switch (nt) {\n    case ClipperLib.Clipper.NodeType.ntOpen:\n      return;\n\n    case ClipperLib.Clipper.NodeType.ntClosed:\n      match = !polynode.IsOpen;\n      break;\n\n    default:\n      break;\n  }\n\n  if (polynode.m_polygon.length > 0 && match) paths.push(polynode.m_polygon);\n\n  for (var $i3 = 0, $t3 = polynode.Childs(), $l3 = $t3.length, pn = $t3[$i3]; $i3 < $l3; $i3++, pn = $t3[$i3]) {\n    ClipperLib.Clipper.AddPolyNodeToPaths(pn, nt, paths);\n  }\n};\n\nClipperLib.Clipper.OpenPathsFromPolyTree = function (polytree) {\n  var result = new ClipperLib.Paths(); //result.set_Capacity(polytree.ChildCount());\n\n  for (var i = 0, ilen = polytree.ChildCount(); i < ilen; i++) {\n    if (polytree.Childs()[i].IsOpen) result.push(polytree.Childs()[i].m_polygon);\n  }\n\n  return result;\n};\n\nClipperLib.Clipper.ClosedPathsFromPolyTree = function (polytree) {\n  var result = new ClipperLib.Paths(); //result.set_Capacity(polytree.Total());\n\n  ClipperLib.Clipper.AddPolyNodeToPaths(polytree, ClipperLib.Clipper.NodeType.ntClosed, result);\n  return result;\n};\n\nInherit(ClipperLib.Clipper, ClipperLib.ClipperBase);\nClipperLib.Clipper.NodeType = {\n  ntAny: 0,\n  ntOpen: 1,\n  ntClosed: 2\n};\n\nClipperLib.ClipperOffset = function (miterLimit, arcTolerance) {\n  if (typeof miterLimit == \"undefined\") miterLimit = 2;\n  if (typeof arcTolerance == \"undefined\") arcTolerance = ClipperLib.ClipperOffset.def_arc_tolerance;\n  this.m_destPolys = new ClipperLib.Paths();\n  this.m_srcPoly = new ClipperLib.Path();\n  this.m_destPoly = new ClipperLib.Path();\n  this.m_normals = new Array();\n  this.m_delta = 0;\n  this.m_sinA = 0;\n  this.m_sin = 0;\n  this.m_cos = 0;\n  this.m_miterLim = 0;\n  this.m_StepsPerRad = 0;\n  this.m_lowest = new ClipperLib.IntPoint();\n  this.m_polyNodes = new ClipperLib.PolyNode();\n  this.MiterLimit = miterLimit;\n  this.ArcTolerance = arcTolerance;\n  this.m_lowest.X = -1;\n};\n\nClipperLib.ClipperOffset.two_pi = 6.28318530717959;\nClipperLib.ClipperOffset.def_arc_tolerance = 0.25;\n\nClipperLib.ClipperOffset.prototype.Clear = function () {\n  ClipperLib.Clear(this.m_polyNodes.Childs());\n  this.m_lowest.X = -1;\n};\n\nClipperLib.ClipperOffset.Round = ClipperLib.Clipper.Round;\n\nClipperLib.ClipperOffset.prototype.AddPath = function (path, joinType, endType) {\n  var highI = path.length - 1;\n  if (highI < 0) return;\n  var newNode = new ClipperLib.PolyNode();\n  newNode.m_jointype = joinType;\n  newNode.m_endtype = endType; //strip duplicate points from path and also get index to the lowest point ...\n\n  if (endType == ClipperLib.EndType.etClosedLine || endType == ClipperLib.EndType.etClosedPolygon) while (highI > 0 && ClipperLib.IntPoint.op_Equality(path[0], path[highI])) {\n    highI--;\n  } //newNode.m_polygon.set_Capacity(highI + 1);\n\n  newNode.m_polygon.push(path[0]);\n  var j = 0,\n      k = 0;\n\n  for (var i = 1; i <= highI; i++) {\n    if (ClipperLib.IntPoint.op_Inequality(newNode.m_polygon[j], path[i])) {\n      j++;\n      newNode.m_polygon.push(path[i]);\n      if (path[i].Y > newNode.m_polygon[k].Y || path[i].Y == newNode.m_polygon[k].Y && path[i].X < newNode.m_polygon[k].X) k = j;\n    }\n  }\n\n  if (endType == ClipperLib.EndType.etClosedPolygon && j < 2 || endType != ClipperLib.EndType.etClosedPolygon && j < 0) return;\n  this.m_polyNodes.AddChild(newNode); //if this path's lowest pt is lower than all the others then update m_lowest\n\n  if (endType != ClipperLib.EndType.etClosedPolygon) return;\n  if (this.m_lowest.X < 0) this.m_lowest = new ClipperLib.IntPoint(0, k);else {\n    var ip = this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon[this.m_lowest.Y];\n    if (newNode.m_polygon[k].Y > ip.Y || newNode.m_polygon[k].Y == ip.Y && newNode.m_polygon[k].X < ip.X) this.m_lowest = new ClipperLib.IntPoint(this.m_polyNodes.ChildCount() - 1, k);\n  }\n};\n\nClipperLib.ClipperOffset.prototype.AddPaths = function (paths, joinType, endType) {\n  for (var i = 0, ilen = paths.length; i < ilen; i++) {\n    this.AddPath(paths[i], joinType, endType);\n  }\n};\n\nClipperLib.ClipperOffset.prototype.FixOrientations = function () {\n  //fixup orientations of all closed paths if the orientation of the\n  //closed path with the lowermost vertex is wrong ...\n  if (this.m_lowest.X >= 0 && !ClipperLib.Clipper.Orientation(this.m_polyNodes.Childs()[this.m_lowest.X].m_polygon)) {\n    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++) {\n      var node = this.m_polyNodes.Childs()[i];\n      if (node.m_endtype == ClipperLib.EndType.etClosedPolygon || node.m_endtype == ClipperLib.EndType.etClosedLine && ClipperLib.Clipper.Orientation(node.m_polygon)) node.m_polygon.reverse();\n    }\n  } else {\n    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++) {\n      var node = this.m_polyNodes.Childs()[i];\n      if (node.m_endtype == ClipperLib.EndType.etClosedLine && !ClipperLib.Clipper.Orientation(node.m_polygon)) node.m_polygon.reverse();\n    }\n  }\n};\n\nClipperLib.ClipperOffset.GetUnitNormal = function (pt1, pt2) {\n  var dx = pt2.X - pt1.X;\n  var dy = pt2.Y - pt1.Y;\n  if (dx == 0 && dy == 0) return new ClipperLib.DoublePoint(0, 0);\n  var f = 1 / Math.sqrt(dx * dx + dy * dy);\n  dx *= f;\n  dy *= f;\n  return new ClipperLib.DoublePoint(dy, -dx);\n};\n\nClipperLib.ClipperOffset.prototype.DoOffset = function (delta) {\n  this.m_destPolys = new Array();\n  this.m_delta = delta; //if Zero offset, just copy any CLOSED polygons to m_p and return ...\n\n  if (ClipperLib.ClipperBase.near_zero(delta)) {\n    //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount);\n    for (var i = 0; i < this.m_polyNodes.ChildCount(); i++) {\n      var node = this.m_polyNodes.Childs()[i];\n      if (node.m_endtype == ClipperLib.EndType.etClosedPolygon) this.m_destPolys.push(node.m_polygon);\n    }\n\n    return;\n  } //see offset_triginometry3.svg in the documentation folder ...\n\n\n  if (this.MiterLimit > 2) this.m_miterLim = 2 / (this.MiterLimit * this.MiterLimit);else this.m_miterLim = 0.5;\n  var y;\n  if (this.ArcTolerance <= 0) y = ClipperLib.ClipperOffset.def_arc_tolerance;else if (this.ArcTolerance > Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance) y = Math.abs(delta) * ClipperLib.ClipperOffset.def_arc_tolerance;else y = this.ArcTolerance; //see offset_triginometry2.svg in the documentation folder ...\n\n  var steps = 3.14159265358979 / Math.acos(1 - y / Math.abs(delta));\n  this.m_sin = Math.sin(ClipperLib.ClipperOffset.two_pi / steps);\n  this.m_cos = Math.cos(ClipperLib.ClipperOffset.two_pi / steps);\n  this.m_StepsPerRad = steps / ClipperLib.ClipperOffset.two_pi;\n  if (delta < 0) this.m_sin = -this.m_sin; //this.m_destPolys.set_Capacity(this.m_polyNodes.ChildCount * 2);\n\n  for (var i = 0; i < this.m_polyNodes.ChildCount(); i++) {\n    var node = this.m_polyNodes.Childs()[i];\n    this.m_srcPoly = node.m_polygon;\n    var len = this.m_srcPoly.length;\n    if (len == 0 || delta <= 0 && (len < 3 || node.m_endtype != ClipperLib.EndType.etClosedPolygon)) continue;\n    this.m_destPoly = new Array();\n\n    if (len == 1) {\n      if (node.m_jointype == ClipperLib.JoinType.jtRound) {\n        var X = 1,\n            Y = 0;\n\n        for (var j = 1; j <= steps; j++) {\n          this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n          var X2 = X;\n          X = X * this.m_cos - this.m_sin * Y;\n          Y = X2 * this.m_sin + Y * this.m_cos;\n        }\n      } else {\n        var X = -1,\n            Y = -1;\n\n        for (var j = 0; j < 4; ++j) {\n          this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + Y * delta)));\n          if (X < 0) X = 1;else if (Y < 0) Y = 1;else X = -1;\n        }\n      }\n\n      this.m_destPolys.push(this.m_destPoly);\n      continue;\n    } //build m_normals ...\n\n\n    this.m_normals.length = 0; //this.m_normals.set_Capacity(len);\n\n    for (var j = 0; j < len - 1; j++) {\n      this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[j], this.m_srcPoly[j + 1]));\n    }\n\n    if (node.m_endtype == ClipperLib.EndType.etClosedLine || node.m_endtype == ClipperLib.EndType.etClosedPolygon) this.m_normals.push(ClipperLib.ClipperOffset.GetUnitNormal(this.m_srcPoly[len - 1], this.m_srcPoly[0]));else this.m_normals.push(new ClipperLib.DoublePoint(this.m_normals[len - 2]));\n\n    if (node.m_endtype == ClipperLib.EndType.etClosedPolygon) {\n      var k = len - 1;\n\n      for (var j = 0; j < len; j++) {\n        k = this.OffsetPoint(j, k, node.m_jointype);\n      }\n\n      this.m_destPolys.push(this.m_destPoly);\n    } else if (node.m_endtype == ClipperLib.EndType.etClosedLine) {\n      var k = len - 1;\n\n      for (var j = 0; j < len; j++) {\n        k = this.OffsetPoint(j, k, node.m_jointype);\n      }\n\n      this.m_destPolys.push(this.m_destPoly);\n      this.m_destPoly = new Array(); //re-build m_normals ...\n\n      var n = this.m_normals[len - 1];\n\n      for (var j = len - 1; j > 0; j--) {\n        this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n      }\n\n      this.m_normals[0] = new ClipperLib.DoublePoint(-n.X, -n.Y);\n      k = 0;\n\n      for (var j = len - 1; j >= 0; j--) {\n        k = this.OffsetPoint(j, k, node.m_jointype);\n      }\n\n      this.m_destPolys.push(this.m_destPoly);\n    } else {\n      var k = 0;\n\n      for (var j = 1; j < len - 1; ++j) {\n        k = this.OffsetPoint(j, k, node.m_jointype);\n      }\n\n      var pt1;\n\n      if (node.m_endtype == ClipperLib.EndType.etOpenButt) {\n        var j = len - 1;\n        pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * delta));\n        this.m_destPoly.push(pt1);\n        pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X - this.m_normals[j].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y - this.m_normals[j].Y * delta));\n        this.m_destPoly.push(pt1);\n      } else {\n        var j = len - 1;\n        k = len - 2;\n        this.m_sinA = 0;\n        this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j].X, -this.m_normals[j].Y);\n        if (node.m_endtype == ClipperLib.EndType.etOpenSquare) this.DoSquare(j, k);else this.DoRound(j, k);\n      } //re-build m_normals ...\n\n\n      for (var j = len - 1; j > 0; j--) {\n        this.m_normals[j] = new ClipperLib.DoublePoint(-this.m_normals[j - 1].X, -this.m_normals[j - 1].Y);\n      }\n\n      this.m_normals[0] = new ClipperLib.DoublePoint(-this.m_normals[1].X, -this.m_normals[1].Y);\n      k = len - 1;\n\n      for (var j = k - 1; j > 0; --j) {\n        k = this.OffsetPoint(j, k, node.m_jointype);\n      }\n\n      if (node.m_endtype == ClipperLib.EndType.etOpenButt) {\n        pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X - this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y - this.m_normals[0].Y * delta));\n        this.m_destPoly.push(pt1);\n        pt1 = new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].X + this.m_normals[0].X * delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[0].Y + this.m_normals[0].Y * delta));\n        this.m_destPoly.push(pt1);\n      } else {\n        k = 1;\n        this.m_sinA = 0;\n        if (node.m_endtype == ClipperLib.EndType.etOpenSquare) this.DoSquare(0, 1);else this.DoRound(0, 1);\n      }\n\n      this.m_destPolys.push(this.m_destPoly);\n    }\n  }\n};\n\nClipperLib.ClipperOffset.prototype.Execute = function () {\n  var a = arguments,\n      ispolytree = a[0] instanceof ClipperLib.PolyTree;\n\n  if (!ispolytree) // function (solution, delta)\n    {\n      var solution = a[0],\n          delta = a[1];\n      ClipperLib.Clear(solution);\n      this.FixOrientations();\n      this.DoOffset(delta); //now clean up 'corners' ...\n\n      var clpr = new ClipperLib.Clipper(0);\n      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n\n      if (delta > 0) {\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n      } else {\n        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n        var outer = new ClipperLib.Path();\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n        clpr.ReverseSolution = true;\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative);\n        if (solution.length > 0) solution.splice(0, 1);\n      } //console.log(JSON.stringify(solution));\n\n    } else // function (polytree, delta)\n    {\n      var solution = a[0],\n          delta = a[1];\n      solution.Clear();\n      this.FixOrientations();\n      this.DoOffset(delta); //now clean up 'corners' ...\n\n      var clpr = new ClipperLib.Clipper(0);\n      clpr.AddPaths(this.m_destPolys, ClipperLib.PolyType.ptSubject, true);\n\n      if (delta > 0) {\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftPositive, ClipperLib.PolyFillType.pftPositive);\n      } else {\n        var r = ClipperLib.Clipper.GetBounds(this.m_destPolys);\n        var outer = new ClipperLib.Path();\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.bottom + 10));\n        outer.push(new ClipperLib.IntPoint(r.right + 10, r.top - 10));\n        outer.push(new ClipperLib.IntPoint(r.left - 10, r.top - 10));\n        clpr.AddPath(outer, ClipperLib.PolyType.ptSubject, true);\n        clpr.ReverseSolution = true;\n        clpr.Execute(ClipperLib.ClipType.ctUnion, solution, ClipperLib.PolyFillType.pftNegative, ClipperLib.PolyFillType.pftNegative); //remove the outer PolyNode rectangle ...\n\n        if (solution.ChildCount() == 1 && solution.Childs()[0].ChildCount() > 0) {\n          var outerNode = solution.Childs()[0]; //solution.Childs.set_Capacity(outerNode.ChildCount);\n\n          solution.Childs()[0] = outerNode.Childs()[0];\n\n          for (var i = 1; i < outerNode.ChildCount(); i++) {\n            solution.AddChild(outerNode.Childs()[i]);\n          }\n        } else solution.Clear();\n      }\n    }\n};\n\nClipperLib.ClipperOffset.prototype.OffsetPoint = function (j, k, jointype) {\n  this.m_sinA = this.m_normals[k].X * this.m_normals[j].Y - this.m_normals[j].X * this.m_normals[k].Y;\n  if (this.m_sinA < 0.00005 && this.m_sinA > -0.00005) return k;else if (this.m_sinA > 1) this.m_sinA = 1.0;else if (this.m_sinA < -1) this.m_sinA = -1.0;\n\n  if (this.m_sinA * this.m_delta < 0) {\n    this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[k].X * this.m_delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[k].Y * this.m_delta)));\n    this.m_destPoly.push(new ClipperLib.IntPoint(this.m_srcPoly[j]));\n    this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n  } else switch (jointype) {\n    case ClipperLib.JoinType.jtMiter:\n      {\n        var r = 1 + (this.m_normals[j].X * this.m_normals[k].X + this.m_normals[j].Y * this.m_normals[k].Y);\n        if (r >= this.m_miterLim) this.DoMiter(j, k, r);else this.DoSquare(j, k);\n        break;\n      }\n\n    case ClipperLib.JoinType.jtSquare:\n      this.DoSquare(j, k);\n      break;\n\n    case ClipperLib.JoinType.jtRound:\n      this.DoRound(j, k);\n      break;\n  }\n\n  k = j;\n  return k;\n};\n\nClipperLib.ClipperOffset.prototype.DoSquare = function (j, k) {\n  var dx = Math.tan(Math.atan2(this.m_sinA, this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y) / 4);\n  this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[k].X - this.m_normals[k].Y * dx)), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[k].Y + this.m_normals[k].X * dx))));\n  this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_delta * (this.m_normals[j].X + this.m_normals[j].Y * dx)), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_delta * (this.m_normals[j].Y - this.m_normals[j].X * dx))));\n};\n\nClipperLib.ClipperOffset.prototype.DoMiter = function (j, k, r) {\n  var q = this.m_delta / r;\n  this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + (this.m_normals[k].X + this.m_normals[j].X) * q), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + (this.m_normals[k].Y + this.m_normals[j].Y) * q)));\n};\n\nClipperLib.ClipperOffset.prototype.DoRound = function (j, k) {\n  var a = Math.atan2(this.m_sinA, this.m_normals[k].X * this.m_normals[j].X + this.m_normals[k].Y * this.m_normals[j].Y);\n  var steps = ClipperLib.Cast_Int32(ClipperLib.ClipperOffset.Round(this.m_StepsPerRad * Math.abs(a)));\n  var X = this.m_normals[k].X,\n      Y = this.m_normals[k].Y,\n      X2;\n\n  for (var i = 0; i < steps; ++i) {\n    this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + X * this.m_delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + Y * this.m_delta)));\n    X2 = X;\n    X = X * this.m_cos - this.m_sin * Y;\n    Y = X2 * this.m_sin + Y * this.m_cos;\n  }\n\n  this.m_destPoly.push(new ClipperLib.IntPoint(ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].X + this.m_normals[j].X * this.m_delta), ClipperLib.ClipperOffset.Round(this.m_srcPoly[j].Y + this.m_normals[j].Y * this.m_delta)));\n};\n\nClipperLib.Error = function (message) {\n  try {\n    throw new Error(message);\n  } catch (err) {\n    alert(err.message);\n  }\n}; // ---------------------------------\n// JS extension by Timo 2013\n\n\nClipperLib.JS = {};\n\nClipperLib.JS.AreaOfPolygon = function (poly, scale) {\n  if (!scale) scale = 1;\n  return ClipperLib.Clipper.Area(poly) / (scale * scale);\n};\n\nClipperLib.JS.AreaOfPolygons = function (poly, scale) {\n  if (!scale) scale = 1;\n  var area = 0;\n\n  for (var i = 0; i < poly.length; i++) {\n    area += ClipperLib.Clipper.Area(poly[i]);\n  }\n\n  return area / (scale * scale);\n};\n\nClipperLib.JS.BoundsOfPath = function (path, scale) {\n  return ClipperLib.JS.BoundsOfPaths([path], scale);\n};\n\nClipperLib.JS.BoundsOfPaths = function (paths, scale) {\n  if (!scale) scale = 1;\n  var bounds = ClipperLib.Clipper.GetBounds(paths);\n  bounds.left /= scale;\n  bounds.bottom /= scale;\n  bounds.right /= scale;\n  bounds.top /= scale;\n  return bounds;\n}; // Clean() joins vertices that are too near each other\n// and causes distortion to offsetted polygons without cleaning\n\n\nClipperLib.JS.Clean = function (polygon, delta) {\n  if (!(polygon instanceof Array)) return [];\n  var isPolygons = polygon[0] instanceof Array;\n  var polygon = ClipperLib.JS.Clone(polygon);\n\n  if (typeof delta != \"number\" || delta === null) {\n    ClipperLib.Error(\"Delta is not a number in Clean().\");\n    return polygon;\n  }\n\n  if (polygon.length === 0 || polygon.length == 1 && polygon[0].length === 0 || delta < 0) return polygon;\n  if (!isPolygons) polygon = [polygon];\n  var k_length = polygon.length;\n  var len, poly, result, d, p, j, i;\n  var results = [];\n\n  for (var k = 0; k < k_length; k++) {\n    poly = polygon[k];\n    len = poly.length;\n    if (len === 0) continue;else if (len < 3) {\n      result = poly;\n      results.push(result);\n      continue;\n    }\n    result = poly;\n    d = delta * delta; //d = Math.floor(c_delta * c_delta);\n\n    p = poly[0];\n    j = 1;\n\n    for (i = 1; i < len; i++) {\n      if ((poly[i].X - p.X) * (poly[i].X - p.X) + (poly[i].Y - p.Y) * (poly[i].Y - p.Y) <= d) continue;\n      result[j] = poly[i];\n      p = poly[i];\n      j++;\n    }\n\n    p = poly[j - 1];\n    if ((poly[0].X - p.X) * (poly[0].X - p.X) + (poly[0].Y - p.Y) * (poly[0].Y - p.Y) <= d) j--;\n    if (j < len) result.splice(j, len - j);\n    if (result.length) results.push(result);\n  }\n\n  if (!isPolygons && results.length) results = results[0];else if (!isPolygons && results.length === 0) results = [];else if (isPolygons && results.length === 0) results = [[]];\n  return results;\n}; // Make deep copy of Polygons or Polygon\n// so that also IntPoint objects are cloned and not only referenced\n// This should be the fastest way\n\n\nClipperLib.JS.Clone = function (polygon) {\n  if (!(polygon instanceof Array)) return [];\n  if (polygon.length === 0) return [];else if (polygon.length == 1 && polygon[0].length === 0) return [[]];\n  var isPolygons = polygon[0] instanceof Array;\n  if (!isPolygons) polygon = [polygon];\n  var len = polygon.length,\n      plen,\n      i,\n      j,\n      result;\n  var results = new Array(len);\n\n  for (i = 0; i < len; i++) {\n    plen = polygon[i].length;\n    result = new Array(plen);\n\n    for (j = 0; j < plen; j++) {\n      result[j] = {\n        X: polygon[i][j].X,\n        Y: polygon[i][j].Y\n      };\n    }\n\n    results[i] = result;\n  }\n\n  if (!isPolygons) results = results[0];\n  return results;\n}; // Removes points that doesn't affect much to the visual appearance.\n// If middle point is at or under certain distance (tolerance) of the line segment between \n// start and end point, the middle point is removed.\n\n\nClipperLib.JS.Lighten = function (polygon, tolerance) {\n  if (!(polygon instanceof Array)) return [];\n\n  if (typeof tolerance != \"number\" || tolerance === null) {\n    ClipperLib.Error(\"Tolerance is not a number in Lighten().\");\n    return ClipperLib.JS.Clone(polygon);\n  }\n\n  if (polygon.length === 0 || polygon.length == 1 && polygon[0].length === 0 || tolerance < 0) {\n    return ClipperLib.JS.Clone(polygon);\n  }\n\n  if (!(polygon[0] instanceof Array)) polygon = [polygon];\n  var i, j, poly, k, poly2, plen, A, B, P, d, rem, addlast;\n  var bxax, byay, l, ax, ay;\n  var len = polygon.length;\n  var toleranceSq = tolerance * tolerance;\n  var results = [];\n\n  for (i = 0; i < len; i++) {\n    poly = polygon[i];\n    plen = poly.length;\n    if (plen == 0) continue;\n\n    for (k = 0; k < 1000000; k++) // could be forever loop, but wiser to restrict max repeat count\n    {\n      poly2 = [];\n      plen = poly.length; // the first have to added to the end, if first and last are not the same\n      // this way we ensure that also the actual last point can be removed if needed\n\n      if (poly[plen - 1].X != poly[0].X || poly[plen - 1].Y != poly[0].Y) {\n        addlast = 1;\n        poly.push({\n          X: poly[0].X,\n          Y: poly[0].Y\n        });\n        plen = poly.length;\n      } else addlast = 0;\n\n      rem = []; // Indexes of removed points\n\n      for (j = 0; j < plen - 2; j++) {\n        A = poly[j]; // Start point of line segment\n\n        P = poly[j + 1]; // Middle point. This is the one to be removed.\n\n        B = poly[j + 2]; // End point of line segment\n\n        ax = A.X;\n        ay = A.Y;\n        bxax = B.X - ax;\n        byay = B.Y - ay;\n\n        if (bxax !== 0 || byay !== 0) // To avoid Nan, when A==P && P==B. And to avoid peaks (A==B && A!=P), which have lenght, but not area.\n          {\n            l = ((P.X - ax) * bxax + (P.Y - ay) * byay) / (bxax * bxax + byay * byay);\n\n            if (l > 1) {\n              ax = B.X;\n              ay = B.Y;\n            } else if (l > 0) {\n              ax += bxax * l;\n              ay += byay * l;\n            }\n          }\n\n        bxax = P.X - ax;\n        byay = P.Y - ay;\n        d = bxax * bxax + byay * byay;\n\n        if (d <= toleranceSq) {\n          rem[j + 1] = 1;\n          j++; // when removed, transfer the pointer to the next one\n        }\n      } // add all unremoved points to poly2\n\n\n      poly2.push({\n        X: poly[0].X,\n        Y: poly[0].Y\n      });\n\n      for (j = 1; j < plen - 1; j++) {\n        if (!rem[j]) poly2.push({\n          X: poly[j].X,\n          Y: poly[j].Y\n        });\n      }\n\n      poly2.push({\n        X: poly[plen - 1].X,\n        Y: poly[plen - 1].Y\n      }); // if the first point was added to the end, remove it\n\n      if (addlast) poly.pop(); // break, if there was not anymore removed points\n\n      if (!rem.length) break; // else continue looping using poly2, to check if there are points to remove\n      else poly = poly2;\n    }\n\n    plen = poly2.length; // remove duplicate from end, if needed\n\n    if (poly2[plen - 1].X == poly2[0].X && poly2[plen - 1].Y == poly2[0].Y) {\n      poly2.pop();\n    }\n\n    if (poly2.length > 2) // to avoid two-point-polygons\n      results.push(poly2);\n  }\n\n  if (!polygon[0] instanceof Array) results = results[0];\n  if (typeof results == \"undefined\") results = [[]];\n  return results;\n};\n\nClipperLib.JS.PerimeterOfPath = function (path, closed, scale) {\n  if (typeof path == \"undefined\") return 0;\n  var sqrt = Math.sqrt;\n  var perimeter = 0.0;\n  var p1,\n      p2,\n      p1x = 0.0,\n      p1y = 0.0,\n      p2x = 0.0,\n      p2y = 0.0;\n  var j = path.length;\n  if (j < 2) return 0;\n\n  if (closed) {\n    path[j] = path[0];\n    j++;\n  }\n\n  while (--j) {\n    p1 = path[j];\n    p1x = p1.X;\n    p1y = p1.Y;\n    p2 = path[j - 1];\n    p2x = p2.X;\n    p2y = p2.Y;\n    perimeter += sqrt((p1x - p2x) * (p1x - p2x) + (p1y - p2y) * (p1y - p2y));\n  }\n\n  if (closed) path.pop();\n  return perimeter / scale;\n};\n\nClipperLib.JS.PerimeterOfPaths = function (paths, closed, scale) {\n  if (!scale) scale = 1;\n  var perimeter = 0;\n\n  for (var i = 0; i < paths.length; i++) {\n    perimeter += ClipperLib.JS.PerimeterOfPath(paths[i], closed, scale);\n  }\n\n  return perimeter;\n};\n\nClipperLib.JS.ScaleDownPath = function (path, scale) {\n  var i, p;\n  if (!scale) scale = 1;\n  i = path.length;\n\n  while (i--) {\n    p = path[i];\n    p.X = p.X / scale;\n    p.Y = p.Y / scale;\n  }\n};\n\nClipperLib.JS.ScaleDownPaths = function (paths, scale) {\n  var i,\n      j,\n      p,\n      round = Math.round;\n  if (!scale) scale = 1;\n  i = paths.length;\n\n  while (i--) {\n    j = paths[i].length;\n\n    while (j--) {\n      p = paths[i][j];\n      p.X = p.X / scale;\n      p.Y = p.Y / scale;\n    }\n  }\n};\n\nClipperLib.JS.ScaleUpPath = function (path, scale) {\n  var i,\n      p,\n      round = Math.round;\n  if (!scale) scale = 1;\n  i = path.length;\n\n  while (i--) {\n    p = path[i];\n    p.X = round(p.X * scale);\n    p.Y = round(p.Y * scale);\n  }\n};\n\nClipperLib.JS.ScaleUpPaths = function (paths, scale) {\n  var i,\n      j,\n      p,\n      round = Math.round;\n  if (!scale) scale = 1;\n  i = paths.length;\n\n  while (i--) {\n    j = paths[i].length;\n\n    while (j--) {\n      p = paths[i][j];\n      p.X = round(p.X * scale);\n      p.Y = round(p.Y * scale);\n    }\n  }\n};\n\nClipperLib.ExPolygons = function () {\n  return [];\n};\n\nClipperLib.ExPolygon = function () {\n  this.outer = null;\n  this.holes = null;\n};\n\nClipperLib.JS.AddOuterPolyNodeToExPolygons = function (polynode, expolygons) {\n  var ep = new ClipperLib.ExPolygon();\n  ep.outer = polynode.Contour();\n  var childs = polynode.Childs();\n  var ilen = childs.length;\n  ep.holes = new Array(ilen);\n  var node, n, i, j, childs2, jlen;\n\n  for (i = 0; i < ilen; i++) {\n    node = childs[i];\n    ep.holes[i] = node.Contour(); //Add outer polygons contained by (nested within) holes ...\n\n    for (j = 0, childs2 = node.Childs(), jlen = childs2.length; j < jlen; j++) {\n      n = childs2[j];\n      ClipperLib.JS.AddOuterPolyNodeToExPolygons(n, expolygons);\n    }\n  }\n\n  expolygons.push(ep);\n};\n\nClipperLib.JS.ExPolygonsToPaths = function (expolygons) {\n  var a, i, alen, ilen;\n  var paths = new ClipperLib.Paths();\n\n  for (a = 0, alen = expolygons.length; a < alen; a++) {\n    paths.push(expolygons[a].outer);\n\n    for (i = 0, ilen = expolygons[a].holes.length; i < ilen; i++) {\n      paths.push(expolygons[a].holes[i]);\n    }\n  }\n\n  return paths;\n};\n\nClipperLib.JS.PolyTreeToExPolygons = function (polytree) {\n  var expolygons = new ClipperLib.ExPolygons();\n  var node, i, childs, ilen;\n\n  for (i = 0, childs = polytree.Childs(), ilen = childs.length; i < ilen; i++) {\n    node = childs[i];\n    ClipperLib.JS.AddOuterPolyNodeToExPolygons(node, expolygons);\n  }\n\n  return expolygons;\n};\n\nmodule.exports = ClipperLib;","map":null,"metadata":{},"sourceType":"script"}