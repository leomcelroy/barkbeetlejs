{"ast":null,"code":"function _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport { transform, fromObject, translate, scale } from 'transformation-matrix';\nimport { TOOL_NONE, TOOL_PAN, TOOL_AUTO, TOOL_ZOOM_IN, TOOL_ZOOM_OUT, MODE_IDLE, MODE_PANNING, MODE_ZOOMING } from '../constants';\nimport { resetMode, getSVGPoint, set } from './common';\nimport { onMouseDown, onMouseMove, onMouseUp } from './interactions';\nimport { isZoomLevelGoingOutOfBounds, limitZoomLevel } from './zoom';\n\nfunction hasPinchPointDistance(value) {\n  return typeof value.pinchPointDistance === 'number';\n}\n\nfunction onMultiTouch(event, ViewerDOM, tool, value, props) {\n  var _ViewerDOM$getBoundin = ViewerDOM.getBoundingClientRect(),\n      left = _ViewerDOM$getBoundin.left,\n      top = _ViewerDOM$getBoundin.top;\n\n  var x1 = event.touches[0].clientX - Math.round(left);\n  var y1 = event.touches[0].clientY - Math.round(top);\n  var x2 = event.touches[1].clientX - Math.round(left);\n  var y2 = event.touches[1].clientY - Math.round(top);\n  var pinchPointDistance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n  var previousPointDistance = hasPinchPointDistance(value) ? value.pinchPointDistance : pinchPointDistance;\n  var svgPoint = getSVGPoint(value, (x1 + x2) / 2, (y1 + y2) / 2);\n  var distanceFactor = pinchPointDistance / previousPointDistance;\n\n  if (isZoomLevelGoingOutOfBounds(value, distanceFactor)) {\n    // Do not change translation and scale of value\n    return value;\n  }\n\n  if (event.cancelable) {\n    event.preventDefault();\n  }\n\n  var matrix = transform(fromObject(value), translate(svgPoint.x, svgPoint.y), scale(distanceFactor, distanceFactor), translate(-svgPoint.x, -svgPoint.y));\n  return set(value, set(_objectSpread({\n    mode: MODE_ZOOMING\n  }, limitZoomLevel(value, matrix), {\n    startX: null,\n    startY: null,\n    endX: null,\n    endY: null,\n    prePinchMode: value.prePinchMode ? value.prePinchMode : value.mode,\n    pinchPointDistance: pinchPointDistance\n  })));\n}\n\nfunction isMultiTouch(event, props) {\n  return props.detectPinchGesture && event.touches.length > 1;\n}\n\nfunction shouldResetPinchPointDistance(event, value, props) {\n  return props.detectPinchGesture && hasPinchPointDistance(value) && event.touches.length < 2;\n}\n\nfunction getTouchPosition(touch, ViewerDOM) {\n  var _ViewerDOM$getBoundin2 = ViewerDOM.getBoundingClientRect(),\n      left = _ViewerDOM$getBoundin2.left,\n      top = _ViewerDOM$getBoundin2.top;\n\n  var x = touch.clientX - Math.round(left);\n  var y = touch.clientY - Math.round(top);\n  return {\n    x: x,\n    y: y\n  };\n}\n\nfunction getNextValue(event, ViewerDOM, tool, value, props, nextValueFn) {\n  var nextValue = event.touches.length === 0 ? set(value, {\n    mode: value.prePinchMode ? MODE_IDLE : value.mode,\n    prePinchMode: null\n  }) : value;\n  var touch = event.touches.length > 0 ? event.touches[0] : event.changedTouches[0];\n  var touchPosition = getTouchPosition(touch, ViewerDOM);\n\n  switch (tool) {\n    case TOOL_ZOOM_OUT:\n    case TOOL_ZOOM_IN:\n    case TOOL_AUTO:\n    case TOOL_PAN:\n      event.stopPropagation();\n      event.preventDefault();\n      return nextValueFn(event, ViewerDOM, tool, nextValue, props, touchPosition);\n\n    default:\n      return nextValue;\n  }\n}\n\nexport function onTouchStart(event, ViewerDOM, tool, value, props) {\n  if (isMultiTouch(event, props)) {\n    return onMultiTouch(event, ViewerDOM, tool, value, props);\n  }\n\n  if (event.touches.length !== 1) {\n    if ([MODE_PANNING, MODE_ZOOMING].indexOf(value.mode) >= 0) {\n      return resetMode(value);\n    } else if ([MODE_IDLE].indexOf(value.mode) >= 0) {\n      return value;\n    }\n  }\n\n  return getNextValue(event, ViewerDOM, tool, value, props, onMouseDown);\n}\nexport function onTouchMove(event, ViewerDOM, tool, value, props) {\n  if (isMultiTouch(event, props)) {\n    return onMultiTouch(event, ViewerDOM, tool, value, props);\n  }\n\n  if (!([MODE_PANNING, MODE_ZOOMING].indexOf(value.mode) >= 0)) {\n    return value;\n  }\n\n  return getNextValue(event, ViewerDOM, tool, value, props, onMouseMove);\n}\nexport function onTouchEnd(event, ViewerDOM, tool, value, props) {\n  if (!([MODE_PANNING, MODE_ZOOMING].indexOf(value.mode) >= 0)) {\n    return value;\n  }\n\n  var nextValue = shouldResetPinchPointDistance(event, value, props) ? set(value, {\n    pinchPointDistance: null\n  }) : value;\n\n  if (event.touches.length > 0) {\n    return nextValue;\n  }\n\n  return getNextValue(event, ViewerDOM, tool, nextValue, props, onMouseUp);\n}\nexport function onTouchCancel(event, ViewerDOM, tool, value, props) {\n  event.stopPropagation();\n  event.preventDefault();\n  return resetMode(value);\n}","map":null,"metadata":{},"sourceType":"module"}