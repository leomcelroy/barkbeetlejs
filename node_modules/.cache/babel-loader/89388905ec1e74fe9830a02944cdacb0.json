{"ast":null,"code":"var _toConsumableArray = require(\"/Users/leomcelroy/Desktop/barkbeetle_js/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/Users/leomcelroy/Desktop/barkbeetle_js/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/leomcelroy/Desktop/barkbeetle_js/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require('../utils/objectCreationUtils'),\n    extendClass = _require.extendClass;\n\nvar matrix = require('gl-matrix').mat2d;\n\nvar radians = function radians(d) {\n  return d % 360 * Math.PI / 180;\n};\n\nvar SVGMatrix =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  function SVGMatrix() {\n    _classCallCheck(this, SVGMatrix);\n\n    this.a = this.d = 1;\n    this.b = this.c = this.e = this.f = 0;\n  }\n\n  _createClass(SVGMatrix, [{\n    key: \"multiply\",\n    value: function multiply(m) {\n      var r = new SVGMatrix();\n      r.a = this.a * m.a + this.c * m.b + this.e * 0;\n      r.b = this.b * m.a + this.d * m.b + this.f * 0;\n      r.c = this.a * m.c + this.c * m.d + this.e * 0;\n      r.d = this.b * m.c + this.d * m.d + this.f * 0;\n      r.e = this.a * m.e + this.c * m.f + this.e * 1;\n      r.f = this.b * m.e + this.d * m.f + this.f * 1;\n      return r;\n    }\n  }, {\n    key: \"translate\",\n    value: function translate() {\n      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      return this.multiply(matrixFactory(1, 0, 0, 1, x, y));\n    }\n  }, {\n    key: \"inverse\",\n    value: function inverse() {\n      var t = matrix.fromValues(this.a, this.b, this.c, this.d, this.e, this.f);\n      var r = matrix.create();\n      matrix.invert(r, t);\n      return matrixFactory.apply(void 0, _toConsumableArray(r));\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return 'SVGMatrix';\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(scaleX) {\n      var scaleY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : scaleX;\n      return this.multiply(matrixFactory(scaleX, 0, 0, scaleY, 0, 0));\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate(r, x, y) {\n      r = r % 360 * Math.PI / 180;\n      return this.multiply(matrixFactory(Math.cos(r), Math.sin(r), -Math.sin(r), Math.cos(r), x ? -Math.cos(r) * x + Math.sin(r) * y + x : 0, y ? -Math.sin(r) * x - Math.cos(r) * y + y : 0));\n    }\n  }, {\n    key: \"skew\",\n    value: function skew(x, y) {\n      return this.multiply(matrixFactory(1, Math.tan(radians(y)), Math.tan(radians(x)), 1, 0, 0));\n    }\n  }, {\n    key: \"skewX\",\n    value: function skewX(x) {\n      return this.skew(x, 0);\n    }\n  }, {\n    key: \"skewY\",\n    value: function skewY(y) {\n      return this.skew(0, y);\n    }\n  }]);\n\n  return SVGMatrix;\n}();\n\nvar matrixFactory = function matrixFactory(a, b, c, d, e, f) {\n  var r = new SVGMatrix();\n  r.a = a;\n  r.b = b;\n  r.c = c;\n  r.d = d;\n  r.e = e;\n  r.f = f;\n  return r;\n};\n\nextendClass(SVGMatrix, {\n  matrixFactory: matrixFactory\n});\nmodule.exports = SVGMatrix;","map":null,"metadata":{},"sourceType":"script"}