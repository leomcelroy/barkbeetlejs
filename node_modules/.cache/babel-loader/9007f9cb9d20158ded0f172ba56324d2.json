{"ast":null,"code":"var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nimport React, { PureComponent } from 'react';\nimport PropTypes from 'prop-types';\nimport { findDOMNode } from 'react-dom';\nimport CSSTransitionGroup from 'react-transition-group/CSSTransitionGroup';\nimport deprecated from 'react-prop-types/lib/deprecated';\nimport getField from '../utils/getField';\nimport TICK from '../constants/CSSTransitionGroupTick';\nimport isInvalidAnimate from './isInvalidAnimate';\nimport Portal from '../Helpers/Portal';\nimport Snackbar from './Snackbar';\nvar CHAINED_TOAST_DELAY = 50;\n/**\n * The `Snackbar` component is used for displaying a concise and small message to the user about\n * an operation performed.\n *\n * > The main component for the `Snackbar` is actually named the `SnackbarContainer`, so you need\n * to make sure the import is `react-md/lib/Snackbars` or `react-md/lib/Snackbars/SnackbarContainer`.\n * The first import is preferable.\n */\n\nvar SnackbarContainer = function (_PureComponent) {\n  _inherits(SnackbarContainer, _PureComponent);\n\n  function SnackbarContainer(props) {\n    _classCallCheck(this, SnackbarContainer);\n\n    var _this = _possibleConstructorReturn(this, _PureComponent.call(this, props));\n\n    _initialiseProps.call(_this);\n\n    var visible = !!props.toasts.length;\n    _this.state = {\n      visible: visible,\n      toast: null\n    };\n    return _this;\n  }\n\n  SnackbarContainer.prototype.componentDidMount = function componentDidMount() {\n    var toasts = this.props.toasts;\n\n    if (toasts.length) {\n      this._initAndToast(toasts[0]);\n    }\n  };\n\n  SnackbarContainer.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    var _nextProps$toasts = nextProps.toasts,\n        toast = _nextProps$toasts[0];\n    var _props$toasts = this.props.toasts,\n        prevToast = _props$toasts[0];\n\n    if (toast === prevToast || toast === this.state.toast) {\n      return;\n    }\n\n    if (!toast) {\n      this._createLeaveTimer();\n    } else if (!this.state.visible) {\n      this._initAndToast(toast);\n    } else {\n      this._createSwapTimer(toast);\n    }\n  };\n\n  SnackbarContainer.prototype.componentWillUnmount = function componentWillUnmount() {\n    if (this._initTimeout) {\n      clearTimeout(this._initTimeout);\n    }\n\n    if (this._leaveTimeout) {\n      clearTimeout(this._leaveTimeout);\n    }\n\n    if (this._swapTimeout) {\n      clearTimeout(this._swapTimeout);\n    }\n\n    if (this._dismissTimeout) {\n      clearTimeout(this._dismissTimeout);\n    }\n  };\n  /**\n   * This function takes in a new toast object and checks if the message will span\n   * multiple lines of text by creating the new snackbar before the `Snackbar` component\n   * gets made, checking the height of the message, and then removing the temporary\n   * snackbar.\n   */\n\n\n  SnackbarContainer.prototype.render = function render() {\n    var _state = this.state,\n        visible = _state.visible,\n        toast = _state.toast,\n        multiline = _state.multiline;\n\n    var _props = this.props,\n        transitionName = _props.transitionName,\n        transitionEnterTimeout = _props.transitionEnterTimeout,\n        transitionLeaveTimeout = _props.transitionLeaveTimeout,\n        dismiss = _props.dismiss,\n        onDismiss = _props.onDismiss,\n        lastChild = _props.lastChild,\n        portal = _props.portal,\n        propRenderNode = _props.renderNode,\n        toasts = _props.toasts,\n        props = _objectWithoutProperties(_props, ['transitionName', 'transitionEnterTimeout', 'transitionLeaveTimeout', 'dismiss', 'onDismiss', 'lastChild', 'portal', 'renderNode', 'toasts']);\n\n    var renderNode = getField(this.props, this.context, 'renderNode');\n    var snackbar = void 0;\n\n    if (toast) {\n      snackbar = React.createElement(Snackbar, _extends({}, props, {\n        key: 'snackbar',\n        leaveTimeout: transitionLeaveTimeout,\n        toast: toast,\n        multiline: multiline,\n        onDismiss: onDismiss || dismiss\n      }));\n    }\n\n    var container = React.createElement(CSSTransitionGroup, {\n      ref: this._setContainer,\n      key: 'container',\n      className: 'md-snackbar-container',\n      transitionName: transitionName,\n      transitionEnterTimeout: transitionEnterTimeout,\n      transitionLeaveTimeout: transitionLeaveTimeout\n    }, snackbar);\n\n    if (!portal) {\n      return visible ? container : null;\n    }\n\n    return React.createElement(Portal, {\n      visible: visible,\n      renderNode: renderNode,\n      lastChild: lastChild\n    }, container);\n  };\n\n  return SnackbarContainer;\n}(PureComponent);\n\nSnackbarContainer.propTypes = {\n  /**\n   * An id for the Snackbar once a toast has been added and is visible. This is a recommended\n   * prop for accessibility concerns. If it is omitted, the id will become `'snackbar-alert'`\n   * when there is no action on the toast, or `'snackbar-alert-dialog'` when there is an action\n   * on the toast.\n   */\n  id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n\n  /**\n   * An optional style to apply to the snackbar once it appears.\n   */\n  style: PropTypes.object,\n\n  /**\n   * An optional className to apply to the snackbar once it appears.\n   */\n  className: PropTypes.string,\n\n  /**\n   * An immutable controlled queue of toasts that should appear in the snackbar.\n   * The snackbar will always display the first toast in this list. When the user has\n   * either clicked the action of the toast, or the `autohideTimeout` has been reached,\n   * the `onDismiss` function will be called. The `onDismiss` function should remove the\n   * first toast and return a new list of remaining toasts.\n   *\n   * ```js\n   * let toasts = [];\n   * const onDismiss = () => {\n   *   const [, ...remainingToasts] = toasts;\n   *   toasts = remainingToasts;\n   * };\n   * ```\n   */\n  toasts: PropTypes.arrayOf(PropTypes.shape({\n    /**\n     * The text to display in the toast.\n     */\n    text: PropTypes.node.isRequired,\n\n    /**\n     * An optional action to take. If this value is a string, the `label` for the\n     * button will be this value, Otherwise, all the keys in the action object will\n     * be applied to the `Button`.\n     */\n    action: PropTypes.oneOfType([PropTypes.node, PropTypes.shape({\n      onClick: PropTypes.func,\n      children: PropTypes.node,\n      // Deprecated\n      label: PropTypes.node\n    })])\n  })).isRequired,\n\n  /**\n   * A function to call that will dismiss a toast. This will automatically be bound to\n   * any toast that has an `action` and it will also be called when the `autohideTimeout`\n   * has been reached.\n   */\n  onDismiss: PropTypes.func.isRequired,\n\n  /**\n   * Boolean if the snackbar's toasts should automatically be dismissed after the\n   * `autohideTimeout` has been reached.\n   */\n  autohide: PropTypes.bool,\n\n  /**\n   * The amount of time before the snackbar should be dequeued and the next toast\n   * should be displayed.\n   */\n  autohideTimeout: PropTypes.number.isRequired,\n\n  /**\n   * When a toast has an action, it will automatically be focused when this prop is enabled.\n   * This will require your action onClick handler to correctly focus an element on the page\n   * once the toast is hidden. If this prop is disabled, it is recommended to add custom focus\n   * logic so that keyboard users can interact with the snackbar.\n   */\n  autoFocusAction: PropTypes.bool,\n\n  /**\n   * The transition name to use for the snackbar appearing and disappearing.\n   */\n  transitionName: PropTypes.string.isRequired,\n\n  /**\n   * The transition time for the snackbar to enter. This should match the `$md-snackbar-transition-time`\n   * sass variable.\n   */\n  transitionEnterTimeout: PropTypes.number.isRequired,\n\n  /**\n   * The transition time for the snackbar to leave. This should match the `$md-snackbar-transition-time`\n   * sass variable.\n   */\n  transitionLeaveTimeout: PropTypes.number.isRequired,\n\n  /**\n   * When the app contains a floating action button that is fixed to the bottom of the screen,\n   * you should set this to be a ref of the floating action button. When a snackbar appears,\n   * the FAB will be moved to not overlay the snackbar.\n   */\n  fab: function fab(props, propName, componentName, location, propFullName) {\n    var propValue = props[propName];\n    var propType = typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue);\n\n    if (!propValue) {\n      return null;\n    }\n\n    if (propType !== 'object' || typeof propValue.render !== 'function' || isInvalidAnimate(propValue)) {\n      var componentNameSafe = componentName || '<<anonymous>>';\n      var propFullNameSafe = propFullName || propName;\n      return new Error('Invalid ' + location + ' `' + propFullNameSafe + '` supplied to `' + componentNameSafe + '`, expected a ' + 'ref to a floating `Button` component. This should not be a DOMElement from `findDOMNode` but instead ' + 'the React ref object.');\n    }\n\n    return null;\n  },\n\n  /**\n   * Boolean if the Portal's functionality of rendering in a separate react tree should be applied\n   * to the snackbar.\n   *\n   * @see {@link Helpers/Portal}\n   */\n  portal: PropTypes.bool,\n\n  /**\n   * An optional DOM node to render the Snackbar in. If this is omitted, it will render as the first\n   * child in the `body`.\n   */\n  renderNode: PropTypes.object,\n\n  /**\n   * Boolean if the snackbar should render as the last child in the `renderNode` or `body` instead of\n   * as the first.\n   */\n  lastChild: PropTypes.bool,\n  dismiss: deprecated(PropTypes.func, 'Use `onDismiss` instead')\n};\nSnackbarContainer.defaultProps = {\n  autoFocusAction: false,\n  autohide: true,\n  toasts: [],\n  autohideTimeout: 3000,\n  transitionName: 'md-snackbar',\n  transitionEnterTimeout: 300,\n  transitionLeaveTimeout: 300\n};\nSnackbarContainer.contextTypes = {\n  renderNode: PropTypes.object\n};\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this2 = this;\n\n  this._setContainer = function (container) {\n    _this2._container = findDOMNode(container);\n  };\n\n  this._isMultiline = function (toast) {\n    var container = _this2._container;\n\n    if (container === null) {\n      return false;\n    }\n\n    var message = document.createElement('p');\n    message.classList.add('md-snackbar--toast');\n    message.innerHTML = toast.text;\n    var snackbar = void 0;\n\n    if (toast.action) {\n      message.classList.add('md-snackbar--action');\n      snackbar = document.createElement('section');\n      snackbar.className = 'md-snackbar';\n      snackbar.appendChild(message);\n      var action = document.createElement('button');\n      action.innerHTML = typeof toast.action === 'string' ? toast.action : toast.action.label;\n      action.className = 'md-btn md-btn--flat md-btn--text md-btn--snackbar';\n      snackbar.appendChild(action);\n    } else {\n      snackbar = message;\n    } // Only style we really want from the .md-snackbar\n\n\n    snackbar.style.maxWidth = '568px';\n    container.appendChild(snackbar);\n    var multiline = message.offsetHeight > 20;\n    container.removeChild(snackbar);\n    return multiline;\n  };\n\n  this._initAndToast = function (toast) {\n    _this2._initTimeout = setTimeout(function () {\n      _this2._initTimeout = null;\n\n      _this2.setState({\n        toast: toast,\n        multiline: _this2._isMultiline(toast)\n      });\n    }, TICK);\n\n    _this2.setState({\n      visible: true\n    });\n  };\n\n  this._createLeaveTimer = function () {\n    var time = _this2.props.transitionLeaveTimeout;\n    _this2._leaveTimeout = setTimeout(function () {\n      _this2._leaveTimeout = null;\n\n      _this2.setState({\n        visible: false\n      });\n    }, time + TICK);\n\n    _this2.setState({\n      toast: null\n    });\n  };\n\n  this._createSwapTimer = function (toast) {\n    _this2._swapTimeout = setTimeout(function () {\n      _this2._swapTimeout = null;\n\n      _this2.setState({\n        toast: toast,\n        multiline: _this2._isMultiline(toast)\n      });\n    }, _this2.props.transitionLeaveTimeout + CHAINED_TOAST_DELAY);\n\n    _this2.setState({\n      toast: null\n    });\n  };\n};\n\nexport default SnackbarContainer;","map":null,"metadata":{},"sourceType":"module"}