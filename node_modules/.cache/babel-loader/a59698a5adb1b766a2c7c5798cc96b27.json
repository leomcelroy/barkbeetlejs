{"ast":null,"code":"import _toConsumableArray from \"/Users/leomcelroy/Desktop/barkbeetle_js/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n// makerjs model, params -> profile toolpath\nimport * as mjs from 'makerjs';\n\nvar offsetFunc = function offsetFunc(params) {\n  if (params.offset === \"outside\") {\n    return false;\n  } else if (params.offset === \"inside\") {\n    return true;\n  } else if (params.offset === \"none\") {\n    return \"none\";\n  }\n};\n\nvar profile = function profile(model, params) {\n  //let p = model.models.profile;\n  var p = model;\n  var outline;\n  var offset = offsetFunc(params.offset);\n\n  if (offset === \"none\") {\n    outline = mjs.model.outline(p, 0, 1, false); //third parameter is what type of corners, 0 (rounded) by default\n  } else {\n    console.log(\"offset\", offset);\n    outline = mjs.model.outline(p, params.compensatedRadius, 1, offset); //third parameter is what type of corners, 0 (rounded) by default\n  } // outline = mjs.model.zero(outline);\n  // let chains = mjs.model.findChains(expansion);\n\n\n  var chain = mjs.model.findSingleChain(outline); // console.log(\"outline\", outline, \"chain\", chain);\n\n  var divisions = Math.floor(chain.pathLength / params.minimumSpacing);\n  var spacing = chain.pathLength / divisions;\n  var keyPoints = mjs.chain.toKeyPoints(chain, spacing); // let scaleFactor = 10;\n  // let scaleXY = keyPoints.map(p => [p[0] * scaleFactor, p[1] * scaleFactor]);\n\n  var gcodePoints = keyPoints.map(function (p) {\n    return \"G1 X\".concat(p[0], \" Y\").concat(p[1], \" F\").concat(params.feedRate);\n  }); //let gcode = JSON.parse(JSON.stringify(gcodePoints));\n\n  var firstPoint = keyPoints[0];\n  var paths = params.depthOfPasses.map(function (p, i) {\n    return [\"G1 Z\".concat(params.depthOfPasses[i], \" F12.0\")].concat(_toConsumableArray(gcodePoints), [\"G1 X\".concat(firstPoint[0], \" Y\").concat(firstPoint[1], \" F\").concat(params.feedRate)]);\n  });\n  paths = paths.flat(1);\n  var preamble = [params.units, \"G90\"];\n  var gcode = preamble.concat([\"(end of preamble)\", \"G1 Z\".concat(params.jogHeight, \" F\").concat(params.jogRate), \"G0 X\".concat(firstPoint[0], \" Y\").concat(firstPoint[1])], _toConsumableArray(paths), [\"G1 Z\".concat(params.jogHeight, \" F\").concat(params.jogRate)]); // write to a new file named\n\n  var filename = 'testGcodeProfile.gcode';\n  var text = gcode.join('\\n'); // console.log(\"profile\", outline)\n\n  return {\n    drawing: outline,\n    gcode: text,\n    filename: filename\n  };\n};\n\nexport { profile };","map":{"version":3,"sources":["/Users/leomcelroy/Desktop/barkbeetle_js/src/toolpaths/profile.js"],"names":["mjs","offsetFunc","params","offset","profile","model","p","outline","console","log","compensatedRadius","chain","findSingleChain","divisions","Math","floor","pathLength","minimumSpacing","spacing","keyPoints","toKeyPoints","gcodePoints","map","feedRate","firstPoint","paths","depthOfPasses","i","flat","preamble","units","gcode","jogHeight","jogRate","filename","text","join","drawing"],"mappings":"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","sourcesContent":["// makerjs model, params -> profile toolpath\n\nimport * as mjs from 'makerjs';\n\nconst offsetFunc = (params) => {\n  if (params.offset === \"outside\") {\n    return false;\n  } else if (params.offset === \"inside\") {\n    return true;\n  } else if (params.offset === \"none\") {\n    return \"none\";\n  }\n}\n\nconst profile = (model, params) => {\n  //let p = model.models.profile;\n  let p = model;\n\n  let outline;\n  let offset = offsetFunc(params.offset);\n  if (offset === \"none\") {\n    outline = mjs.model.outline(p, 0, 1, false); //third parameter is what type of corners, 0 (rounded) by default\n  } else {\n    console.log(\"offset\", offset);\n    outline = mjs.model.outline(p, params.compensatedRadius, 1, offset); //third parameter is what type of corners, 0 (rounded) by default\n  }\n  // outline = mjs.model.zero(outline);\n  // let chains = mjs.model.findChains(expansion);\n  let chain = mjs.model.findSingleChain(outline);\n\n  // console.log(\"outline\", outline, \"chain\", chain);\n\n  let divisions = Math.floor(chain.pathLength / params.minimumSpacing);\n  let spacing = chain.pathLength / divisions;\n  let keyPoints = mjs.chain.toKeyPoints(chain, spacing);\n\n  // let scaleFactor = 10;\n  // let scaleXY = keyPoints.map(p => [p[0] * scaleFactor, p[1] * scaleFactor]);\n\n  let gcodePoints = keyPoints.map(p => `G1 X${p[0]} Y${p[1]} F${params.feedRate}`)\n  //let gcode = JSON.parse(JSON.stringify(gcodePoints));\n\n  let firstPoint = keyPoints[0];\n\n  let paths = params.depthOfPasses.map((p,i) => [\n    `G1 Z${params.depthOfPasses[i]} F12.0`,\n    ...gcodePoints,\n    `G1 X${firstPoint[0]} Y${firstPoint[1]} F${params.feedRate}`\n  ])\n\n  paths = paths.flat(1);\n\n  let preamble = [params.units, \"G90\"];\n\n  let gcode = [\n    ...preamble,\n    \"(end of preamble)\",\n    `G1 Z${params.jogHeight} F${params.jogRate}`,\n    `G0 X${firstPoint[0]} Y${firstPoint[1]}`,\n    ...paths,\n    `G1 Z${params.jogHeight} F${params.jogRate}`,\n  ]\n\n  // write to a new file named\n  let filename = 'testGcodeProfile.gcode';\n\n  let text = gcode.join('\\n');\n\n  // console.log(\"profile\", outline)\n\n  return {drawing: outline, gcode: text, filename};\n};\n\n\nexport {profile};\n"]},"metadata":{},"sourceType":"module"}