{"ast":null,"code":"/* Copyright 2013 Google Inc. All Rights Reserved.\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n   http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n\n   Bit reading helpers\n*/\nvar BROTLI_READ_SIZE = 4096;\nvar BROTLI_IBUF_SIZE = 2 * BROTLI_READ_SIZE + 32;\nvar BROTLI_IBUF_MASK = 2 * BROTLI_READ_SIZE - 1;\nvar kBitMask = new Uint32Array([0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215]);\n/* Input byte buffer, consist of a ringbuffer and a \"slack\" region where */\n\n/* bytes from the start of the ringbuffer are copied. */\n\nfunction BrotliBitReader(input) {\n  this.buf_ = new Uint8Array(BROTLI_IBUF_SIZE);\n  this.input_ = input;\n  /* input callback */\n\n  this.reset();\n}\n\nBrotliBitReader.READ_SIZE = BROTLI_READ_SIZE;\nBrotliBitReader.IBUF_MASK = BROTLI_IBUF_MASK;\n\nBrotliBitReader.prototype.reset = function () {\n  this.buf_ptr_ = 0;\n  /* next input will write here */\n\n  this.val_ = 0;\n  /* pre-fetched bits */\n\n  this.pos_ = 0;\n  /* byte position in stream */\n\n  this.bit_pos_ = 0;\n  /* current bit-reading position in val_ */\n\n  this.bit_end_pos_ = 0;\n  /* bit-reading end position from LSB of val_ */\n\n  this.eos_ = 0;\n  /* input stream is finished */\n\n  this.readMoreInput();\n\n  for (var i = 0; i < 4; i++) {\n    this.val_ |= this.buf_[this.pos_] << 8 * i;\n    ++this.pos_;\n  }\n\n  return this.bit_end_pos_ > 0;\n};\n/* Fills up the input ringbuffer by calling the input callback.\n\n   Does nothing if there are at least 32 bytes present after current position.\n\n   Returns 0 if either:\n    - the input callback returned an error, or\n    - there is no more input and the position is past the end of the stream.\n\n   After encountering the end of the input stream, 32 additional zero bytes are\n   copied to the ringbuffer, therefore it is safe to call this function after\n   every 32 bytes of input is read.\n*/\n\n\nBrotliBitReader.prototype.readMoreInput = function () {\n  if (this.bit_end_pos_ > 256) {\n    return;\n  } else if (this.eos_) {\n    if (this.bit_pos_ > this.bit_end_pos_) throw new Error('Unexpected end of input ' + this.bit_pos_ + ' ' + this.bit_end_pos_);\n  } else {\n    var dst = this.buf_ptr_;\n    var bytes_read = this.input_.read(this.buf_, dst, BROTLI_READ_SIZE);\n\n    if (bytes_read < 0) {\n      throw new Error('Unexpected end of input');\n    }\n\n    if (bytes_read < BROTLI_READ_SIZE) {\n      this.eos_ = 1;\n      /* Store 32 bytes of zero after the stream end. */\n\n      for (var p = 0; p < 32; p++) {\n        this.buf_[dst + bytes_read + p] = 0;\n      }\n    }\n\n    if (dst === 0) {\n      /* Copy the head of the ringbuffer to the slack region. */\n      for (var p = 0; p < 32; p++) {\n        this.buf_[(BROTLI_READ_SIZE << 1) + p] = this.buf_[p];\n      }\n\n      this.buf_ptr_ = BROTLI_READ_SIZE;\n    } else {\n      this.buf_ptr_ = 0;\n    }\n\n    this.bit_end_pos_ += bytes_read << 3;\n  }\n};\n/* Guarantees that there are at least 24 bits in the buffer. */\n\n\nBrotliBitReader.prototype.fillBitWindow = function () {\n  while (this.bit_pos_ >= 8) {\n    this.val_ >>>= 8;\n    this.val_ |= this.buf_[this.pos_ & BROTLI_IBUF_MASK] << 24;\n    ++this.pos_;\n    this.bit_pos_ = this.bit_pos_ - 8 >>> 0;\n    this.bit_end_pos_ = this.bit_end_pos_ - 8 >>> 0;\n  }\n};\n/* Reads the specified number of bits from Read Buffer. */\n\n\nBrotliBitReader.prototype.readBits = function (n_bits) {\n  if (32 - this.bit_pos_ < n_bits) {\n    this.fillBitWindow();\n  }\n\n  var val = this.val_ >>> this.bit_pos_ & kBitMask[n_bits];\n  this.bit_pos_ += n_bits;\n  return val;\n};\n\nmodule.exports = BrotliBitReader;","map":null,"metadata":{},"sourceType":"script"}