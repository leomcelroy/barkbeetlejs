{"ast":null,"code":"var _classCallCheck = require(\"/Users/leomcelroy/Desktop/barkbeetle_js/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/leomcelroy/Desktop/barkbeetle_js/node_modules/@babel/runtime/helpers/createClass\");\n\nvar Box = require('../class/Box');\n\nvar Point = require('../class/Point');\n\nvar regex = require('./regex');\n\nvar matrixFactory = require('../class/SVGMatrix').matrixFactory;\n\nvar PointCloud = require('./PointCloud.js');\n\nvar NoBox = Box.NoBox;\nvar pathHandlers = {\n  M: function M(c, p, r, p0) {\n    p.x = p0.x = c[0];\n    p.y = p0.y = c[1];\n    return new Move(p);\n  },\n  L: function L(c, p) {\n    var ret = new Line(p.x, p.y, c[0], c[1]); // .offset(o)\n\n    p.x = c[0];\n    p.y = c[1];\n    return ret;\n  },\n  H: function H(c, p) {\n    return pathHandlers.L([c[0], p.y], p);\n  },\n  V: function V(c, p) {\n    return pathHandlers.L([p.x, c[0]], p);\n  },\n  Q: function Q(c, p, r) {\n    var ret = Cubic.fromQuad(p, new Point(c[0], c[1]), new Point(c[2], c[3])); // .offset(o)\n\n    p.x = c[2];\n    p.y = c[3];\n    var reflect = new Point(c[0], c[1]).reflectAt(p);\n    r.x = reflect.x;\n    r.y = reflect.y;\n    return ret;\n  },\n  T: function T(c, p, r, p0, reflectionIsPossible) {\n    if (reflectionIsPossible) {\n      c = [r.x, r.y].concat(c);\n    } else {\n      c = [p.x, p.y].concat(c);\n    }\n\n    return pathHandlers.Q(c, p, r);\n  },\n  C: function C(c, p, r) {\n    var ret = new Cubic(p, new Point(c[0], c[1]), new Point(c[2], c[3]), new Point(c[4], c[5])); // .offset(o)\n\n    p.x = c[4];\n    p.y = c[5];\n    var reflect = new Point(c[2], c[3]).reflectAt(p);\n    r.x = reflect.x;\n    r.y = reflect.y;\n    return ret;\n  },\n  S: function S(c, p, r, p0, reflectionIsPossible) {\n    // reflection makes only sense if this command was preceeded by another beziere command (QTSC)\n    if (reflectionIsPossible) {\n      c = [r.x, r.y].concat(c);\n    } else {\n      c = [p.x, p.y].concat(c);\n    }\n\n    return pathHandlers.C(c, p, r);\n  },\n  Z: function Z(c, p, r, p0) {\n    // FIXME: The behavior of Z depends on the command before\n    return pathHandlers.L([p0.x, p0.y], p);\n  },\n  A: function A(c, p, r) {\n    var ret = new Arc(p, new Point(c[5], c[6]), c[0], c[1], c[2], c[3], c[4]);\n    p.x = c[5];\n    p.y = c[6];\n    return ret;\n  }\n};\nvar mlhvqtcsa = 'mlhvqtcsaz'.split('');\n\nfor (var i = 0, il = mlhvqtcsa.length; i < il; ++i) {\n  pathHandlers[mlhvqtcsa[i]] = function (i) {\n    return function (c, p, r, p0, reflectionIsPossible) {\n      if (i === 'H') c[0] = c[0] + p.x;else if (i === 'V') c[0] = c[0] + p.y;else if (i === 'A') {\n        c[5] = c[5] + p.x;\n        c[6] = c[6] + p.y;\n      } else {\n        for (var j = 0, jl = c.length; j < jl; ++j) {\n          c[j] = c[j] + (j % 2 ? p.y : p.x);\n        }\n      }\n      return pathHandlers[i](c, p, r, p0, reflectionIsPossible);\n    };\n  }(mlhvqtcsa[i].toUpperCase());\n}\n\nfunction pathRegReplace(a, b, c, d) {\n  return c + d.replace(regex.dots, ' .');\n}\n\nfunction isBeziere(obj) {\n  return obj instanceof Cubic;\n}\n\nvar pathParser = function pathParser(array) {\n  // prepare for parsing\n  var paramCnt = {\n    'M': 2,\n    'L': 2,\n    'H': 1,\n    'V': 1,\n    'C': 6,\n    'S': 4,\n    'Q': 4,\n    'T': 2,\n    'A': 7,\n    'Z': 0\n  };\n  array = array.replace(regex.numbersWithDots, pathRegReplace) // convert 45.123.123 to 45.123 .123\n  .replace(regex.pathLetters, ' $& ') // put some room between letters and numbers\n  .replace(regex.hyphen, '$1 -') // add space before hyphen\n  .trim() // trim\n  .split(regex.delimiter); // split into array\n  // array now is an array containing all parts of a path e.g. ['M', '0', '0', 'L', '30', '30' ...]\n\n  var arr = [];\n  var p = new Point();\n  var p0 = new Point();\n  var r = new Point();\n  var index = 0;\n  var len = array.length;\n  var s;\n\n  do {\n    // Test if we have a path letter\n    if (regex.isPathLetter.test(array[index])) {\n      s = array[index];\n      ++index; // If last letter was a move command and we got no new, it defaults to [L]ine\n    } else if (s === 'M') {\n      s = 'L';\n    } else if (s === 'm') {\n      s = 'l';\n    }\n\n    arr.push(pathHandlers[s].call(null, array.slice(index, index = index + paramCnt[s.toUpperCase()]).map(parseFloat), p, r, p0, isBeziere(arr[arr.length - 1])));\n  } while (len > index);\n\n  return arr;\n};\n\nvar Move =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  function Move(p) {\n    _classCallCheck(this, Move);\n\n    this.p1 = p.clone();\n  }\n\n  _createClass(Move, [{\n    key: \"getCloud\",\n    value: function getCloud() {\n      return new PointCloud([this.p1]);\n    } // FIXME: Use pointcloud\n\n  }, {\n    key: \"bbox\",\n    value: function bbox() {\n      var p = this.p1;\n      return new Box(p.x, p.y, 0, 0);\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      return 0;\n    }\n  }, {\n    key: \"toPath\",\n    value: function toPath() {\n      return ['M', this.p1.x, this.p1.y].join(' ');\n    }\n  }, {\n    key: \"toPathFragment\",\n    value: function toPathFragment() {\n      return ['M', this.p1.x, this.p1.y];\n    }\n  }]);\n\n  return Move;\n}();\n\nvar Arc =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  function Arc(p1, p2, rx, ry, φ, arc, sweep) {\n    _classCallCheck(this, Arc);\n\n    this.p1 = p1.clone();\n    this.p2 = p2.clone();\n    this.arc = arc ? 1 : 0;\n    this.sweep = sweep ? 1 : 0;\n    var cosφ = Math.cos(φ / 180 * Math.PI);\n    var sinφ = Math.sin(φ / 180 * Math.PI);\n    var p1_ = new Point((p1.x - p2.x) / 2, (p1.y - p2.y) / 2).transform(matrixFactory(cosφ, -sinφ, sinφ, cosφ, 0, 0));\n    var ratio = p1_.x * p1_.x / (rx * rx) + p1_.y * p1_.y / (ry * ry);\n\n    if (ratio > 1) {\n      rx = Math.sqrt(ratio) * rx;\n      ry = Math.sqrt(ratio) * ry;\n    }\n\n    var divisor1 = rx * rx * p1_.y * p1_.y;\n    var divisor2 = ry * ry * p1_.x * p1_.x;\n    var c_ = new Point(rx * p1_.y / ry, -ry * p1_.x / rx).mul(Math.sqrt(Math.round((rx * rx * ry * ry - divisor1 - divisor2) * 100000) / 100000 // -------------------------------//\n    / (divisor1 + divisor2)));\n    if (this.arc === this.sweep) c_ = c_.mul(-1);\n    var c = c_.transform(matrixFactory(cosφ, sinφ, -sinφ, cosφ, 0, 0)).add(new Point((p1.x + p2.x) / 2, (p1.y + p2.y) / 2));\n    var anglePoint = new Point((p1_.x - c_.x) / rx, (p1_.y - c_.y) / ry);\n    var θ = new Point(1, 0).angleTo(anglePoint);\n    var Δθ = anglePoint.angleTo(new Point((-p1_.x - c_.x) / rx, (-p1_.y - c_.y) / ry));\n    Δθ = Δθ % (2 * Math.PI);\n    if (!sweep && Δθ > 0) Δθ -= 2 * Math.PI;\n    if (sweep && Δθ < 0) Δθ += 2 * Math.PI;\n    this.c = c;\n    this.theta = θ * 180 / Math.PI;\n    this.theta2 = (θ + Δθ) * 180 / Math.PI;\n    this.delta = Δθ * 180 / Math.PI;\n    this.rx = rx;\n    this.ry = ry;\n    this.phi = φ;\n    this.cosφ = cosφ;\n    this.sinφ = sinφ;\n  }\n\n  _createClass(Arc, [{\n    key: \"pointAt\",\n    value: function pointAt(t) {\n      var tInAngle = (this.theta + t * this.delta) / 180 * Math.PI;\n      var sinθ = Math.sin(tInAngle);\n      var cosθ = Math.cos(tInAngle);\n      return new Point(this.cosφ * this.rx * cosθ - this.sinφ * this.ry * sinθ + this.c.x, this.sinφ * this.rx * cosθ + this.cosφ * this.ry * sinθ + this.c.y);\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      var length = this.p2.sub(this.p1).abs();\n      var ret = this.splitAt(0.5);\n      var len1 = ret[0].p2.sub(ret[0].p1).abs();\n      var len2 = ret[1].p2.sub(ret[1].p1).abs();\n\n      if (len1 + len2 - length < 0.00001) {\n        return len1 + len2;\n      }\n\n      return ret[0].length() + ret[1].length();\n    }\n  }, {\n    key: \"splitAt\",\n    value: function splitAt(t) {\n      var absDelta = Math.abs(this.delta);\n      var delta1 = absDelta * t;\n      var delta2 = absDelta * (1 - t);\n      return [new Arc(this.p1, this.pointAt(t), this.rx, this.ry, this.phi, delta1 > 180, this.sweep), new Arc(this.pointAt(t), this.p2, this.rx, this.ry, this.phi, delta2 > 180, this.sweep)];\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Arc(this.p1, this.p2, this.rx, this.ry, this.phi, this.arc, this.sweep);\n    }\n  }, {\n    key: \"getCloud\",\n    value: function getCloud() {\n      // arc could be rotated. the min and max values then dont lie on multiples of 90 degress but are shifted by the rotation angle\n      // so we first calculate our 0/90 degree angle\n      var θ01 = Math.atan(-this.sinφ / this.cosφ * this.ry / this.rx) * 180 / Math.PI;\n      var θ02 = Math.atan(this.cosφ / this.sinφ * this.ry / this.rx) * 180 / Math.PI;\n      var θ1 = this.theta;\n      var θ2 = this.theta2;\n\n      if (θ1 < 0 || θ2 < 0) {\n        θ1 += 360;\n        θ2 += 360;\n      }\n\n      if (θ2 < θ1) {\n        var temp = θ1;\n        θ1 = θ2;\n        θ2 = temp;\n      }\n\n      while (θ01 - 90 > θ01) {\n        θ01 -= 90;\n      }\n\n      while (θ01 < θ1) {\n        θ01 += 90;\n      }\n\n      while (θ02 - 90 > θ02) {\n        θ02 -= 90;\n      }\n\n      while (θ02 < θ1) {\n        θ02 += 90;\n      }\n\n      var angleToTest = [θ01, θ02, θ01 + 90, θ02 + 90, θ01 + 180, θ02 + 180, θ01 + 270, θ02 + 270];\n      var points = angleToTest.filter(function (angle) {\n        return angle > θ1 && angle < θ2;\n      }).map(function (angle) {\n        while (this.theta < angle) {\n          angle -= 360;\n        }\n\n        return this.pointAt((angle - this.theta) % 360 / this.delta); // TODO: replace that call with pointAtAngle\n      }.bind(this)).concat(this.p1, this.p2);\n      return new PointCloud(points);\n    }\n  }, {\n    key: \"bbox\",\n    value: function bbox() {\n      var cloud = this.getCloud();\n      return cloud.bbox();\n    }\n  }, {\n    key: \"toPathFragment\",\n    value: function toPathFragment() {\n      return ['A', this.rx, this.ry, this.phi, this.arc, this.sweep, this.p2.x, this.p2.y];\n    }\n  }, {\n    key: \"toPath\",\n    value: function toPath() {\n      return ['M', this.p1.x, this.p1.y, 'A', this.rx, this.ry, this.phi, this.arc, this.sweep, this.p2.x, this.p2.y].join(' ');\n    }\n  }], [{\n    key: \"fromCenterForm\",\n    value: function fromCenterForm(c, rx, ry, φ, θ, Δθ) {\n      var cosφ = Math.cos(φ / 180 * Math.PI);\n      var sinφ = Math.sin(φ / 180 * Math.PI);\n      var m = matrixFactory(cosφ, sinφ, -sinφ, cosφ, 0, 0);\n      var p1 = new Point(rx * Math.cos(θ / 180 * Math.PI), ry * Math.sin(θ / 180 * Math.PI)).transform(m).add(c);\n      var p2 = new Point(rx * Math.cos((θ + Δθ) / 180 * Math.PI), ry * Math.sin((θ + Δθ) / 180 * Math.PI)).transform(m).add(c);\n      var arc = Math.abs(Δθ) > 180 ? 1 : 0;\n      var sweep = Δθ > 0 ? 1 : 0;\n      return new Arc(p1, p2, rx, ry, φ, arc, sweep);\n    }\n  }]);\n\n  return Arc;\n}();\n\nvar Cubic =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  function Cubic(p1, c1, c2, p2) {\n    _classCallCheck(this, Cubic);\n\n    if (p1 instanceof Point) {\n      this.p1 = new Point(p1);\n      this.c1 = new Point(c1);\n      this.c2 = new Point(c2);\n      this.p2 = new Point(p2);\n    } else {\n      this.p1 = new Point(p1.p1);\n      this.c1 = new Point(p1.c1);\n      this.c2 = new Point(p1.c2);\n      this.p2 = new Point(p1.p2);\n    }\n  }\n\n  _createClass(Cubic, [{\n    key: \"pointAt\",\n    value: function pointAt(t) {\n      return new Point((1 - t) * (1 - t) * (1 - t) * this.p1.x + 3 * (1 - t) * (1 - t) * t * this.c1.x + 3 * (1 - t) * t * t * this.c2.x + t * t * t * this.p2.x, (1 - t) * (1 - t) * (1 - t) * this.p1.y + 3 * (1 - t) * (1 - t) * t * this.c1.y + 3 * (1 - t) * t * t * this.c2.y + t * t * t * this.p2.y);\n    }\n  }, {\n    key: \"findRootsX\",\n    value: function findRootsX() {\n      return this.findRootsXY(this.p1.x, this.c1.x, this.c2.x, this.p2.x);\n    }\n  }, {\n    key: \"findRootsY\",\n    value: function findRootsY() {\n      return this.findRootsXY(this.p1.y, this.c1.y, this.c2.y, this.p2.y);\n    }\n  }, {\n    key: \"findRootsXY\",\n    value: function findRootsXY(p1, p2, p3, p4) {\n      var a = 3 * (-p1 + 3 * p2 - 3 * p3 + p4);\n      var b = 6 * (p1 - 2 * p2 + p3);\n      var c = 3 * (p2 - p1);\n      if (a === 0) return [-c / b].filter(function (el) {\n        return el > 0 && el < 1;\n      });\n      if (b * b - 4 * a * c < 0) return [];\n      if (b * b - 4 * a * c === 0) return [Math.round(-b / (2 * a) * 100000) / 100000].filter(function (el) {\n        return el > 0 && el < 1;\n      });\n      return [Math.round((-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a) * 100000) / 100000, Math.round((-b - Math.sqrt(b * b - 4 * a * c)) / (2 * a) * 100000) / 100000].filter(function (el) {\n        return el > 0 && el < 1;\n      });\n    }\n  }, {\n    key: \"findRoots\",\n    value: function findRoots() {\n      return this.findRootsX().concat(this.findRootsY());\n    }\n  }, {\n    key: \"lengthAt\",\n    value: function lengthAt() {\n      var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var curves = this.splitAt(t)[0].makeFlat(t);\n      var length = 0;\n\n      for (var i = 0, len = curves.length; i < len; ++i) {\n        length += curves[i].p2.sub(curves[i].p1).abs();\n      }\n\n      return length;\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      return this.lengthAt();\n    }\n  }, {\n    key: \"flatness\",\n    value: function flatness() {\n      var ux = Math.pow(3 * this.c1.x - 2 * this.p1.x - this.p2.x, 2);\n      var uy = Math.pow(3 * this.c1.y - 2 * this.p1.y - this.p2.y, 2);\n      var vx = Math.pow(3 * this.c2.x - 2 * this.p2.x - this.p1.x, 2);\n      var vy = Math.pow(3 * this.c2.y - 2 * this.p2.y - this.p1.y, 2);\n\n      if (ux < vx) {\n        ux = vx;\n      }\n\n      if (uy < vy) {\n        uy = vy;\n      }\n\n      return ux + uy;\n    }\n  }, {\n    key: \"makeFlat\",\n    value: function makeFlat(t) {\n      if (this.flatness() > 0.15) {\n        return this.splitAt(0.5).map(function (el) {\n          return el.makeFlat(t * 0.5);\n        }).reduce(function (last, current) {\n          return last.concat(current);\n        }, []);\n      } else {\n        this.t_value = t;\n        return [this];\n      }\n    }\n  }, {\n    key: \"splitAtScalar\",\n    value: function splitAtScalar(z, p) {\n      var p1 = this.p1[p];\n      var p2 = this.c1[p];\n      var p3 = this.c2[p];\n      var p4 = this.p2[p];\n      var t = z * z * z * p4 - 3 * z * z * (z - 1) * p3 + 3 * z * (z - 1) * (z - 1) * p2 - (z - 1) * (z - 1) * (z - 1) * p1;\n      return [[p1, z * p2 - (z - 1) * p1, z * z * p3 - 2 * z * (z - 1) * p2 + (z - 1) * (z - 1) * p1, t], [t, z * z * p4 - 2 * z * (z - 1) * p3 + (z - 1) * (z - 1) * p2, z * p4 - (z - 1) * p3, p4]];\n    }\n  }, {\n    key: \"splitAt\",\n    value: function splitAt(z) {\n      var x = this.splitAtScalar(z, 'x');\n      var y = this.splitAtScalar(z, 'y');\n      var a = new Cubic(new Point(x[0][0], y[0][0]), new Point(x[0][1], y[0][1]), new Point(x[0][2], y[0][2]), new Point(x[0][3], y[0][3]));\n      var b = new Cubic(new Point(x[1][0], y[1][0]), new Point(x[1][1], y[1][1]), new Point(x[1][2], y[1][2]), new Point(x[1][3], y[1][3]));\n      return [a, b];\n    }\n  }, {\n    key: \"getCloud\",\n    value: function getCloud() {\n      var _this = this;\n\n      var points = this.findRoots().filter(function (root) {\n        return root !== 0 && root !== 1;\n      }).map(function (root) {\n        return _this.pointAt(root);\n      }).concat(this.p1, this.p2);\n      return new PointCloud(points);\n    }\n  }, {\n    key: \"bbox\",\n    value: function bbox() {\n      return this.getCloud().bbox();\n    }\n  }, {\n    key: \"toPathFragment\",\n    value: function toPathFragment() {\n      return ['C', this.c1.x, this.c1.y, this.c2.x, this.c2.y, this.p2.x, this.p2.y];\n    }\n  }, {\n    key: \"toPath\",\n    value: function toPath() {\n      return ['M', this.p1.x, this.p1.y].concat(this.toPathFragment()).join(' ');\n    }\n  }], [{\n    key: \"fromQuad\",\n    value: function fromQuad(p1, c, p2) {\n      var c1 = p1.mul(1 / 3).add(c.mul(2 / 3));\n      var c2 = c.mul(2 / 3).add(p2.mul(1 / 3));\n      return new Cubic(p1, c1, c2, p2);\n    }\n  }]);\n\n  return Cubic;\n}();\n\nvar Line =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  function Line(x1, y1, x2, y2) {\n    _classCallCheck(this, Line);\n\n    if (x1 instanceof Object) {\n      this.p1 = new Point(x1);\n      this.p2 = new Point(y1);\n    } else {\n      this.p1 = new Point(x1, y1);\n      this.p2 = new Point(x2, y2);\n    }\n  }\n\n  _createClass(Line, [{\n    key: \"getCloud\",\n    value: function getCloud() {\n      return new PointCloud([this.p1, this.p2]);\n    }\n  }, {\n    key: \"bbox\",\n    value: function bbox() {\n      return this.getCloud().bbox();\n    }\n  }, {\n    key: \"pointAt\",\n    value: function pointAt(t) {\n      var vec = this.p2.sub(this.p1).mul(t);\n      return this.p1.add(vec);\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      return this.p2.sub(this.p1).abs();\n    }\n  }, {\n    key: \"toPath\",\n    value: function toPath() {\n      return ['M', this.p1.x, this.p1.y, this.p2.x, this.p2.y].join(' ');\n    }\n  }, {\n    key: \"toPathFragment\",\n    value: function toPathFragment() {\n      return ['L', this.p2.x, this.p2.y];\n    }\n  }]);\n\n  return Line;\n}();\n\nvar bbox = function bbox(d) {\n  return pathParser(d).reduce(function (l, c) {\n    return l.merge(c.bbox());\n  }, new NoBox());\n};\n\nvar pointAtLength = function pointAtLength(d, len) {\n  var segs = pathParser(d);\n  var segLengths = segs.map(function (el) {\n    return el.length();\n  });\n  var length = segLengths.reduce(function (l, c) {\n    return l + c;\n  }, 0);\n  var i = 0;\n  var t = len / length; // FIXME: Pop Move before using shortcut?\n  // shortcut for trivial cases\n\n  if (t >= 1) {\n    // Check if there is a p2. If not, use p1\n    if (segs[segs.length - 1].p2) {\n      return segs[segs.length - 1].p2.native();\n    } else {\n      return segs[segs.length - 1].p1.native();\n    }\n  }\n\n  if (t <= 0) return segs[0].p1.native(); // remove move commands at the very end of the path\n\n  while (segs[segs.length - 1] instanceof Move) {\n    segs.pop();\n  }\n\n  var segEnd = 0;\n\n  for (il = segLengths.length; i < il; ++i) {\n    var k = segLengths[i] / length;\n    segEnd += k;\n\n    if (segEnd > t) {\n      break;\n    }\n  }\n\n  var ratio = length / segLengths[i];\n  t = ratio * (t - segEnd) + 1;\n  return segs[i].pointAt(t).native();\n};\n\nvar length = function length(d) {\n  return pathParser(d).reduce(function (l, c) {\n    return l + c.length();\n  }, 0);\n};\n\nvar debug = function debug(node) {\n  var parse = pathParser(node.getAttribute('d'));\n  var ret = {\n    paths: parse.map(function (el) {\n      return el.toPath();\n    }),\n    fragments: parse.map(function (el) {\n      return el.toPathFragment().join(' ');\n    }),\n    bboxs: parse.map(function (el) {\n      var box = el.bbox();\n      return [box.x, box.y, box.width, box.height];\n    }),\n    bbox: parse.reduce(function (l, c) {\n      return l.merge(c.bbox());\n    }, new NoBox()),\n    bboxs_new: parse.map(function (el) {\n      return el.getCloud().transform(node.matrixify()).bbox();\n    })\n  };\n  return Object.assign({}, ret, {\n    bbox_new: ret.bboxs_new.reduce(function (l, c) {\n      return l.merge(c);\n    }, new NoBox())\n  });\n};\n\nvar getCloud = function getCloud(d) {\n  return pathParser(d).reduce(function (cloud, segment) {\n    return segment.getCloud().merge(cloud);\n  }, new PointCloud());\n};\n\nvar pathFrom = {\n  box: function box(_ref) {\n    var x = _ref.x,\n        y = _ref.y,\n        width = _ref.width,\n        height = _ref.height;\n    return \"M \".concat(x, \" \").concat(y, \" h \").concat(width, \" v \").concat(height, \" H \").concat(x, \" V \").concat(y);\n  },\n  rect: function rect(node) {\n    var width = parseFloat(node.getAttribute('width')) || 0;\n    var height = parseFloat(node.getAttribute('height')) || 0;\n    var x = parseFloat(node.getAttribute('x')) || 0;\n    var y = parseFloat(node.getAttribute('y')) || 0;\n    return \"M \".concat(x, \" \").concat(y, \" h \").concat(width, \" v \").concat(height, \" H \").concat(x, \" V \").concat(y);\n  },\n  circle: function circle(node) {\n    var r = parseFloat(node.getAttribute('r')) || 0;\n    var x = parseFloat(node.getAttribute('cx')) || 0;\n    var y = parseFloat(node.getAttribute('cy')) || 0;\n    if (r === 0) return 'M0 0';\n    return \"M \".concat(x - r, \" \").concat(y, \" A \").concat(r, \" \").concat(r, \" 0 0 0 \").concat(x + r, \" \").concat(y, \" A \").concat(r, \" \").concat(r, \" 0 0 0 \").concat(x - r, \" \").concat(y);\n  },\n  ellipse: function ellipse(node) {\n    var rx = parseFloat(node.getAttribute('rx')) || 0;\n    var ry = parseFloat(node.getAttribute('ry')) || 0;\n    var x = parseFloat(node.getAttribute('cx')) || 0;\n    var y = parseFloat(node.getAttribute('cy')) || 0;\n    return \"M \".concat(x - rx, \" \").concat(y, \" A \").concat(rx, \" \").concat(ry, \" 0 0 0 \").concat(x + rx, \" \").concat(y, \" A \").concat(rx, \" \").concat(ry, \" 0 0 0 \").concat(x - rx, \" \").concat(y);\n  },\n  line: function line(node) {\n    var x1 = parseFloat(node.getAttribute('x1')) || 0;\n    var x2 = parseFloat(node.getAttribute('x2')) || 0;\n    var y1 = parseFloat(node.getAttribute('y1')) || 0;\n    var y2 = parseFloat(node.getAttribute('y2')) || 0;\n    return \"M \".concat(x1, \" \").concat(y1, \" L \").concat(x2, \" \").concat(y2);\n  },\n  polygon: function polygon(node) {\n    return \"M \".concat(node.getAttribute('points'), \" z\");\n  },\n  polyline: function polyline(node) {\n    return \"M \".concat(node.getAttribute('points'));\n  }\n};\nmodule.exports = {\n  bbox: bbox,\n  pointAtLength: pointAtLength,\n  length: length,\n  debug: debug,\n  Arc: Arc,\n  pathParser: pathParser,\n  pathFrom: pathFrom,\n  getCloud: getCloud\n};","map":null,"metadata":{},"sourceType":"script"}