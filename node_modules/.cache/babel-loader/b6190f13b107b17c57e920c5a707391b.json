{"ast":null,"code":"/*\n * Copyright 2016 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the terms of the LICENSE file distributed with this project.\n */\nimport * as tslib_1 from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { AbstractPureComponent } from \"../../common/abstractPureComponent\";\nimport * as Classes from \"../../common/classes\";\nimport * as Keys from \"../../common/keys\";\nimport { DISPLAYNAME_PREFIX } from \"../../common/props\";\nimport { clamp, safeInvoke } from \"../../common/utils\";\nimport { formatPercentage } from \"./sliderUtils\"; // props that require number values, for validation\n\nvar NUMBER_PROPS = [\"max\", \"min\", \"stepSize\", \"tickSize\", \"value\"];\n/** Internal component for a Handle with click/drag/keyboard logic to determine a new value. */\n\nvar Handle =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(Handle, _super);\n\n  function Handle() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      isMoving: false\n    };\n    _this.refHandlers = {\n      handle: function handle(el) {\n        return _this.handleElement = el;\n      }\n    };\n\n    _this.beginHandleMovement = function (event) {\n      document.addEventListener(\"mousemove\", _this.handleHandleMovement);\n      document.addEventListener(\"mouseup\", _this.endHandleMovement);\n\n      _this.setState({\n        isMoving: true\n      });\n\n      _this.changeValue(_this.clientToValue(_this.mouseEventClientOffset(event)));\n    };\n\n    _this.beginHandleTouchMovement = function (event) {\n      document.addEventListener(\"touchmove\", _this.handleHandleTouchMovement);\n      document.addEventListener(\"touchend\", _this.endHandleTouchMovement);\n      document.addEventListener(\"touchcancel\", _this.endHandleTouchMovement);\n\n      _this.setState({\n        isMoving: true\n      });\n\n      _this.changeValue(_this.clientToValue(_this.touchEventClientOffset(event)));\n    };\n\n    _this.endHandleMovement = function (event) {\n      _this.handleMoveEndedAt(_this.mouseEventClientOffset(event));\n    };\n\n    _this.endHandleTouchMovement = function (event) {\n      _this.handleMoveEndedAt(_this.touchEventClientOffset(event));\n    };\n\n    _this.handleMoveEndedAt = function (clientPixel) {\n      _this.removeDocumentEventListeners();\n\n      _this.setState({\n        isMoving: false\n      }); // always invoke onRelease; changeValue may call onChange if value is different\n\n\n      var onRelease = _this.props.onRelease;\n\n      var finalValue = _this.changeValue(_this.clientToValue(clientPixel));\n\n      safeInvoke(onRelease, finalValue);\n    };\n\n    _this.handleHandleMovement = function (event) {\n      _this.handleMovedTo(_this.mouseEventClientOffset(event));\n    };\n\n    _this.handleHandleTouchMovement = function (event) {\n      _this.handleMovedTo(_this.touchEventClientOffset(event));\n    };\n\n    _this.handleMovedTo = function (clientPixel) {\n      if (_this.state.isMoving && !_this.props.disabled) {\n        _this.changeValue(_this.clientToValue(clientPixel));\n      }\n    };\n\n    _this.handleKeyDown = function (event) {\n      var _a = _this.props,\n          stepSize = _a.stepSize,\n          value = _a.value;\n      var which = event.which;\n\n      if (which === Keys.ARROW_DOWN || which === Keys.ARROW_LEFT) {\n        _this.changeValue(value - stepSize); // this key event has been handled! prevent browser scroll on up/down\n\n\n        event.preventDefault();\n      } else if (which === Keys.ARROW_UP || which === Keys.ARROW_RIGHT) {\n        _this.changeValue(value + stepSize);\n\n        event.preventDefault();\n      }\n    };\n\n    _this.handleKeyUp = function (event) {\n      if ([Keys.ARROW_UP, Keys.ARROW_DOWN, Keys.ARROW_LEFT, Keys.ARROW_RIGHT].indexOf(event.which) >= 0) {\n        safeInvoke(_this.props.onRelease, _this.props.value);\n      }\n    };\n\n    return _this;\n  }\n\n  Handle.prototype.componentDidMount = function () {\n    // The first time this component renders, it has no ref to the handle and thus incorrectly centers the handle.\n    // Therefore, on the first mount, force a re-render to center the handle with the ref'd component.\n    this.forceUpdate();\n  };\n\n  Handle.prototype.render = function () {\n    var _a = this.props,\n        className = _a.className,\n        disabled = _a.disabled,\n        label = _a.label,\n        min = _a.min,\n        tickSizeRatio = _a.tickSizeRatio,\n        value = _a.value,\n        vertical = _a.vertical;\n    var isMoving = this.state.isMoving; // The handle midpoint of RangeSlider is actually shifted by a margin to\n    // be on the edge of the visible handle element. Because the midpoint\n    // calculation does not take this margin into account, we instead\n    // measure the long side (which is equal to the short side plus the\n    // margin).\n\n    var handleMidpoint = this.getHandleMidpointAndOffset(this.handleElement, true).handleMidpoint;\n    var offsetRatio = (value - min) * tickSizeRatio;\n    var offsetCalc = \"calc(\" + formatPercentage(offsetRatio) + \" - \" + handleMidpoint + \"px)\";\n    var style = vertical ? {\n      bottom: offsetCalc\n    } : {\n      left: offsetCalc\n    };\n    return React.createElement(\"span\", {\n      className: classNames(Classes.SLIDER_HANDLE, (_b = {}, _b[Classes.ACTIVE] = isMoving, _b), className),\n      onKeyDown: disabled ? null : this.handleKeyDown,\n      onKeyUp: disabled ? null : this.handleKeyUp,\n      onMouseDown: disabled ? null : this.beginHandleMovement,\n      onTouchStart: disabled ? null : this.beginHandleTouchMovement,\n      ref: this.refHandlers.handle,\n      style: style,\n      tabIndex: 0\n    }, label == null ? null : React.createElement(\"span\", {\n      className: Classes.SLIDER_LABEL\n    }, label));\n\n    var _b;\n  };\n\n  Handle.prototype.componentWillUnmount = function () {\n    this.removeDocumentEventListeners();\n  };\n  /** Convert client pixel to value between min and max. */\n\n\n  Handle.prototype.clientToValue = function (clientPixel) {\n    var _a = this.props,\n        stepSize = _a.stepSize,\n        tickSize = _a.tickSize,\n        value = _a.value,\n        vertical = _a.vertical;\n\n    if (this.handleElement == null) {\n      return value;\n    } // #1769: this logic doesn't work perfectly when the tick size is\n    // smaller than the handle size; it may be off by a tick or two.\n\n\n    var clientPixelNormalized = vertical ? window.innerHeight - clientPixel : clientPixel;\n    var handleCenterPixel = this.getHandleElementCenterPixel(this.handleElement);\n    var pixelDelta = clientPixelNormalized - handleCenterPixel;\n\n    if (isNaN(pixelDelta)) {\n      return value;\n    } // convert pixels to range value in increments of `stepSize`\n\n\n    return value + Math.round(pixelDelta / (tickSize * stepSize)) * stepSize;\n  };\n\n  Handle.prototype.mouseEventClientOffset = function (event) {\n    return this.props.vertical ? event.clientY : event.clientX;\n  };\n\n  Handle.prototype.touchEventClientOffset = function (event) {\n    var touch = event.changedTouches[0];\n    return this.props.vertical ? touch.clientY : touch.clientX;\n  };\n\n  Handle.prototype.validateProps = function (props) {\n    for (var _i = 0, NUMBER_PROPS_1 = NUMBER_PROPS; _i < NUMBER_PROPS_1.length; _i++) {\n      var prop = NUMBER_PROPS_1[_i];\n\n      if (typeof props[prop] !== \"number\") {\n        throw new Error(\"[Blueprint] <Handle> requires number value for \" + prop + \" prop\");\n      }\n    }\n  };\n  /** Clamp value and invoke callback if it differs from current value */\n\n\n  Handle.prototype.changeValue = function (newValue, callback) {\n    if (callback === void 0) {\n      callback = this.props.onChange;\n    }\n\n    newValue = this.clamp(newValue);\n\n    if (!isNaN(newValue) && this.props.value !== newValue) {\n      safeInvoke(callback, newValue);\n    }\n\n    return newValue;\n  };\n  /** Clamp value between min and max props */\n\n\n  Handle.prototype.clamp = function (value) {\n    return clamp(value, this.props.min, this.props.max);\n  };\n\n  Handle.prototype.getHandleElementCenterPixel = function (handleElement) {\n    var _a = this.getHandleMidpointAndOffset(handleElement),\n        handleMidpoint = _a.handleMidpoint,\n        handleOffset = _a.handleOffset;\n\n    return handleOffset + handleMidpoint;\n  };\n\n  Handle.prototype.getHandleMidpointAndOffset = function (handleElement, useOppositeDimension) {\n    if (useOppositeDimension === void 0) {\n      useOppositeDimension = false;\n    }\n\n    if (handleElement == null) {\n      return {\n        handleMidpoint: 0,\n        handleOffset: 0\n      };\n    }\n\n    var vertical = this.props.vertical; // getBoundingClientRect().height includes border size; clientHeight does not.\n\n    var handleRect = handleElement.getBoundingClientRect();\n    var sizeKey = vertical ? useOppositeDimension ? \"width\" : \"height\" : useOppositeDimension ? \"height\" : \"width\"; // \"bottom\" value seems to be consistently incorrect, so explicitly\n    // calculate it using the window offset instead.\n\n    var handleOffset = vertical ? window.innerHeight - (handleRect.top + handleRect[sizeKey]) : handleRect.left;\n    return {\n      handleMidpoint: handleRect[sizeKey] / 2,\n      handleOffset: handleOffset\n    };\n  };\n\n  Handle.prototype.removeDocumentEventListeners = function () {\n    document.removeEventListener(\"mousemove\", this.handleHandleMovement);\n    document.removeEventListener(\"mouseup\", this.endHandleMovement);\n    document.removeEventListener(\"touchmove\", this.handleHandleTouchMovement);\n    document.removeEventListener(\"touchend\", this.endHandleTouchMovement);\n    document.removeEventListener(\"touchcancel\", this.endHandleTouchMovement);\n  };\n\n  Handle.displayName = DISPLAYNAME_PREFIX + \".SliderHandle\";\n  return Handle;\n}(AbstractPureComponent);\n\nexport { Handle };","map":null,"metadata":{},"sourceType":"module"}