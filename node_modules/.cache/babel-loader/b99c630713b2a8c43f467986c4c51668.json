{"ast":null,"code":"/*\n * Copyright 2017 Palantir Technologies, Inc. All rights reserved.\n *\n * Licensed under the terms of the LICENSE file distributed with this project.\n */\nimport * as tslib_1 from \"tslib\";\nimport classNames from \"classnames\";\nimport * as React from \"react\";\nimport { AbstractPureComponent, Classes, DISPLAYNAME_PREFIX, Keys, Position, removeNonHTMLProps, Utils } from \"../../common\";\nimport * as Errors from \"../../common/errors\";\nimport { ButtonGroup } from \"../button/buttonGroup\";\nimport { Button } from \"../button/buttons\";\nimport { ControlGroup } from \"./controlGroup\";\nimport { InputGroup } from \"./inputGroup\";\nimport { clampValue, getValueOrEmptyValue, isFloatingPointNumericCharacter, isValidNumericKeyboardEvent, isValueNumeric, toMaxPrecision } from \"./numericInputUtils\";\nvar IncrementDirection;\n\n(function (IncrementDirection) {\n  IncrementDirection[IncrementDirection[\"DOWN\"] = -1] = \"DOWN\";\n  IncrementDirection[IncrementDirection[\"UP\"] = 1] = \"UP\";\n})(IncrementDirection || (IncrementDirection = {}));\n\nvar NON_HTML_PROPS = [\"allowNumericCharactersOnly\", \"buttonPosition\", \"clampValueOnBlur\", \"className\", \"large\", \"majorStepSize\", \"minorStepSize\", \"onButtonClick\", \"onValueChange\", \"selectAllOnFocus\", \"selectAllOnIncrement\", \"stepSize\"];\n\nvar NumericInput =\n/** @class */\nfunction (_super) {\n  tslib_1.__extends(NumericInput, _super);\n\n  function NumericInput() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      shouldSelectAfterUpdate: false,\n      stepMaxPrecision: _this.getStepMaxPrecision(_this.props),\n      value: getValueOrEmptyValue(_this.props.value)\n    }; // updating these flags need not trigger re-renders, so don't include them in this.state.\n\n    _this.didPasteEventJustOccur = false;\n    _this.delta = 0;\n    _this.inputElement = null;\n    _this.intervalId = null;\n    _this.incrementButtonHandlers = _this.getButtonEventHandlers(IncrementDirection.UP);\n    _this.decrementButtonHandlers = _this.getButtonEventHandlers(IncrementDirection.DOWN);\n\n    _this.inputRef = function (input) {\n      _this.inputElement = input;\n      Utils.safeInvoke(_this.props.inputRef, input);\n    };\n\n    _this.handleButtonClick = function (e, direction) {\n      var delta = _this.updateDelta(direction, e);\n\n      var nextValue = _this.incrementValue(delta);\n\n      _this.invokeValueCallback(nextValue, _this.props.onButtonClick);\n    };\n\n    _this.stopContinuousChange = function () {\n      _this.delta = 0;\n\n      _this.clearTimeouts();\n\n      clearInterval(_this.intervalId);\n      document.removeEventListener(\"mouseup\", _this.stopContinuousChange);\n    };\n\n    _this.handleContinuousChange = function () {\n      var nextValue = _this.incrementValue(_this.delta);\n\n      _this.invokeValueCallback(nextValue, _this.props.onButtonClick);\n    }; // Callbacks - Input\n    // =================\n\n\n    _this.handleInputFocus = function (e) {\n      // update this state flag to trigger update for input selection (see componentDidUpdate)\n      _this.setState({\n        shouldSelectAfterUpdate: _this.props.selectAllOnFocus\n      });\n\n      Utils.safeInvoke(_this.props.onFocus, e);\n    };\n\n    _this.handleInputBlur = function (e) {\n      // always disable this flag on blur so it's ready for next time.\n      _this.setState({\n        shouldSelectAfterUpdate: false\n      });\n\n      if (_this.props.clampValueOnBlur) {\n        var value = e.target.value;\n\n        var sanitizedValue = _this.getSanitizedValue(value);\n\n        _this.setState({\n          value: sanitizedValue\n        });\n\n        if (value !== sanitizedValue) {\n          _this.invokeValueCallback(sanitizedValue, _this.props.onValueChange);\n        }\n      }\n\n      Utils.safeInvoke(_this.props.onBlur, e);\n    };\n\n    _this.handleInputKeyDown = function (e) {\n      if (_this.props.disabled || _this.props.readOnly) {\n        return;\n      }\n\n      var keyCode = e.keyCode;\n      var direction;\n\n      if (keyCode === Keys.ARROW_UP) {\n        direction = IncrementDirection.UP;\n      } else if (keyCode === Keys.ARROW_DOWN) {\n        direction = IncrementDirection.DOWN;\n      }\n\n      if (direction != null) {\n        // when the input field has focus, some key combinations will modify\n        // the field's selection range. we'll actually want to select all\n        // text in the field after we modify the value on the following\n        // lines. preventing the default selection behavior lets us do that\n        // without interference.\n        e.preventDefault();\n\n        var delta = _this.updateDelta(direction, e);\n\n        _this.incrementValue(delta);\n      }\n\n      Utils.safeInvoke(_this.props.onKeyDown, e);\n    };\n\n    _this.handleInputKeyPress = function (e) {\n      // we prohibit keystrokes in onKeyPress instead of onKeyDown, because\n      // e.key is not trustworthy in onKeyDown in all browsers.\n      if (_this.props.allowNumericCharactersOnly && !isValidNumericKeyboardEvent(e)) {\n        e.preventDefault();\n      }\n\n      Utils.safeInvoke(_this.props.onKeyPress, e);\n    };\n\n    _this.handleInputPaste = function (e) {\n      _this.didPasteEventJustOccur = true;\n      Utils.safeInvoke(_this.props.onPaste, e);\n    };\n\n    _this.handleInputChange = function (e) {\n      var value = e.target.value;\n      var nextValue = value;\n\n      if (_this.props.allowNumericCharactersOnly && _this.didPasteEventJustOccur) {\n        _this.didPasteEventJustOccur = false;\n        var valueChars = value.split(\"\");\n        var sanitizedValueChars = valueChars.filter(isFloatingPointNumericCharacter);\n        var sanitizedValue = sanitizedValueChars.join(\"\");\n        nextValue = sanitizedValue;\n      }\n\n      _this.setState({\n        shouldSelectAfterUpdate: false,\n        value: nextValue\n      });\n\n      _this.invokeValueCallback(nextValue, _this.props.onValueChange);\n    };\n\n    return _this;\n  }\n\n  NumericInput.prototype.componentWillReceiveProps = function (nextProps) {\n    _super.prototype.componentWillReceiveProps.call(this, nextProps);\n\n    var value = getValueOrEmptyValue(nextProps.value);\n    var didMinChange = nextProps.min !== this.props.min;\n    var didMaxChange = nextProps.max !== this.props.max;\n    var didBoundsChange = didMinChange || didMaxChange;\n    var sanitizedValue = value !== NumericInput.VALUE_EMPTY ? this.getSanitizedValue(value,\n    /* delta */\n    0, nextProps.min, nextProps.max) : NumericInput.VALUE_EMPTY;\n    var stepMaxPrecision = this.getStepMaxPrecision(nextProps); // if a new min and max were provided that cause the existing value to fall\n    // outside of the new bounds, then clamp the value to the new valid range.\n\n    if (didBoundsChange && sanitizedValue !== this.state.value) {\n      this.setState({\n        stepMaxPrecision: stepMaxPrecision,\n        value: sanitizedValue\n      });\n      this.invokeValueCallback(sanitizedValue, this.props.onValueChange);\n    } else {\n      this.setState({\n        stepMaxPrecision: stepMaxPrecision,\n        value: value\n      });\n    }\n  };\n\n  NumericInput.prototype.render = function () {\n    var _a = this.props,\n        buttonPosition = _a.buttonPosition,\n        className = _a.className,\n        fill = _a.fill,\n        large = _a.large;\n    var containerClasses = classNames(Classes.NUMERIC_INPUT, (_b = {}, _b[Classes.LARGE] = large, _b), className);\n    var buttons = this.renderButtons();\n    return React.createElement(ControlGroup, {\n      className: containerClasses,\n      fill: fill\n    }, buttonPosition === Position.LEFT && buttons, this.renderInput(), buttonPosition === Position.RIGHT && buttons);\n\n    var _b;\n  };\n\n  NumericInput.prototype.componentDidUpdate = function () {\n    if (this.state.shouldSelectAfterUpdate) {\n      this.inputElement.setSelectionRange(0, this.state.value.length);\n    }\n  };\n\n  NumericInput.prototype.validateProps = function (nextProps) {\n    var majorStepSize = nextProps.majorStepSize,\n        max = nextProps.max,\n        min = nextProps.min,\n        minorStepSize = nextProps.minorStepSize,\n        stepSize = nextProps.stepSize;\n\n    if (min != null && max != null && min >= max) {\n      throw new Error(Errors.NUMERIC_INPUT_MIN_MAX);\n    }\n\n    if (stepSize == null) {\n      throw new Error(Errors.NUMERIC_INPUT_STEP_SIZE_NULL);\n    }\n\n    if (stepSize <= 0) {\n      throw new Error(Errors.NUMERIC_INPUT_STEP_SIZE_NON_POSITIVE);\n    }\n\n    if (minorStepSize && minorStepSize <= 0) {\n      throw new Error(Errors.NUMERIC_INPUT_MINOR_STEP_SIZE_NON_POSITIVE);\n    }\n\n    if (majorStepSize && majorStepSize <= 0) {\n      throw new Error(Errors.NUMERIC_INPUT_MAJOR_STEP_SIZE_NON_POSITIVE);\n    }\n\n    if (minorStepSize && minorStepSize > stepSize) {\n      throw new Error(Errors.NUMERIC_INPUT_MINOR_STEP_SIZE_BOUND);\n    }\n\n    if (majorStepSize && majorStepSize < stepSize) {\n      throw new Error(Errors.NUMERIC_INPUT_MAJOR_STEP_SIZE_BOUND);\n    }\n  }; // Render Helpers\n  // ==============\n\n\n  NumericInput.prototype.renderButtons = function () {\n    var intent = this.props.intent;\n    var disabled = this.props.disabled || this.props.readOnly;\n    return React.createElement(ButtonGroup, {\n      className: Classes.FIXED,\n      key: \"button-group\",\n      vertical: true\n    }, React.createElement(Button, tslib_1.__assign({\n      disabled: disabled,\n      icon: \"chevron-up\",\n      intent: intent\n    }, this.incrementButtonHandlers)), React.createElement(Button, tslib_1.__assign({\n      disabled: disabled,\n      icon: \"chevron-down\",\n      intent: intent\n    }, this.decrementButtonHandlers)));\n  };\n\n  NumericInput.prototype.renderInput = function () {\n    var inputGroupHtmlProps = removeNonHTMLProps(this.props, NON_HTML_PROPS, true);\n    return React.createElement(InputGroup, tslib_1.__assign({\n      autoComplete: \"off\"\n    }, inputGroupHtmlProps, {\n      intent: this.props.intent,\n      inputRef: this.inputRef,\n      large: this.props.large,\n      leftIcon: this.props.leftIcon,\n      onFocus: this.handleInputFocus,\n      onBlur: this.handleInputBlur,\n      onChange: this.handleInputChange,\n      onKeyDown: this.handleInputKeyDown,\n      onKeyPress: this.handleInputKeyPress,\n      onPaste: this.handleInputPaste,\n      value: this.state.value\n    }));\n  }; // Callbacks - Buttons\n  // ===================\n\n\n  NumericInput.prototype.getButtonEventHandlers = function (direction) {\n    var _this = this;\n\n    return {\n      // keydown is fired repeatedly when held so it's implicitly continuous\n      onKeyDown: function onKeyDown(evt) {\n        if (Keys.isKeyboardClick(evt.keyCode)) {\n          _this.handleButtonClick(evt, direction);\n        }\n      },\n      onMouseDown: function onMouseDown(evt) {\n        _this.handleButtonClick(evt, direction);\n\n        _this.startContinuousChange();\n      }\n    };\n  };\n\n  NumericInput.prototype.startContinuousChange = function () {\n    var _this = this; // The button's onMouseUp event handler doesn't fire if the user\n    // releases outside of the button, so we need to watch all the way\n    // from the top.\n\n\n    document.addEventListener(\"mouseup\", this.stopContinuousChange); // Initial delay is slightly longer to prevent the user from\n    // accidentally triggering the continuous increment/decrement.\n\n    this.setTimeout(function () {\n      _this.intervalId = window.setInterval(_this.handleContinuousChange, NumericInput.CONTINUOUS_CHANGE_INTERVAL);\n    }, NumericInput.CONTINUOUS_CHANGE_DELAY);\n  };\n\n  NumericInput.prototype.invokeValueCallback = function (value, callback) {\n    Utils.safeInvoke(callback, +value, value);\n  }; // Value Helpers\n  // =============\n\n\n  NumericInput.prototype.incrementValue = function (delta) {\n    // pretend we're incrementing from 0 if currValue is empty\n    var currValue = this.state.value || NumericInput.VALUE_ZERO;\n    var nextValue = this.getSanitizedValue(currValue, delta);\n    this.setState({\n      shouldSelectAfterUpdate: this.props.selectAllOnIncrement,\n      value: nextValue\n    });\n    this.invokeValueCallback(nextValue, this.props.onValueChange);\n    return nextValue;\n  };\n\n  NumericInput.prototype.getIncrementDelta = function (direction, isShiftKeyPressed, isAltKeyPressed) {\n    var _a = this.props,\n        majorStepSize = _a.majorStepSize,\n        minorStepSize = _a.minorStepSize,\n        stepSize = _a.stepSize;\n\n    if (isShiftKeyPressed && majorStepSize != null) {\n      return direction * majorStepSize;\n    } else if (isAltKeyPressed && minorStepSize != null) {\n      return direction * minorStepSize;\n    } else {\n      return direction * stepSize;\n    }\n  };\n\n  NumericInput.prototype.getSanitizedValue = function (value, delta, min, max) {\n    if (delta === void 0) {\n      delta = 0;\n    }\n\n    if (min === void 0) {\n      min = this.props.min;\n    }\n\n    if (max === void 0) {\n      max = this.props.max;\n    }\n\n    if (!isValueNumeric(value)) {\n      return NumericInput.VALUE_EMPTY;\n    }\n\n    var nextValue = toMaxPrecision(parseFloat(value) + delta, this.state.stepMaxPrecision);\n    return clampValue(nextValue, min, max).toString();\n  };\n\n  NumericInput.prototype.getStepMaxPrecision = function (props) {\n    if (props.minorStepSize != null) {\n      return Utils.countDecimalPlaces(props.minorStepSize);\n    } else {\n      return Utils.countDecimalPlaces(props.stepSize);\n    }\n  };\n\n  NumericInput.prototype.updateDelta = function (direction, e) {\n    this.delta = this.getIncrementDelta(direction, e.shiftKey, e.altKey);\n    return this.delta;\n  };\n\n  NumericInput.displayName = DISPLAYNAME_PREFIX + \".NumericInput\";\n  NumericInput.VALUE_EMPTY = \"\";\n  NumericInput.VALUE_ZERO = \"0\";\n  NumericInput.defaultProps = {\n    allowNumericCharactersOnly: true,\n    buttonPosition: Position.RIGHT,\n    clampValueOnBlur: false,\n    large: false,\n    majorStepSize: 10,\n    minorStepSize: 0.1,\n    selectAllOnFocus: false,\n    selectAllOnIncrement: false,\n    stepSize: 1,\n    value: NumericInput.VALUE_EMPTY\n  };\n  NumericInput.CONTINUOUS_CHANGE_DELAY = 300;\n  NumericInput.CONTINUOUS_CHANGE_INTERVAL = 100;\n  return NumericInput;\n}(AbstractPureComponent);\n\nexport { NumericInput };","map":null,"metadata":{},"sourceType":"module"}