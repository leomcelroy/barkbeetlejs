{"ast":null,"code":"// Generated by PEG.js v0.11.0-master.30f3260, https://pegjs.org/\nfunction peg$subclass(child, parent) {\n  function C() {\n    this.constructor = child;\n  }\n\n  C.prototype = parent.prototype;\n  child.prototype = new C();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message = message;\n  this.expected = expected;\n  this.found = found;\n  this.location = location;\n  this.name = \"SyntaxError\"; // istanbul ignore next\n\n  if (typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\npeg$SyntaxError.buildMessage = function (expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n    literal: function literal(expectation) {\n      return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n    },\n    class: function _class(expectation) {\n      var escapedParts = expectation.parts.map(function (part) {\n        return Array.isArray(part) ? classEscape(part[0]) + \"-\" + classEscape(part[1]) : classEscape(part);\n      });\n      return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n    },\n    any: function any() {\n      return \"any character\";\n    },\n    end: function end() {\n      return \"end of input\";\n    },\n    other: function other(expectation) {\n      return expectation.description;\n    },\n    not: function not(expectation) {\n      return \"not \" + describeExpectation(expectation.expected);\n    }\n  };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, \"\\\\\\\"\").replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function (ch) {\n      return \"\\\\x0\" + hex(ch);\n    }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function (ch) {\n      return \"\\\\x\" + hex(ch);\n    });\n  }\n\n  function classEscape(s) {\n    return s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\]/g, \"\\\\]\").replace(/\\^/g, \"\\\\^\").replace(/-/g, \"\\\\-\").replace(/\\0/g, \"\\\\0\").replace(/\\t/g, \"\\\\t\").replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/[\\x00-\\x0F]/g, function (ch) {\n      return \"\\\\x0\" + hex(ch);\n    }).replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function (ch) {\n      return \"\\\\x\" + hex(ch);\n    });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = expected.map(describeExpectation);\n    var i, j;\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \") + \", or \" + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== undefined ? options : {};\n  var peg$FAILED = {};\n  var peg$startRuleFunctions = {\n    transformList: peg$parsetransformList\n  };\n  var peg$startRuleFunction = peg$parsetransformList;\n  var peg$c0 = \"matrix\";\n  var peg$c1 = \"(\";\n  var peg$c2 = \")\";\n  var peg$c3 = \"translate\";\n  var peg$c4 = \"scale\";\n  var peg$c5 = \"rotate\";\n  var peg$c6 = \"skewX\";\n  var peg$c7 = \"skewY\";\n  var peg$c8 = \",\";\n  var peg$c9 = \".\";\n  var peg$r0 = /^[eE]/;\n  var peg$r1 = /^[+\\-]/;\n  var peg$r2 = /^[0-9]/;\n  var peg$r3 = /^[ \\t\\r\\n]/;\n  var peg$e0 = peg$literalExpectation(\"matrix\", false);\n  var peg$e1 = peg$literalExpectation(\"(\", false);\n  var peg$e2 = peg$literalExpectation(\")\", false);\n  var peg$e3 = peg$literalExpectation(\"translate\", false);\n  var peg$e4 = peg$literalExpectation(\"scale\", false);\n  var peg$e5 = peg$literalExpectation(\"rotate\", false);\n  var peg$e6 = peg$literalExpectation(\"skewX\", false);\n  var peg$e7 = peg$literalExpectation(\"skewY\", false);\n  var peg$e8 = peg$literalExpectation(\",\", false);\n  var peg$e9 = peg$otherExpectation(\"fractionalConstant\");\n  var peg$e10 = peg$classExpectation([\"e\", \"E\"], false, false);\n  var peg$e11 = peg$classExpectation([\"+\", \"-\"], false, false);\n  var peg$e12 = peg$classExpectation([[\"0\", \"9\"]], false, false);\n  var peg$e13 = peg$classExpectation([\" \", \"\\t\", \"\\r\", \"\\n\"], false, false);\n\n  var peg$f0 = function peg$f0(ts) {\n    return ts;\n  };\n\n  var peg$f1 = function peg$f1(t, ts) {\n    return t.concat(ts);\n  };\n\n  var peg$f2 = function peg$f2(a, b, c, d, e, f) {\n    return [{\n      type: 'matrix',\n      a: a,\n      b: b,\n      c: c,\n      d: d,\n      e: e,\n      f: f\n    }];\n  };\n\n  var peg$f3 = function peg$f3(tx, ty) {\n    var t = {\n      type: 'translate',\n      tx: tx\n    };\n    if (ty) t.ty = ty;\n    return [t];\n  };\n\n  var peg$f4 = function peg$f4(sx, sy) {\n    var s = {\n      type: 'scale',\n      sx: sx\n    };\n    if (sy) s.sy = sy;\n    return [s];\n  };\n\n  var peg$f5 = function peg$f5(angle, c) {\n    var r = {\n      type: 'rotate',\n      angle: angle\n    };\n\n    if (c) {\n      r.cx = c[0];\n      r.cy = c[1];\n    }\n\n    return [r];\n  };\n\n  var peg$f6 = function peg$f6(angle) {\n    return [{\n      type: 'skewX',\n      angle: angle\n    }];\n  };\n\n  var peg$f7 = function peg$f7(angle) {\n    return [{\n      type: 'skewY',\n      angle: angle\n    }];\n  };\n\n  var peg$f8 = function peg$f8(f) {\n    return parseFloat(f.join(\"\"));\n  };\n\n  var peg$f9 = function peg$f9(i) {\n    return parseInt(i.join(\"\"));\n  };\n\n  var peg$f10 = function peg$f10(n) {\n    return n;\n  };\n\n  var peg$f11 = function peg$f11(n1, n2) {\n    return [n1, n2];\n  };\n\n  var peg$f12 = function peg$f12(ds) {\n    return ds.join(\"\");\n  };\n\n  var peg$f13 = function peg$f13(d1, d2) {\n    return [d1 ? d1.join(\"\") : null, \".\", d2.join(\"\")].join(\"\");\n  };\n\n  var peg$f14 = function peg$f14(d) {\n    return d.join(\"\");\n  };\n\n  var peg$currPos = 0;\n  var peg$savedPos = 0;\n  var peg$posDetailsCache = [{\n    line: 1,\n    column: 1\n  }];\n  var peg$expected = [];\n  var peg$silentFails = 0;\n  var peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$savedPos;\n  }\n\n  function range() {\n    return [peg$savedPos, peg$currPos];\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== undefined ? location : peg$computeLocation(peg$savedPos, peg$currPos);\n    throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);\n  }\n\n  function error(message, location) {\n    location = location !== undefined ? location : peg$computeLocation(peg$savedPos, peg$currPos);\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return {\n      type: \"literal\",\n      text: text,\n      ignoreCase: ignoreCase\n    };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return {\n      type: \"class\",\n      parts: parts,\n      inverted: inverted,\n      ignoreCase: ignoreCase\n    };\n  }\n\n  function peg$anyExpectation() {\n    return {\n      type: \"any\"\n    };\n  }\n\n  function peg$endExpectation() {\n    return {\n      type: \"end\"\n    };\n  }\n\n  function peg$otherExpectation(description) {\n    return {\n      type: \"other\",\n      description: description\n    };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos];\n    var p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n      return details;\n    }\n  }\n\n  var peg$VALIDFILENAME = typeof options.filename === \"string\" && options.filename.length > 0;\n\n  function peg$computeLocation(startPos, endPos) {\n    var loc = {};\n    if (peg$VALIDFILENAME) loc.filename = options.filename;\n    var startPosDetails = peg$computePosDetails(startPos);\n    loc.start = {\n      offset: startPos,\n      line: startPosDetails.line,\n      column: startPosDetails.column\n    };\n    var endPosDetails = peg$computePosDetails(endPos);\n    loc.end = {\n      offset: endPos,\n      line: endPosDetails.line,\n      column: endPosDetails.column\n    };\n    return loc;\n  }\n\n  function peg$begin() {\n    peg$expected.push({\n      pos: peg$currPos,\n      variants: []\n    });\n  }\n\n  function peg$expect(expected) {\n    var top = peg$expected[peg$expected.length - 1];\n\n    if (peg$currPos < top.pos) {\n      return;\n    }\n\n    if (peg$currPos > top.pos) {\n      top.pos = peg$currPos;\n      top.variants = [];\n    }\n\n    top.variants.push(expected);\n  }\n\n  function peg$end(invert) {\n    var expected = peg$expected.pop();\n    var top = peg$expected[peg$expected.length - 1];\n    var variants = expected.variants;\n\n    if (top.pos !== expected.pos) {\n      return;\n    }\n\n    if (invert) {\n      variants = variants.map(function (e) {\n        return e.type === \"not\" ? e.expected : {\n          type: \"not\",\n          expected: e\n        };\n      });\n    }\n\n    Array.prototype.push.apply(top.variants, variants);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);\n  }\n\n  function peg$buildError() {\n    var expected = peg$expected[0];\n    var failPos = expected.pos;\n    return peg$buildStructuredError(expected.variants, failPos < input.length ? input.charAt(failPos) : null, failPos < input.length ? peg$computeLocation(failPos, failPos + 1) : peg$computeLocation(failPos, failPos));\n  }\n\n  function peg$parsetransformList() {\n    var s0, s1, s2, s3, s4;\n\n    var rule$expects = function rule$expects(expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    };\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsewsp();\n\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parsewsp();\n    }\n\n    s2 = peg$parsetransforms();\n\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n\n    s3 = [];\n    s4 = peg$parsewsp();\n\n    while (s4 !== peg$FAILED) {\n      s3.push(s4);\n      s4 = peg$parsewsp();\n    }\n\n    peg$savedPos = s0;\n    s0 = peg$f0(s2);\n    return s0;\n  }\n\n  function peg$parsetransforms() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function rule$expects(expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    };\n\n    s0 = peg$currPos;\n    s1 = peg$parsetransform();\n\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsecommaWsp();\n\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsecommaWsp();\n        }\n      } else {\n        s2 = peg$FAILED;\n      }\n\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsetransforms();\n\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f1(s1, s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsetransform();\n    }\n\n    return s0;\n  }\n\n  function peg$parsetransform() {\n    var s0;\n\n    var rule$expects = function rule$expects(expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    };\n\n    s0 = peg$parsematrix();\n\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsetranslate();\n\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsescale();\n\n        if (s0 === peg$FAILED) {\n          s0 = peg$parserotate();\n\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseskewX();\n\n            if (s0 === peg$FAILED) {\n              s0 = peg$parseskewY();\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsematrix() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17;\n\n    var rule$expects = function rule$expects(expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    };\n\n    s0 = peg$currPos;\n    rule$expects(peg$e0);\n\n    if (input.substr(peg$currPos, 6) === peg$c0) {\n      s1 = peg$c0;\n      peg$currPos += 6;\n    } else {\n      s1 = peg$FAILED;\n    }\n\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n\n      rule$expects(peg$e1);\n\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s3 = peg$c1;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n      }\n\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$parsewsp();\n\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parsewsp();\n        }\n\n        s5 = peg$parsenumber();\n\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parsecommaWsp();\n\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parsenumber();\n\n            if (s7 !== peg$FAILED) {\n              s8 = peg$parsecommaWsp();\n\n              if (s8 !== peg$FAILED) {\n                s9 = peg$parsenumber();\n\n                if (s9 !== peg$FAILED) {\n                  s10 = peg$parsecommaWsp();\n\n                  if (s10 !== peg$FAILED) {\n                    s11 = peg$parsenumber();\n\n                    if (s11 !== peg$FAILED) {\n                      s12 = peg$parsecommaWsp();\n\n                      if (s12 !== peg$FAILED) {\n                        s13 = peg$parsenumber();\n\n                        if (s13 !== peg$FAILED) {\n                          s14 = peg$parsecommaWsp();\n\n                          if (s14 !== peg$FAILED) {\n                            s15 = peg$parsenumber();\n\n                            if (s15 !== peg$FAILED) {\n                              s16 = [];\n                              s17 = peg$parsewsp();\n\n                              while (s17 !== peg$FAILED) {\n                                s16.push(s17);\n                                s17 = peg$parsewsp();\n                              }\n\n                              rule$expects(peg$e2);\n\n                              if (input.charCodeAt(peg$currPos) === 41) {\n                                s17 = peg$c2;\n                                peg$currPos++;\n                              } else {\n                                s17 = peg$FAILED;\n                              }\n\n                              if (s17 !== peg$FAILED) {\n                                peg$savedPos = s0;\n                                s0 = peg$f2(s5, s7, s9, s11, s13, s15);\n                              } else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                              }\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsetranslate() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n    var rule$expects = function rule$expects(expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    };\n\n    s0 = peg$currPos;\n    rule$expects(peg$e3);\n\n    if (input.substr(peg$currPos, 9) === peg$c3) {\n      s1 = peg$c3;\n      peg$currPos += 9;\n    } else {\n      s1 = peg$FAILED;\n    }\n\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n\n      rule$expects(peg$e1);\n\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s3 = peg$c1;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n      }\n\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$parsewsp();\n\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parsewsp();\n        }\n\n        s5 = peg$parsenumber();\n\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parsecommaWspNumber();\n\n          if (s6 === peg$FAILED) {\n            s6 = null;\n          }\n\n          s7 = [];\n          s8 = peg$parsewsp();\n\n          while (s8 !== peg$FAILED) {\n            s7.push(s8);\n            s8 = peg$parsewsp();\n          }\n\n          rule$expects(peg$e2);\n\n          if (input.charCodeAt(peg$currPos) === 41) {\n            s8 = peg$c2;\n            peg$currPos++;\n          } else {\n            s8 = peg$FAILED;\n          }\n\n          if (s8 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f3(s5, s6);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsescale() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n    var rule$expects = function rule$expects(expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    };\n\n    s0 = peg$currPos;\n    rule$expects(peg$e4);\n\n    if (input.substr(peg$currPos, 5) === peg$c4) {\n      s1 = peg$c4;\n      peg$currPos += 5;\n    } else {\n      s1 = peg$FAILED;\n    }\n\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n\n      rule$expects(peg$e1);\n\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s3 = peg$c1;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n      }\n\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$parsewsp();\n\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parsewsp();\n        }\n\n        s5 = peg$parsenumber();\n\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parsecommaWspNumber();\n\n          if (s6 === peg$FAILED) {\n            s6 = null;\n          }\n\n          s7 = [];\n          s8 = peg$parsewsp();\n\n          while (s8 !== peg$FAILED) {\n            s7.push(s8);\n            s8 = peg$parsewsp();\n          }\n\n          rule$expects(peg$e2);\n\n          if (input.charCodeAt(peg$currPos) === 41) {\n            s8 = peg$c2;\n            peg$currPos++;\n          } else {\n            s8 = peg$FAILED;\n          }\n\n          if (s8 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f4(s5, s6);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parserotate() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n    var rule$expects = function rule$expects(expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    };\n\n    s0 = peg$currPos;\n    rule$expects(peg$e5);\n\n    if (input.substr(peg$currPos, 6) === peg$c5) {\n      s1 = peg$c5;\n      peg$currPos += 6;\n    } else {\n      s1 = peg$FAILED;\n    }\n\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n\n      rule$expects(peg$e1);\n\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s3 = peg$c1;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n      }\n\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$parsewsp();\n\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parsewsp();\n        }\n\n        s5 = peg$parsenumber();\n\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parsecommaWspTwoNumbers();\n\n          if (s6 === peg$FAILED) {\n            s6 = null;\n          }\n\n          s7 = [];\n          s8 = peg$parsewsp();\n\n          while (s8 !== peg$FAILED) {\n            s7.push(s8);\n            s8 = peg$parsewsp();\n          }\n\n          rule$expects(peg$e2);\n\n          if (input.charCodeAt(peg$currPos) === 41) {\n            s8 = peg$c2;\n            peg$currPos++;\n          } else {\n            s8 = peg$FAILED;\n          }\n\n          if (s8 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f5(s5, s6);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseskewX() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var rule$expects = function rule$expects(expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    };\n\n    s0 = peg$currPos;\n    rule$expects(peg$e6);\n\n    if (input.substr(peg$currPos, 5) === peg$c6) {\n      s1 = peg$c6;\n      peg$currPos += 5;\n    } else {\n      s1 = peg$FAILED;\n    }\n\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n\n      rule$expects(peg$e1);\n\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s3 = peg$c1;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n      }\n\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$parsewsp();\n\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parsewsp();\n        }\n\n        s5 = peg$parsenumber();\n\n        if (s5 !== peg$FAILED) {\n          s6 = [];\n          s7 = peg$parsewsp();\n\n          while (s7 !== peg$FAILED) {\n            s6.push(s7);\n            s7 = peg$parsewsp();\n          }\n\n          rule$expects(peg$e2);\n\n          if (input.charCodeAt(peg$currPos) === 41) {\n            s7 = peg$c2;\n            peg$currPos++;\n          } else {\n            s7 = peg$FAILED;\n          }\n\n          if (s7 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f6(s5);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseskewY() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var rule$expects = function rule$expects(expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    };\n\n    s0 = peg$currPos;\n    rule$expects(peg$e7);\n\n    if (input.substr(peg$currPos, 5) === peg$c7) {\n      s1 = peg$c7;\n      peg$currPos += 5;\n    } else {\n      s1 = peg$FAILED;\n    }\n\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n\n      rule$expects(peg$e1);\n\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s3 = peg$c1;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n      }\n\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$parsewsp();\n\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parsewsp();\n        }\n\n        s5 = peg$parsenumber();\n\n        if (s5 !== peg$FAILED) {\n          s6 = [];\n          s7 = peg$parsewsp();\n\n          while (s7 !== peg$FAILED) {\n            s6.push(s7);\n            s7 = peg$parsewsp();\n          }\n\n          rule$expects(peg$e2);\n\n          if (input.charCodeAt(peg$currPos) === 41) {\n            s7 = peg$c2;\n            peg$currPos++;\n          } else {\n            s7 = peg$FAILED;\n          }\n\n          if (s7 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f7(s5);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsenumber() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function rule$expects(expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    };\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parsesign();\n\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n\n    s3 = peg$parsefloatingPointConstant();\n\n    if (s3 !== peg$FAILED) {\n      s2 = [s2, s3];\n      s1 = s2;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f8(s1);\n    }\n\n    s0 = s1;\n\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsesign();\n\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n\n      s3 = peg$parseintegerConstant();\n\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f9(s1);\n      }\n\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecommaWspNumber() {\n    var s0, s1, s2;\n\n    var rule$expects = function rule$expects(expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    };\n\n    s0 = peg$currPos;\n    s1 = peg$parsecommaWsp();\n\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsenumber();\n\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f10(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecommaWspTwoNumbers() {\n    var s0, s1, s2, s3, s4;\n\n    var rule$expects = function rule$expects(expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    };\n\n    s0 = peg$currPos;\n    s1 = peg$parsecommaWsp();\n\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsenumber();\n\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecommaWsp();\n\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsenumber();\n\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f11(s2, s4);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecommaWsp() {\n    var s0, s1, s2, s3, s4;\n\n    var rule$expects = function rule$expects(expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    };\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsewsp();\n\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsewsp();\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma();\n\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n\n      s3 = [];\n      s4 = peg$parsewsp();\n\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = peg$parsewsp();\n      }\n\n      s1 = [s1, s2, s3];\n      s0 = s1;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsecomma();\n\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parsewsp();\n\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsewsp();\n        }\n\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsecomma() {\n    var s0;\n\n    var rule$expects = function rule$expects(expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    };\n\n    rule$expects(peg$e8);\n\n    if (input.charCodeAt(peg$currPos) === 44) {\n      s0 = peg$c8;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseintegerConstant() {\n    var s0, s1;\n\n    var rule$expects = function rule$expects(expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    };\n\n    s0 = peg$currPos;\n    s1 = peg$parsedigitSequence();\n\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f12(s1);\n    }\n\n    s0 = s1;\n    return s0;\n  }\n\n  function peg$parsefloatingPointConstant() {\n    var s0, s1, s2;\n\n    var rule$expects = function rule$expects(expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    };\n\n    s0 = peg$currPos;\n    s1 = peg$parsefractionalConstant();\n\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseexponent();\n\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n\n      s1 = [s1, s2];\n      s0 = s1;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsedigitSequence();\n\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseexponent();\n\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsefractionalConstant() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function rule$expects(expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    };\n\n    rule$expects(peg$e9);\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parsedigitSequence();\n\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s2 = peg$c9;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n    }\n\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parsedigitSequence();\n\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f13(s1, s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsedigitSequence();\n\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s2 = peg$c9;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n        }\n\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f14(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    peg$silentFails--;\n    return s0;\n  }\n\n  function peg$parseexponent() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function rule$expects(expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    };\n\n    s0 = peg$currPos;\n    rule$expects(peg$e10);\n\n    if (peg$r0.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n    }\n\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsesign();\n\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n\n      s3 = peg$parsedigitSequence();\n\n      if (s3 !== peg$FAILED) {\n        s1 = [s1, s2, s3];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesign() {\n    var s0;\n\n    var rule$expects = function rule$expects(expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    };\n\n    rule$expects(peg$e11);\n\n    if (peg$r1.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsedigitSequence() {\n    var s0, s1;\n\n    var rule$expects = function rule$expects(expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    };\n\n    s0 = [];\n    s1 = peg$parsedigit();\n\n    if (s1 !== peg$FAILED) {\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        s1 = peg$parsedigit();\n      }\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsedigit() {\n    var s0;\n\n    var rule$expects = function rule$expects(expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    };\n\n    rule$expects(peg$e12);\n\n    if (peg$r2.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsewsp() {\n    var s0;\n\n    var rule$expects = function rule$expects(expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    };\n\n    rule$expects(peg$e13);\n\n    if (peg$r3.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  peg$begin();\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$expect(peg$endExpectation());\n    }\n\n    throw peg$buildError();\n  }\n}\n\nexport { peg$SyntaxError as SyntaxError, peg$parse as parse };\nexport default {\n  SyntaxError: peg$SyntaxError,\n  parse: peg$parse\n};","map":null,"metadata":{},"sourceType":"module"}