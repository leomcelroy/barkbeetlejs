{"ast":null,"code":"(function () {\n  var AcronymResult, computeScore, emptyAcronymResult, isAcronymFullWord, isMatch, isSeparator, isWordEnd, isWordStart, miss_coeff, pos_bonus, scoreAcronyms, scoreCharacter, scoreConsecutives, scoreExact, scoreExactMatch, scorePattern, scorePosition, scoreSize, tau_size, wm;\n  wm = 150;\n  pos_bonus = 20;\n  tau_size = 150;\n  miss_coeff = 0.75;\n\n  exports.score = function (string, query, options) {\n    var allowErrors, preparedQuery, score, string_lw;\n    preparedQuery = options.preparedQuery, allowErrors = options.allowErrors;\n\n    if (!(allowErrors || isMatch(string, preparedQuery.core_lw, preparedQuery.core_up))) {\n      return 0;\n    }\n\n    string_lw = string.toLowerCase();\n    score = computeScore(string, string_lw, preparedQuery);\n    return Math.ceil(score);\n  };\n\n  exports.isMatch = isMatch = function isMatch(subject, query_lw, query_up) {\n    var i, j, m, n, qj_lw, qj_up, si;\n    m = subject.length;\n    n = query_lw.length;\n\n    if (!m || n > m) {\n      return false;\n    }\n\n    i = -1;\n    j = -1;\n\n    while (++j < n) {\n      qj_lw = query_lw.charCodeAt(j);\n      qj_up = query_up.charCodeAt(j);\n\n      while (++i < m) {\n        si = subject.charCodeAt(i);\n\n        if (si === qj_lw || si === qj_up) {\n          break;\n        }\n      }\n\n      if (i === m) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  exports.computeScore = computeScore = function computeScore(subject, subject_lw, preparedQuery) {\n    var acro, acro_score, align, csc_diag, csc_row, csc_score, csc_should_rebuild, i, j, m, miss_budget, miss_left, n, pos, query, query_lw, record_miss, score, score_diag, score_row, score_up, si_lw, start, sz;\n    query = preparedQuery.query;\n    query_lw = preparedQuery.query_lw;\n    m = subject.length;\n    n = query.length;\n    acro = scoreAcronyms(subject, subject_lw, query, query_lw);\n    acro_score = acro.score;\n\n    if (acro.count === n) {\n      return scoreExact(n, m, acro_score, acro.pos);\n    }\n\n    pos = subject_lw.indexOf(query_lw);\n\n    if (pos > -1) {\n      return scoreExactMatch(subject, subject_lw, query, query_lw, pos, n, m);\n    }\n\n    score_row = new Array(n);\n    csc_row = new Array(n);\n    sz = scoreSize(n, m);\n    miss_budget = Math.ceil(miss_coeff * n) + 5;\n    miss_left = miss_budget;\n    csc_should_rebuild = true;\n    j = -1;\n\n    while (++j < n) {\n      score_row[j] = 0;\n      csc_row[j] = 0;\n    }\n\n    i = -1;\n\n    while (++i < m) {\n      si_lw = subject_lw[i];\n\n      if (!si_lw.charCodeAt(0) in preparedQuery.charCodes) {\n        if (csc_should_rebuild) {\n          j = -1;\n\n          while (++j < n) {\n            csc_row[j] = 0;\n          }\n\n          csc_should_rebuild = false;\n        }\n\n        continue;\n      }\n\n      score = 0;\n      score_diag = 0;\n      csc_diag = 0;\n      record_miss = true;\n      csc_should_rebuild = true;\n      j = -1;\n\n      while (++j < n) {\n        score_up = score_row[j];\n\n        if (score_up > score) {\n          score = score_up;\n        }\n\n        csc_score = 0;\n\n        if (query_lw[j] === si_lw) {\n          start = isWordStart(i, subject, subject_lw);\n          csc_score = csc_diag > 0 ? csc_diag : scoreConsecutives(subject, subject_lw, query, query_lw, i, j, start);\n          align = score_diag + scoreCharacter(i, j, start, acro_score, csc_score);\n\n          if (align > score) {\n            score = align;\n            miss_left = miss_budget;\n          } else {\n            if (record_miss && --miss_left <= 0) {\n              return Math.max(score, score_row[n - 1]) * sz;\n            }\n\n            record_miss = false;\n          }\n        }\n\n        score_diag = score_up;\n        csc_diag = csc_row[j];\n        csc_row[j] = csc_score;\n        score_row[j] = score;\n      }\n    }\n\n    score = score_row[n - 1];\n    return score * sz;\n  };\n\n  exports.isWordStart = isWordStart = function isWordStart(pos, subject, subject_lw) {\n    var curr_s, prev_s;\n\n    if (pos === 0) {\n      return true;\n    }\n\n    curr_s = subject[pos];\n    prev_s = subject[pos - 1];\n    return isSeparator(prev_s) || curr_s !== subject_lw[pos] && prev_s === subject_lw[pos - 1];\n  };\n\n  exports.isWordEnd = isWordEnd = function isWordEnd(pos, subject, subject_lw, len) {\n    var curr_s, next_s;\n\n    if (pos === len - 1) {\n      return true;\n    }\n\n    curr_s = subject[pos];\n    next_s = subject[pos + 1];\n    return isSeparator(next_s) || curr_s === subject_lw[pos] && next_s !== subject_lw[pos + 1];\n  };\n\n  isSeparator = function isSeparator(c) {\n    return c === ' ' || c === '.' || c === '-' || c === '_' || c === '/' || c === '\\\\';\n  };\n\n  scorePosition = function scorePosition(pos) {\n    var sc;\n\n    if (pos < pos_bonus) {\n      sc = pos_bonus - pos;\n      return 100 + sc * sc;\n    } else {\n      return Math.max(100 + pos_bonus - pos, 0);\n    }\n  };\n\n  exports.scoreSize = scoreSize = function scoreSize(n, m) {\n    return tau_size / (tau_size + Math.abs(m - n));\n  };\n\n  scoreExact = function scoreExact(n, m, quality, pos) {\n    return 2 * n * (wm * quality + scorePosition(pos)) * scoreSize(n, m);\n  };\n\n  exports.scorePattern = scorePattern = function scorePattern(count, len, sameCase, start, end) {\n    var bonus, sz;\n    sz = count;\n    bonus = 6;\n\n    if (sameCase === count) {\n      bonus += 2;\n    }\n\n    if (start) {\n      bonus += 3;\n    }\n\n    if (end) {\n      bonus += 1;\n    }\n\n    if (count === len) {\n      if (start) {\n        if (sameCase === len) {\n          sz += 2;\n        } else {\n          sz += 1;\n        }\n      }\n\n      if (end) {\n        bonus += 1;\n      }\n    }\n\n    return sameCase + sz * (sz + bonus);\n  };\n\n  exports.scoreCharacter = scoreCharacter = function scoreCharacter(i, j, start, acro_score, csc_score) {\n    var posBonus;\n    posBonus = scorePosition(i);\n\n    if (start) {\n      return posBonus + wm * ((acro_score > csc_score ? acro_score : csc_score) + 10);\n    }\n\n    return posBonus + wm * csc_score;\n  };\n\n  exports.scoreConsecutives = scoreConsecutives = function scoreConsecutives(subject, subject_lw, query, query_lw, i, j, startOfWord) {\n    var k, m, mi, n, nj, sameCase, sz;\n    m = subject.length;\n    n = query.length;\n    mi = m - i;\n    nj = n - j;\n    k = mi < nj ? mi : nj;\n    sameCase = 0;\n    sz = 0;\n\n    if (query[j] === subject[i]) {\n      sameCase++;\n    }\n\n    while (++sz < k && query_lw[++j] === subject_lw[++i]) {\n      if (query[j] === subject[i]) {\n        sameCase++;\n      }\n    }\n\n    if (sz < k) {\n      i--;\n    }\n\n    if (sz === 1) {\n      return 1 + 2 * sameCase;\n    }\n\n    return scorePattern(sz, n, sameCase, startOfWord, isWordEnd(i, subject, subject_lw, m));\n  };\n\n  exports.scoreExactMatch = scoreExactMatch = function scoreExactMatch(subject, subject_lw, query, query_lw, pos, n, m) {\n    var end, i, pos2, sameCase, start;\n    start = isWordStart(pos, subject, subject_lw);\n\n    if (!start) {\n      pos2 = subject_lw.indexOf(query_lw, pos + 1);\n\n      if (pos2 > -1) {\n        start = isWordStart(pos2, subject, subject_lw);\n\n        if (start) {\n          pos = pos2;\n        }\n      }\n    }\n\n    i = -1;\n    sameCase = 0;\n\n    while (++i < n) {\n      if (query[pos + i] === subject[i]) {\n        sameCase++;\n      }\n    }\n\n    end = isWordEnd(pos + n - 1, subject, subject_lw, m);\n    return scoreExact(n, m, scorePattern(n, n, sameCase, start, end), pos);\n  };\n\n  AcronymResult = function () {\n    function AcronymResult(score, pos, count) {\n      this.score = score;\n      this.pos = pos;\n      this.count = count;\n    }\n\n    return AcronymResult;\n  }();\n\n  emptyAcronymResult = new AcronymResult(0, 0.1, 0);\n\n  exports.scoreAcronyms = scoreAcronyms = function scoreAcronyms(subject, subject_lw, query, query_lw) {\n    var count, fullWord, i, j, m, n, qj_lw, sameCase, score, sepCount, sumPos;\n    m = subject.length;\n    n = query.length;\n\n    if (!(m > 1 && n > 1)) {\n      return emptyAcronymResult;\n    }\n\n    count = 0;\n    sepCount = 0;\n    sumPos = 0;\n    sameCase = 0;\n    i = -1;\n    j = -1;\n\n    while (++j < n) {\n      qj_lw = query_lw[j];\n\n      if (isSeparator(qj_lw)) {\n        i = subject_lw.indexOf(qj_lw, i + 1);\n\n        if (i > -1) {\n          sepCount++;\n          continue;\n        } else {\n          break;\n        }\n      }\n\n      while (++i < m) {\n        if (qj_lw === subject_lw[i] && isWordStart(i, subject, subject_lw)) {\n          if (query[j] === subject[i]) {\n            sameCase++;\n          }\n\n          sumPos += i;\n          count++;\n          break;\n        }\n      }\n\n      if (i === m) {\n        break;\n      }\n    }\n\n    if (count < 2) {\n      return emptyAcronymResult;\n    }\n\n    fullWord = count === n ? isAcronymFullWord(subject, subject_lw, query, count) : false;\n    score = scorePattern(count, n, sameCase, true, fullWord);\n    return new AcronymResult(score, sumPos / count, count + sepCount);\n  };\n\n  isAcronymFullWord = function isAcronymFullWord(subject, subject_lw, query, nbAcronymInQuery) {\n    var count, i, m, n;\n    m = subject.length;\n    n = query.length;\n    count = 0;\n\n    if (m > 12 * n) {\n      return false;\n    }\n\n    i = -1;\n\n    while (++i < m) {\n      if (isWordStart(i, subject, subject_lw) && ++count > nbAcronymInQuery) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}