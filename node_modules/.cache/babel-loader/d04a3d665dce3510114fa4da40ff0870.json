{"ast":null,"code":"/*\n (c) 2017, Vladimir Agafonkin\n Simplify.js, a high-performance JS polyline simplification library\n mourner.github.io/simplify-js\n*/\n(function () {\n  'use strict'; // to suit your point format, run search/replace for '.x' and '.y';\n  // for 3D version, see 3d branch (configurability would draw significant performance overhead)\n  // square distance between 2 points\n\n  function getSqDist(p1, p2) {\n    var dx = p1.x - p2.x,\n        dy = p1.y - p2.y;\n    return dx * dx + dy * dy;\n  } // square distance from a point to a segment\n\n\n  function getSqSegDist(p, p1, p2) {\n    var x = p1.x,\n        y = p1.y,\n        dx = p2.x - x,\n        dy = p2.y - y;\n\n    if (dx !== 0 || dy !== 0) {\n      var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);\n\n      if (t > 1) {\n        x = p2.x;\n        y = p2.y;\n      } else if (t > 0) {\n        x += dx * t;\n        y += dy * t;\n      }\n    }\n\n    dx = p.x - x;\n    dy = p.y - y;\n    return dx * dx + dy * dy;\n  } // rest of the code doesn't care about point format\n  // basic distance-based simplification\n\n\n  function simplifyRadialDist(points, sqTolerance) {\n    var prevPoint = points[0],\n        newPoints = [prevPoint],\n        point;\n\n    for (var i = 1, len = points.length; i < len; i++) {\n      point = points[i];\n\n      if (getSqDist(point, prevPoint) > sqTolerance) {\n        newPoints.push(point);\n        prevPoint = point;\n      }\n    }\n\n    if (prevPoint !== point) newPoints.push(point);\n    return newPoints;\n  }\n\n  function simplifyDPStep(points, first, last, sqTolerance, simplified) {\n    var maxSqDist = sqTolerance,\n        index;\n\n    for (var i = first + 1; i < last; i++) {\n      var sqDist = getSqSegDist(points[i], points[first], points[last]);\n\n      if (sqDist > maxSqDist) {\n        index = i;\n        maxSqDist = sqDist;\n      }\n    }\n\n    if (maxSqDist > sqTolerance) {\n      if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);\n      simplified.push(points[index]);\n      if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);\n    }\n  } // simplification using Ramer-Douglas-Peucker algorithm\n\n\n  function simplifyDouglasPeucker(points, sqTolerance) {\n    var last = points.length - 1;\n    var simplified = [points[0]];\n    simplifyDPStep(points, 0, last, sqTolerance, simplified);\n    simplified.push(points[last]);\n    return simplified;\n  } // both algorithms combined for awesome performance\n\n\n  function simplify(points, tolerance, highestQuality) {\n    if (points.length <= 2) return points;\n    var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;\n    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);\n    points = simplifyDouglasPeucker(points, sqTolerance);\n    return points;\n  } // export as AMD module / Node module / browser or worker variable\n\n\n  if (typeof define === 'function' && define.amd) define(function () {\n    return simplify;\n  });else if (typeof module !== 'undefined') {\n    module.exports = simplify;\n    module.exports.default = simplify;\n  } else if (typeof self !== 'undefined') self.simplify = simplify;else window.simplify = simplify;\n})();","map":null,"metadata":{},"sourceType":"script"}