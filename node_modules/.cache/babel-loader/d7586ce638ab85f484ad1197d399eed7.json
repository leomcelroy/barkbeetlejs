{"ast":null,"code":"var _classCallCheck = require(\"/Users/leomcelroy/Desktop/barkbeetle_js/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/leomcelroy/Desktop/barkbeetle_js/node_modules/@babel/runtime/helpers/createClass\");\n\nvar SVGPoint = require('./SVGPoint');\n\nvar Point =\n/*#__PURE__*/\nfunction () {\n  \"use strict\";\n\n  // Initialize\n  function Point(x, y) {\n    _classCallCheck(this, Point);\n\n    var source;\n    var base = {\n      x: 0,\n      y: 0 // ensure source as object\n\n    };\n    source = Array.isArray(x) ? {\n      x: x[0],\n      y: x[1]\n    } : typeof x === 'object' ? {\n      x: x.x,\n      y: x.y\n    } : x != null ? {\n      x: x,\n      y: y != null ? y : x\n    } : base; // If y has no value, then x is used has its value\n    // merge source\n\n    this.x = source.x;\n    this.y = source.y;\n  } // Clone point\n\n\n  _createClass(Point, [{\n    key: \"clone\",\n    value: function clone() {\n      return new Point(this);\n    } // Convert to native SVGPoint\n\n  }, {\n    key: \"native\",\n    value: function native() {\n      // create new point\n      var point = new SVGPoint(); // update with current values\n\n      point.x = this.x;\n      point.y = this.y;\n      return point;\n    } // transform point with matrix\n\n  }, {\n    key: \"transform\",\n    value: function transform(matrix) {\n      return new Point(this.native().matrixTransform(matrix));\n    }\n  }, {\n    key: \"add\",\n    value: function add(x, y) {\n      var p = new Point(x, y);\n      return new Point(this.x + p.x, this.y + p.y);\n    }\n  }, {\n    key: \"sub\",\n    value: function sub(x, y) {\n      var p = new Point(x, y);\n      return new Point(this.x - p.x, this.y - p.y);\n    }\n  }, {\n    key: \"mul\",\n    value: function mul(factor) {\n      return new Point(this.x * factor, this.y * factor);\n    }\n  }, {\n    key: \"div\",\n    value: function div(factor) {\n      return new Point(this.x / factor, this.y / factor);\n    }\n  }, {\n    key: \"absQuad\",\n    value: function absQuad() {\n      return this.x * this.x + this.y * this.y;\n    }\n  }, {\n    key: \"abs\",\n    value: function abs() {\n      return Math.sqrt(this.absQuad());\n    }\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      var abs = this.abs();\n      if (!abs) throw new Error('Can\\'t normalize vector of zero length');\n      return this.div(abs);\n    }\n  }, {\n    key: \"normal\",\n    value: function normal() {\n      return new Point(this.y, -this.x);\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      return [this.x, this.y];\n    }\n  }, {\n    key: \"reflectAt\",\n    value: function reflectAt(p) {\n      return p.add(p.sub(this));\n    }\n  }, {\n    key: \"toPath\",\n    value: function toPath() {\n      return ['M', this.x, this.y].join(' ');\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(p) {\n      return this.x === p.x && this.y === p.y;\n    }\n  }, {\n    key: \"closeTo\",\n    value: function closeTo(p) {\n      var eta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.00001;\n      return this.equals(p) || Math.abs(this.x - p.x) < eta && Math.abs(this.y - p.y) < eta;\n    }\n  }, {\n    key: \"angleTo\",\n    value: function angleTo(p) {\n      var sign = Math.sign(this.x * p.y - this.y * p.x);\n      sign = sign || 1;\n      return sign * Math.acos(Math.round(this.dot(p) / (this.abs() * p.abs()) * 1000000) / 1000000);\n    }\n  }, {\n    key: \"dot\",\n    value: function dot(p) {\n      return this.x * p.x + this.y * p.y;\n    }\n  }]);\n\n  return Point;\n}();\n\nmodule.exports = Point;","map":null,"metadata":{},"sourceType":"script"}