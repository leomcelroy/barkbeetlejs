{"ast":null,"code":"import _toConsumableArray from \"/Users/leomcelroy/Desktop/barkBeetleEverything/barkbeetle_js_real/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n// makerjs model, depth, params -> pocket toolpath\nimport * as mjs from 'makerjs';\nvar STRANGE_CORRECTION = 0.0000001;\n\nvar isToolpath = function isToolpath(toolpath) {\n  if (Object.keys(toolpath.models).length === 0) {\n    return false;\n  } else {\n    return true;\n  }\n};\n\nvar intToolpath = function intToolpath(geo, radius) {\n  return mjs.model.outline(geo, radius + STRANGE_CORRECTION, 1, true);\n};\n\nvar intToolpaths = function intToolpaths(geo, radius) {\n  var first = intToolpath(geo, radius);\n\n  if (isToolpath(first) !== true) {\n    return {\n      models: {}\n    };\n  }\n\n  var models = {};\n  var count = 0;\n  models[count] = intToolpath(geo, radius);\n  count++;\n\n  while (isToolpath(intToolpath(models[count - 1], radius))) {\n    models[count] = intToolpath(models[count - 1], radius);\n    count++;\n  }\n\n  var model = {\n    models: models\n  };\n  return model;\n};\n\nvar pocket = function pocket(model, params) {\n  //let p = model.models.profile;\n  var p = model; // let outline = mjs.model.outline(p, params.compensatedRadius, 1, true); //third parameter is what type of corners, 0 (rounded) by default\n\n  var outline = intToolpath(p, params.compensatedRadius);\n  var outlines = intToolpaths(p, params.compensatedRadius);\n  var iterOut = Object.values(outlines.models); //let chains = mjs.model.findChains(expansion);\n\n  var chain = mjs.model.findSingleChain(outline);\n  var chain2 = iterOut.map(function (x) {\n    return mjs.model.findSingleChain(x);\n  }); //TODO: need to change this to find chains\n\n  var divisions = Math.floor(chain.pathLength / params.minimumSpacing);\n  var spacing = chain.pathLength / divisions;\n  var keyPoints = mjs.chain.toPoints(chain, spacing);\n  var keyPoints2 = chain2.map(function (x) {\n    return mjs.chain.toPoints(x, spacing);\n  }); //console.log(keyPoints2);\n  // let scaleFactor = 10;\n  // let scaleXY = keyPoints.map(p => [p[0] * scaleFactor, p[1] * scaleFactor]);\n\n  var gcodePoints = keyPoints.map(function (p) {\n    return \"G1 X\".concat(p[0], \" Y\").concat(p[1], \" F\").concat(params.feedRate);\n  });\n  var gcodePoints2 = keyPoints2.map(function (x) {\n    return x.map(function (p) {\n      return \"G1 X\".concat(p[0], \" Y\").concat(p[1], \" F\").concat(params.feedRate);\n    });\n  });\n  gcodePoints2 = gcodePoints2.flat(1); // let gcode = JSON.parse(JSON.stringify(gcodePoints));\n  // let gcode2 = JSON.parse(JSON.stringify(gcodePoints2));\n  //console.log(gcode2);\n\n  var firstPoint = keyPoints[0];\n  var firstPoints2 = keyPoints2.map(function (x) {\n    return x[0];\n  });\n  var paths = params.depthOfPasses.map(function (p, i) {\n    return [\"G1 Z\".concat(params.depthOfPasses[i], \" F12.0\")].concat(_toConsumableArray(gcodePoints), [\"G1 X\".concat(firstPoint[0], \" Y\").concat(firstPoint[1], \" F\").concat(params.feedRate)]);\n  });\n  paths = paths.flat(1); //let paths2 = params.depthOfPasses.map((p,i) => [`G1 Z${params.depthOfPasses[i]} F12.0`, ...gcodePoints2, `G1 X${firstPoints2[i][0]} Y${firstPoints2[i][1]} F${params.feedRate}`]\n  //paths2 = paths2.flat(1);\n  //console.log(paths2)\n\n  var gcode = [params.units, \"G90\", \"G1 Z\".concat(params.jogHeight, \" F9.0\"), \"G0 X\".concat(firstPoint[0], \" Y\").concat(firstPoint[1])].concat(_toConsumableArray(paths)); // let gcode2 = [\n  //   params.units,\n  //   \"G90\",\n  //   `G1 Z${params.jogHeight} F9.0`,\n  //   `G0 X${firstPoint[0]} Y${firstPoint[1]}`,\n  //   ...paths2\n  // ]\n  // write to a new file named\n\n  var filename = 'testGcodePocket.nc';\n  var text = gcode.join('\\n');\n  return {\n    drawing: outlines,\n    gcode: text,\n    filename: filename\n  };\n};\n\nexport { pocket };","map":{"version":3,"sources":["/Users/leomcelroy/Desktop/barkBeetleEverything/barkbeetle_js_real/src/toolpaths/pocket.js"],"names":["mjs","STRANGE_CORRECTION","isToolpath","toolpath","Object","keys","models","length","intToolpath","geo","radius","model","outline","intToolpaths","first","count","pocket","params","p","compensatedRadius","outlines","iterOut","values","chain","findSingleChain","chain2","map","x","divisions","Math","floor","pathLength","minimumSpacing","spacing","keyPoints","toPoints","keyPoints2","gcodePoints","feedRate","gcodePoints2","flat","firstPoint","firstPoints2","paths","depthOfPasses","i","gcode","units","jogHeight","filename","text","join","drawing"],"mappings":"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","sourcesContent":["// makerjs model, depth, params -> pocket toolpath\nimport * as mjs from 'makerjs';\n\nconst STRANGE_CORRECTION = 0.0000001;\n\nconst isToolpath = (toolpath) => {\n  if (Object.keys(toolpath.models).length === 0) {\n    return false;\n  } else {\n    return true;\n  }\n}\n\nconst intToolpath = (geo, radius) => {\n  return mjs.model.outline(geo, radius + STRANGE_CORRECTION, 1, true);\n}\n\nconst intToolpaths = (geo, radius) => {\n  let first = intToolpath(geo, radius);\n\n  if (isToolpath(first) !== true) {\n    return {models:{}};\n  }\n\n  let models = {}\n  let count = 0;\n\n  models[count] = intToolpath(geo, radius);\n\n  count++;\n\n  while ( isToolpath(intToolpath(models[count-1], radius)) ) {\n    models[count] = intToolpath(models[count-1], radius);\n    count++;\n  }\n\n  let model = {models}\n\n  return model;\n}\n\nconst pocket = (model, params) => {\n  //let p = model.models.profile;\n  let p = model;\n\n  // let outline = mjs.model.outline(p, params.compensatedRadius, 1, true); //third parameter is what type of corners, 0 (rounded) by default\n  let outline = intToolpath(p, params.compensatedRadius);\n  let outlines = intToolpaths(p, params.compensatedRadius);\n  let iterOut = Object.values(outlines.models);\n\n  //let chains = mjs.model.findChains(expansion);\n  let chain = mjs.model.findSingleChain(outline);\n  let chain2 = iterOut.map(x => mjs.model.findSingleChain(x)); //TODO: need to change this to find chains\n\n  var divisions = Math.floor(chain.pathLength / params.minimumSpacing);\n  var spacing = chain.pathLength / divisions;\n\n  let keyPoints = mjs.chain.toPoints(chain, spacing);\n  let keyPoints2 = chain2.map(x => mjs.chain.toPoints(x, spacing));\n  //console.log(keyPoints2);\n\n  // let scaleFactor = 10;\n  // let scaleXY = keyPoints.map(p => [p[0] * scaleFactor, p[1] * scaleFactor]);\n\n  let gcodePoints = keyPoints.map(p => `G1 X${p[0]} Y${p[1]} F${params.feedRate}`)\n  let gcodePoints2 = keyPoints2.map(x => x.map(p => `G1 X${p[0]} Y${p[1]} F${params.feedRate}`));\n  gcodePoints2 = gcodePoints2.flat(1);\n\n  // let gcode = JSON.parse(JSON.stringify(gcodePoints));\n  // let gcode2 = JSON.parse(JSON.stringify(gcodePoints2));\n\n  //console.log(gcode2);\n\n  let firstPoint = keyPoints[0];\n  let firstPoints2 = keyPoints2.map(x => x[0]);\n\n  let paths = params.depthOfPasses.map((p,i) => [`G1 Z${params.depthOfPasses[i]} F12.0`, ...gcodePoints, `G1 X${firstPoint[0]} Y${firstPoint[1]} F${params.feedRate}`])\n  paths = paths.flat(1);\n\n  //let paths2 = params.depthOfPasses.map((p,i) => [`G1 Z${params.depthOfPasses[i]} F12.0`, ...gcodePoints2, `G1 X${firstPoints2[i][0]} Y${firstPoints2[i][1]} F${params.feedRate}`]\n  //paths2 = paths2.flat(1);\n\n  //console.log(paths2)\n\n  let gcode = [\n    params.units,\n    \"G90\",\n    `G1 Z${params.jogHeight} F9.0`,\n    `G0 X${firstPoint[0]} Y${firstPoint[1]}`,\n    ...paths\n  ]\n\n  // let gcode2 = [\n  //   params.units,\n  //   \"G90\",\n  //   `G1 Z${params.jogHeight} F9.0`,\n  //   `G0 X${firstPoint[0]} Y${firstPoint[1]}`,\n  //   ...paths2\n  // ]\n\n  // write to a new file named\n  let filename = 'testGcodePocket.nc';\n\n  let text = gcode.join('\\n');\n\n  return {drawing: outlines, gcode: text, filename};\n};\n\n\nexport {pocket};\n"]},"metadata":{},"sourceType":"module"}