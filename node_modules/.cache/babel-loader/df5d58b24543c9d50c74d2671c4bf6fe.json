{"ast":null,"code":"import _slicedToArray from \"/Users/leomcelroy/Desktop/barkbeetle_js/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"/Users/leomcelroy/Desktop/barkbeetle_js/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { gcode } from './exampleGCode.js';\nimport { line } from './unmakerjs/primitives.js'; //gocode: string -> {points: list, preamble: list} :object\n\nvar getPoints = function getPoints(gcode) {\n  var gcodeList = gcode.split('\\n');\n  var preamble = [];\n  var points = [];\n  var sawPreamble = false;\n  gcodeList.forEach(function (e) {\n    if (sawPreamble) {\n      var xIndex = e.indexOf(\"X\");\n      var yIndex = e.indexOf(\"Y\");\n      var fIndex = e.indexOf(\"F\");\n\n      if (e.includes(\"X\")) {\n        //console.log(\"full\", e);\n        var x = e.substring(xIndex + 1, yIndex - 1); //console.log(\"x\", x)\n\n        x = parseFloat(x);\n        var y = fIndex === -1 ? e.substring(yIndex + 1, e.length) : e.substring(yIndex + 1, fIndex - 1); //console.log(\"y\", y, \"f\", fIndex)\n\n        y = parseFloat(y);\n        points.push([x, y]);\n      }\n    } else {\n      preamble.push(e);\n    }\n\n    if (e === \"(end of preamble)\") sawPreamble = true;\n  });\n  return {\n    points: points,\n    preamble: preamble\n  };\n}; // finds center of a list of contours\n\n\nvar center = function center(contours) {\n  var points = contours.flat(1);\n  points = points.map(function (line) {\n    return [line.origin, line.end];\n  }).flat();\n  var xS = points.map(function (point) {\n    return point[0];\n  });\n  var medianX = (Math.max.apply(Math, _toConsumableArray(xS)) + Math.min.apply(Math, _toConsumableArray(xS))) / 2; // let averageX = xS.reduce(sum, 0)/xS.length;\n\n  var yS = points.map(function (point) {\n    return point[1];\n  });\n  var medianY = (Math.max.apply(Math, _toConsumableArray(yS)) + Math.min.apply(Math, _toConsumableArray(yS))) / 2; // let averageY = yS.reduce(sum, 0)/yS.length;\n  // return [averageX, averageY];\n\n  return [medianX, medianY];\n}; // mirrors a list of contours\n\n\nvar mirror = function mirror(contours, line) {};\n\nvar scale = function scale(contours, xFactor, yFactor) {\n  contours = contours.map(function (contour) {\n    return contour.map(function (l) {\n      var _l$origin = _slicedToArray(l.origin, 2),\n          originX = _l$origin[0],\n          originY = _l$origin[1];\n\n      var _l$end = _slicedToArray(l.end, 2),\n          endX = _l$end[0],\n          endY = _l$end[1];\n\n      var newOrigin = [originX * xFactor, originY * yFactor];\n      var newEnd = [endX * xFactor, endY * yFactor];\n      return line(newOrigin, newEnd);\n    });\n  });\n  return contours;\n}; //offsets a list of contours\n\n\nvar offset = function offset(contours, xOffset, yOffset) {\n  contours = contours.map(function (contour) {\n    return contour.map(function (l) {\n      var _l$origin2 = _slicedToArray(l.origin, 2),\n          originX = _l$origin2[0],\n          originY = _l$origin2[1];\n\n      var _l$end2 = _slicedToArray(l.end, 2),\n          endX = _l$end2[0],\n          endY = _l$end2[1];\n\n      var newOrigin = [originX + xOffset, originY + yOffset];\n      var newEnd = [endX + xOffset, endY + yOffset];\n      return line(newOrigin, newEnd);\n    });\n  });\n  return contours;\n}; //contours: list of lists, x: boolean, y: boolean -> new contours: list of lists\n\n\nvar reflect = function reflect(contours, x, y) {\n  x = x ? -1 : 1;\n  y = y ? -1 : 1;\n  contours = contours.map(function (contour) {\n    return contour.map(function (l) {\n      var _l$origin3 = _slicedToArray(l.origin, 2),\n          originX = _l$origin3[0],\n          originY = _l$origin3[1];\n\n      var _l$end3 = _slicedToArray(l.end, 2),\n          endX = _l$end3[0],\n          endY = _l$end3[1];\n\n      var newOrigin = [originX * x, originY * y];\n      var newEnd = [endX * x, endY * y];\n      return line(newOrigin, newEnd);\n    });\n  });\n  return contours;\n};\n\nexport var transformations = {\n  offset: offset,\n  mirror: mirror,\n  reflect: reflect,\n  scale: scale\n};","map":{"version":3,"sources":["/Users/leomcelroy/Desktop/barkbeetle_js/src/gcodeManipulations.js"],"names":["gcode","line","getPoints","gcodeList","split","preamble","points","sawPreamble","forEach","e","xIndex","indexOf","yIndex","fIndex","includes","x","substring","parseFloat","y","length","push","center","contours","flat","map","origin","end","xS","point","medianX","Math","max","min","yS","medianY","mirror","scale","xFactor","yFactor","contour","l","originX","originY","endX","endY","newOrigin","newEnd","offset","xOffset","yOffset","reflect","transformations"],"mappings":"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","sourcesContent":["import {gcode} from './exampleGCode.js';\nimport {line} from './unmakerjs/primitives.js';\n\n//gocode: string -> {points: list, preamble: list} :object\nconst getPoints = (gcode) => {\n  let gcodeList = gcode.split('\\n');\n  let preamble = [];\n  let points = [];\n\n  let sawPreamble = false;\n  gcodeList.forEach(e => {\n    if (sawPreamble) {\n      let xIndex = e.indexOf(\"X\");\n      let yIndex = e.indexOf(\"Y\");\n      let fIndex = e.indexOf(\"F\");\n\n      if (e.includes(\"X\")) {\n        //console.log(\"full\", e);\n\n        let x = e.substring(xIndex + 1, yIndex - 1);\n        //console.log(\"x\", x)\n        x = parseFloat(x);\n\n        let y = (fIndex === -1) ? e.substring(yIndex + 1, e.length) : e.substring(yIndex + 1, fIndex - 1);\n        //console.log(\"y\", y, \"f\", fIndex)\n        y = parseFloat(y);\n\n        points.push([x, y]);\n      }\n\n    } else {\n      preamble.push(e);\n    }\n\n    if (e === \"(end of preamble)\") sawPreamble = true;\n  })\n\n  return {points, preamble};\n}\n\n// finds center of a list of contours\nconst center = (contours) => {\n  let points = contours.flat(1);\n  points = points.map(line => [line.origin, line.end]).flat();\n\n  let xS = points.map(point => point[0]);\n  let medianX = (Math.max(...xS) + Math.min(...xS))/2\n  // let averageX = xS.reduce(sum, 0)/xS.length;\n\n  let yS = points.map(point => point[1]);\n  let medianY = (Math.max(...yS) + Math.min(...yS))/2\n  // let averageY = yS.reduce(sum, 0)/yS.length;\n\n  // return [averageX, averageY];\n  return [medianX, medianY];\n}\n\n// mirrors a list of contours\nconst mirror = (contours, line) => {};\n\nconst scale = (contours, xFactor, yFactor) => {\n  contours = contours.map(contour => {\n    return contour.map(l => {\n      let [originX, originY] = l.origin;\n      let [endX, endY] = l.end;\n\n      let newOrigin = [originX * xFactor, originY * yFactor];\n      let newEnd = [endX * xFactor, endY *yFactor];\n\n      return line(newOrigin, newEnd);\n    })\n  })\n\n  return contours\n};\n\n//offsets a list of contours\nconst offset = (contours, xOffset, yOffset) => {\n  contours = contours.map(contour => {\n    return contour.map(l => {\n      let [originX, originY] = l.origin;\n      let [endX, endY] = l.end;\n\n      let newOrigin = [originX + xOffset, originY + yOffset];\n      let newEnd = [endX + xOffset, endY + yOffset];\n\n      return line(newOrigin, newEnd);\n    })\n  })\n\n  return contours\n}\n\n//contours: list of lists, x: boolean, y: boolean -> new contours: list of lists\nconst reflect = (contours, x, y) => {\n  x = (x) ? -1 : 1;\n  y = (y) ? -1 : 1;\n\n  contours = contours.map(contour => {\n    return contour.map(l => {\n      let [originX, originY] = l.origin;\n      let [endX, endY] = l.end;\n\n      let newOrigin = [originX * x, originY * y];\n      let newEnd = [endX * x, endY * y];\n\n      return line(newOrigin, newEnd);\n    })\n  })\n\n  return contours\n}\n\nexport const transformations = {\n  offset,\n  mirror,\n  reflect,\n  scale\n}\n"]},"metadata":{},"sourceType":"module"}