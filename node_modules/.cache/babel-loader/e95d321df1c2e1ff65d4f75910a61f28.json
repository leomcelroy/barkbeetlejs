{"ast":null,"code":"import { Position } from '../../constants';\n/**\n * Function to create a Rect.\n * @param {Object} dimensions\n * @param {Number} dimensions.width\n * @param {Number} dimensions.height\n * @param {Object} position\n * @param {Number} position.left\n * @param {Number} position.top\n * @return {Object} Rect { width, height, left, top, right, bottom }\n */\n\nvar makeRect = function makeRect(_ref, _ref2) {\n  var width = _ref.width,\n      height = _ref.height;\n  var left = _ref2.left,\n      top = _ref2.top;\n  var ceiledLeft = Math.ceil(left);\n  var ceiledTop = Math.ceil(top);\n  return {\n    width: width,\n    height: height,\n    left: ceiledLeft,\n    top: ceiledTop,\n    right: ceiledLeft + width,\n    bottom: ceiledTop + height\n  };\n};\n/**\n * Function to flip a position upside down.\n * @param {Position} position\n * @return {Position} flipped position\n */\n\n\nvar flipHorizontal = function flipHorizontal(position) {\n  switch (position) {\n    case Position.TOP_LEFT:\n      return Position.BOTTOM_LEFT;\n\n    case Position.TOP:\n    default:\n      return Position.BOTTOM;\n\n    case Position.TOP_RIGHT:\n      return Position.BOTTOM_RIGHT;\n\n    case Position.BOTTOM_LEFT:\n      return Position.TOP_LEFT;\n\n    case Position.BOTTOM:\n      return Position.TOP;\n\n    case Position.BOTTOM_RIGHT:\n      return Position.TOP_RIGHT;\n  }\n};\n/**\n * Function that returns if position is aligned on top.\n * @param {Position} position\n * @return {Boolean}\n */\n\n\nvar isAlignedOnTop = function isAlignedOnTop(position) {\n  switch (position) {\n    case Position.TOP_LEFT:\n    case Position.TOP:\n    case Position.TOP_RIGHT:\n      return true;\n\n    default:\n      return false;\n  }\n};\n/**\n * Function that returns if position is aligned left or right.\n * @param {Position} position\n * @return {Boolean}\n */\n\n\nvar isAlignedHorizontal = function isAlignedHorizontal(position) {\n  switch (position) {\n    case Position.LEFT:\n    case Position.RIGHT:\n      return true;\n\n    default:\n      return false;\n  }\n};\n/**\n * Function that returns if a rect fits on bottom.\n * @param {Rect} rect\n * @param {Object} viewport\n * @param {Number} viewportOffset\n * @return {Boolean}\n */\n\n\nvar getFitsOnBottom = function getFitsOnBottom(rect, viewport, viewportOffset) {\n  return rect.bottom < viewport.height - viewportOffset;\n};\n/**\n * Function that returns if a rect fits on top.\n * @param {Rect} rect\n * @param {Number} viewportOffset\n * @return {Boolean}\n */\n\n\nvar getFitsOnTop = function getFitsOnTop(rect, viewportOffset) {\n  return rect.top > viewportOffset;\n};\n/**\n * Function that returns if a rect fits on right.\n * @param {Rect} rect\n * @param {Object} viewport\n * @param {Number} viewportOffset\n * @return {Boolean}\n */\n\n\nvar getFitsOnRight = function getFitsOnRight(rect, viewport, viewportOffset) {\n  return rect.right < viewport.width - viewportOffset;\n};\n/**\n * Function that returns if a rect fits on left.\n * @param {Rect} rect\n * @param {Number} viewportOffset\n * @return {Boolean}\n */\n\n\nvar getFitsOnLeft = function getFitsOnLeft(rect, viewportOffset) {\n  return rect.left > viewportOffset;\n};\n/**\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-origin\n * Function that returns the CSS `tranform-origin` property.\n * @param {Rect} rect\n * @param {Position} position\n * @param {Object} dimensions — the dimensions of the positioner.\n * @param {Number} targetCenter - center of the target.\n * @return {String} transform origin\n */\n\n\nvar getTransformOrigin = function getTransformOrigin(_ref3) {\n  var rect = _ref3.rect,\n      position = _ref3.position,\n      dimensions = _ref3.dimensions,\n      targetCenter = _ref3.targetCenter;\n  var centerY = Math.round(targetCenter - rect.top);\n\n  if (position === Position.LEFT) {\n    /* Syntax: x-offset | y-offset */\n    return \"\".concat(dimensions.width, \"px \").concat(centerY, \"px\");\n  }\n\n  if (position === Position.RIGHT) {\n    /* Syntax: x-offset | y-offset */\n    return \"0px \".concat(centerY, \"px\");\n  }\n\n  var centerX = Math.round(targetCenter - rect.left);\n\n  if (isAlignedOnTop(position)) {\n    /* Syntax: x-offset | y-offset */\n    return \"\".concat(centerX, \"px \").concat(dimensions.height, \"px \");\n  }\n  /* Syntax: x-offset | y-offset */\n\n\n  return \"\".concat(centerX, \"px 0px \");\n};\n/**\n * Function that takes in numbers and position and gives the final coords.\n * @param {Position} position — the position the positioner should be on.\n * @param {Object} dimensions — the dimensions of the positioner.\n * @param {Object} targetRect — the rect of the target.\n * @param {Number} targetOffset - offset from the target.\n * @param {Object} viewport - the width and height of the viewport.\n * @param {Object} viewportOffset - offset from the viewport.\n * @return {Object} - { x: Number, y: Number }\n */\n\n\nexport default function getFittedPosition(_ref4) {\n  var position = _ref4.position,\n      dimensions = _ref4.dimensions,\n      targetRect = _ref4.targetRect,\n      targetOffset = _ref4.targetOffset,\n      viewport = _ref4.viewport,\n      _ref4$viewportOffset = _ref4.viewportOffset,\n      viewportOffset = _ref4$viewportOffset === void 0 ? 8 : _ref4$viewportOffset;\n\n  var _getPosition = getPosition({\n    position: position,\n    dimensions: dimensions,\n    targetRect: targetRect,\n    targetOffset: targetOffset,\n    viewport: viewport,\n    viewportOffset: viewportOffset\n  }),\n      rect = _getPosition.rect,\n      finalPosition = _getPosition.position; // Push rect to the right if overflowing on the left side of the viewport.\n\n\n  if (rect.left < viewportOffset) {\n    rect.right += Math.ceil(Math.abs(rect.left - viewportOffset));\n    rect.left = Math.ceil(viewportOffset);\n  } // Push rect to the left if overflowing on the right side of the viewport.\n\n\n  if (rect.right > viewport.width - viewportOffset) {\n    var delta = Math.ceil(rect.right - (viewport.width - viewportOffset));\n    rect.left -= delta;\n    rect.right -= delta;\n  } // Push rect down if overflowing on the top side of the viewport.\n\n\n  if (rect.top < viewportOffset) {\n    rect.top += Math.ceil(Math.abs(rect.top - viewportOffset));\n    rect.bottom = Math.ceil(viewportOffset);\n  } // Push rect up if overflowing on the bottom side of the viewport.\n\n\n  if (rect.bottom > viewport.height - viewportOffset) {\n    var _delta = Math.ceil(rect.bottom - (viewport.height - viewportOffset));\n\n    rect.top -= _delta;\n    rect.right -= _delta;\n  }\n\n  var targetCenter = isAlignedHorizontal(position) ? targetRect.top + targetRect.height / 2 : targetRect.left + targetRect.width / 2;\n  var transformOrigin = getTransformOrigin({\n    rect: rect,\n    position: finalPosition,\n    dimensions: dimensions,\n    targetCenter: targetCenter\n  });\n  return {\n    rect: rect,\n    position: finalPosition,\n    transformOrigin: transformOrigin\n  };\n}\n/**\n * Function that takes in numbers and position and gives the final coords.\n * @param {Position} position — the position the positioner should be on.\n * @param {Object} dimensions — the dimensions of the positioner.\n * @param {Object} targetRect — the rect of the target.\n * @param {Number} targetOffset - offset from the target.\n * @param {Object} viewport - the width and height of the viewport.\n * @param {Object} viewportOffset - offset from the viewport.\n * @return {Object} - { rect: Rect, position: Position }\n */\n\nfunction getPosition(_ref5) {\n  var position = _ref5.position,\n      dimensions = _ref5.dimensions,\n      targetRect = _ref5.targetRect,\n      targetOffset = _ref5.targetOffset,\n      viewport = _ref5.viewport,\n      _ref5$viewportOffset = _ref5.viewportOffset,\n      viewportOffset = _ref5$viewportOffset === void 0 ? 8 : _ref5$viewportOffset;\n  var isHorizontal = isAlignedHorizontal(position); // Handle left and right positions\n\n  if (isHorizontal) {\n    var leftRect = getRect({\n      position: Position.LEFT,\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset\n    });\n    var rightRect = getRect({\n      position: Position.RIGHT,\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset\n    });\n    var fitsOnLeft = getFitsOnLeft(leftRect, viewportOffset);\n    var fitsOnRight = getFitsOnRight(rightRect, viewport, viewportOffset);\n\n    if (position === Position.LEFT) {\n      if (fitsOnLeft) {\n        return {\n          position: position,\n          rect: leftRect\n        };\n      }\n\n      if (fitsOnRight) {\n        return {\n          position: Position.RIGHT,\n          rect: rightRect\n        };\n      }\n    }\n\n    if (position === Position.RIGHT) {\n      if (fitsOnRight) {\n        return {\n          position: position,\n          rect: rightRect\n        };\n      }\n\n      if (fitsOnLeft) {\n        return {\n          position: Position.LEFT,\n          rect: leftRect\n        };\n      }\n    } // Default to using the position with the most space\n\n\n    var spaceRight = Math.abs(viewport.width - viewportOffset - rightRect.right);\n    var spaceLeft = Math.abs(leftRect.left - viewportOffset);\n\n    if (spaceRight < spaceLeft) {\n      return {\n        position: Position.RIGHT,\n        rect: rightRect\n      };\n    }\n\n    return {\n      position: Position.LEFT,\n      rect: leftRect\n    };\n  }\n\n  var positionIsAlignedOnTop = isAlignedOnTop(position);\n  var topRect;\n  var bottomRect;\n\n  if (positionIsAlignedOnTop) {\n    topRect = getRect({\n      position: position,\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset\n    });\n    bottomRect = getRect({\n      position: flipHorizontal(position),\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset\n    });\n  } else {\n    topRect = getRect({\n      position: flipHorizontal(position),\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset\n    });\n    bottomRect = getRect({\n      position: position,\n      dimensions: dimensions,\n      targetRect: targetRect,\n      targetOffset: targetOffset\n    });\n  }\n\n  var topRectFitsOnTop = getFitsOnTop(topRect, viewportOffset);\n  var bottomRectFitsOnBottom = getFitsOnBottom(bottomRect, viewport, viewportOffset);\n\n  if (positionIsAlignedOnTop) {\n    if (topRectFitsOnTop) {\n      return {\n        position: position,\n        rect: topRect\n      };\n    }\n\n    if (bottomRectFitsOnBottom) {\n      return {\n        position: flipHorizontal(position),\n        rect: bottomRect\n      };\n    }\n  }\n\n  if (!positionIsAlignedOnTop) {\n    if (bottomRectFitsOnBottom) {\n      return {\n        position: position,\n        rect: bottomRect\n      };\n    }\n\n    if (topRectFitsOnTop) {\n      return {\n        position: flipHorizontal(position),\n        rect: topRect\n      };\n    }\n  } // Default to most spacious if there is no fit.\n\n\n  var spaceBottom = Math.abs(viewport.height - viewportOffset - bottomRect.bottom);\n  var spaceTop = Math.abs(topRect.top - viewportOffset);\n\n  if (spaceBottom < spaceTop) {\n    return {\n      position: positionIsAlignedOnTop ? flipHorizontal(position) : position,\n      rect: bottomRect\n    };\n  }\n\n  return {\n    position: positionIsAlignedOnTop ? position : flipHorizontal(position),\n    rect: topRect\n  };\n}\n/**\n * Function that takes in numbers and position and gives the final coords.\n * @param {Object} position - the width and height of the viewport.\n * @param {Number} targetOffset - offset from the target.\n * @param {Object} dimensions — the dimensions of the positioner.\n * @param {Object} targetRect — the rect of the target.\n * @return {Object} - { x: Number, y: Number }\n */\n\n\nfunction getRect(_ref6) {\n  var position = _ref6.position,\n      targetOffset = _ref6.targetOffset,\n      dimensions = _ref6.dimensions,\n      targetRect = _ref6.targetRect;\n  var leftRect = targetRect.left + targetRect.width / 2 - dimensions.width / 2;\n  var alignedTopY = targetRect.top - dimensions.height - targetOffset;\n  var alignedBottomY = targetRect.bottom + targetOffset;\n  var alignedRightX = targetRect.right - dimensions.width;\n  var alignedLeftRightY = targetRect.top + targetRect.height / 2 - dimensions.height / 2;\n\n  switch (position) {\n    case Position.LEFT:\n      return makeRect(dimensions, {\n        left: targetRect.left - dimensions.width - targetOffset,\n        top: alignedLeftRightY\n      });\n\n    case Position.RIGHT:\n      return makeRect(dimensions, {\n        left: targetRect.right + targetOffset,\n        top: alignedLeftRightY\n      });\n\n    case Position.TOP:\n      return makeRect(dimensions, {\n        left: leftRect,\n        top: alignedTopY\n      });\n\n    case Position.TOP_LEFT:\n      return makeRect(dimensions, {\n        left: targetRect.left,\n        top: alignedTopY\n      });\n\n    case Position.TOP_RIGHT:\n      return makeRect(dimensions, {\n        left: alignedRightX,\n        top: alignedTopY\n      });\n\n    default:\n    case Position.BOTTOM:\n      return makeRect(dimensions, {\n        left: leftRect,\n        top: alignedBottomY\n      });\n\n    case Position.BOTTOM_LEFT:\n      return makeRect(dimensions, {\n        left: targetRect.left,\n        top: alignedBottomY\n      });\n\n    case Position.BOTTOM_RIGHT:\n      return makeRect(dimensions, {\n        left: alignedRightX,\n        top: alignedBottomY\n      });\n  }\n}","map":null,"metadata":{},"sourceType":"module"}