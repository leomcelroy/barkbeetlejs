{"ast":null,"code":"'use strict';\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    'default': obj\n  };\n}\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = require('react-dom');\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _reactAddonsCssTransitionGroup = require('react-addons-css-transition-group');\n\nvar _reactAddonsCssTransitionGroup2 = _interopRequireDefault(_reactAddonsCssTransitionGroup);\n\nvar _blacklist = require('blacklist');\n\nvar _blacklist2 = _interopRequireDefault(_blacklist);\n\nvar _classnames = require('classnames');\n\nvar _classnames2 = _interopRequireDefault(_classnames);\n\nvar _constants = require('../constants');\n\nvar TransitionPortal = _react2['default'].createClass({\n  displayName: 'TransitionPortal',\n  componentDidMount: function componentDidMount() {\n    if (!_constants.canUseDOM) return;\n    var p = document.createElement('div');\n    document.body.appendChild(p);\n    this.portalElement = p;\n    this.componentDidUpdate();\n  },\n  componentDidUpdate: function componentDidUpdate() {\n    if (!_constants.canUseDOM) return;\n\n    _reactDom2['default'].render(_react2['default'].createElement(_reactAddonsCssTransitionGroup2['default'], this.props, this.props.children), this.portalElement);\n  },\n  componentWillUnmount: function componentWillUnmount() {\n    if (!_constants.canUseDOM) return;\n    document.body.removeChild(this.portalElement);\n  },\n  portalElement: null,\n  render: function render() {\n    return null;\n  }\n});\n\nmodule.exports = _react2['default'].createClass({\n  displayName: 'Modal',\n  propTypes: {\n    autoFocusFirstElement: _react2['default'].PropTypes.bool,\n    backdropClosesModal: _react2['default'].PropTypes.bool,\n    className: _react2['default'].PropTypes.string,\n    isOpen: _react2['default'].PropTypes.bool,\n    onCancel: _react2['default'].PropTypes.func,\n    width: _react2['default'].PropTypes.oneOfType([_react2['default'].PropTypes.oneOf(['small', 'medium', 'large']), _react2['default'].PropTypes.number])\n  },\n  getDefaultProps: function getDefaultProps() {\n    return {\n      width: 'medium'\n    };\n  },\n  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {\n    if (!_constants.canUseDOM) return;\n\n    if (!this.props.isOpen && nextProps.isOpen) {\n      // setTimeout(() => this.handleAccessibility());\n      document.body.style.overflow = 'hidden';\n    } else if (this.props.isOpen && !nextProps.isOpen) {\n      // setTimeout(() => this.removeAccessibilityHandlers());\n      document.body.style.overflow = null;\n    }\n  },\n\n  /*\n  handleAccessibility () {\n  \t// Remember the element that was focused before we opened the modal\n  \t// so we can return focus to it once we close the modal.\n  \tthis.focusedElementBeforeModalOpened = document.activeElement;\n  \t\t// We're using a transition to reveal the modal,\n  \t// so wait until the element is visible, before\n  \t// finding the first keyboard focusable element\n  \t// and passing focus to it, otherwise the browser\n  \t// might scroll the document to reveal the element\n  \t// receiving focus\n  \tif (this.props.autoFocusFirstElement) {\n  \t\tally.when.visibleArea({\n  \t\t\tcontext: this.modalElement,\n  \t\t\tcallback: function(context) {\n  \t\t\t\t// the modal is visible on screen, so find the first\n  \t\t\t\t// keyboard focusable element (giving any element with\n  \t\t\t\t// autoFocus attribute precendence). If the modal does\n  \t\t\t\t// not contain any keyboard focusabe elements, focus will\n  \t\t\t\t// be given to the modal itself.\n  \t\t\t\tvar element = ally.query.firstTabbable({\n  \t\t\t\t\tcontext: context,\n  \t\t\t\t\tdefaultToContext: true,\n  \t\t\t\t});\n  \t\t\t\telement.focus();\n  \t\t\t},\n  \t\t});\n  \t}\n  \t\t// Make sure that no element outside of the modal\n  \t// can be interacted with while the modal is visible.\n  \tthis.disabledHandle = ally.maintain.disabled({\n  \t\tfilter: this.modalElement,\n  \t});\n  \t\t// Make sure that no element outside of the modal\n  \t// is exposed via the Accessibility Tree, to prevent\n  \t// screen readers from navigating to content it shouldn't\n  \t// be seeing while the modal is open.\n  \tthis.hiddenHandle = ally.maintain.hidden({\n  \t\tfilter: this.modalElement,\n  \t});\n  \t\t// React to escape keys as mandated by ARIA Practices\n  \tthis.keyHandle = ally.when.key({\n  \t\tescape: this.handleClose,\n  \t});\n  },\n  removeAccessibilityHandlers () {\n  \t// undo listening to keyboard\n  \tthis.keyHandle && this.keyHandle.disengage();\n  \t\t// undo hiding elements outside of the modal\n  \tthis.hiddenHandle && this.hiddenHandle.disengage();\n  \t\t// undo disabling elements outside of the modal\n  \tthis.disabledHandle && this.disabledHandle.disengage();\n  \t\t// return focus to where it was before we opened the modal\n  \tthis.focusedElementBeforeModalOpened && this.focusedElementBeforeModalOpened.focus();\n  },\n  handleModalClick (event) {\n  \tif (event.target.dataset.modal) this.handleClose();\n  },\n  */\n  handleClose: function handleClose() {\n    this.props.onCancel();\n  },\n  renderDialog: function renderDialog() {\n    var _this = this;\n\n    if (!this.props.isOpen) return;\n    var dialogClassname = (0, _classnames2['default'])('Modal-dialog', this.props.width && isNaN(this.props.width) ? 'Modal-dialog--' + this.props.width : null);\n    return _react2['default'].createElement('div', {\n      className: dialogClassname,\n      style: this.props.width && !isNaN(this.props.width) ? {\n        width: this.props.width + 20\n      } : null\n    }, _react2['default'].createElement('div', {\n      ref: function ref(_ref) {\n        _this.modalElement = _ref;\n      },\n      className: 'Modal-content'\n    }, this.props.children));\n  },\n  renderBackdrop: function renderBackdrop() {\n    if (!this.props.isOpen) return;\n    return _react2['default'].createElement('div', {\n      className: 'Modal-backdrop',\n      onClick: this.props.backdropClosesModal ? this.handleClose : null\n    });\n  },\n  render: function render() {\n    var className = (0, _classnames2['default'])('Modal', {\n      'is-open': this.props.isOpen\n    }, this.props.className);\n    var props = (0, _blacklist2['default'])(this.props, 'backdropClosesModal', 'className', 'isOpen', 'onCancel');\n    return _react2['default'].createElement('div', null, _react2['default'].createElement(TransitionPortal, _extends({}, props, {\n      'data-modal': 'true',\n      className: className,\n\n      /*onClick={this.handleModalClick}*/\n      transitionName: 'Modal-dialog',\n      transitionEnterTimeout: 260,\n      transitionLeaveTimeout: 140,\n      component: 'div'\n    }), this.renderDialog()), _react2['default'].createElement(TransitionPortal, {\n      transitionName: 'Modal-background',\n      transitionEnterTimeout: 140,\n      transitionLeaveTimeout: 240,\n      component: 'div'\n    }, this.renderBackdrop()));\n  }\n}); // expose the children to the top level export\n\nmodule.exports.Body = require('./ModalBody');\nmodule.exports.Footer = require('./ModalFooter');\nmodule.exports.Header = require('./ModalHeader');","map":null,"metadata":{},"sourceType":"script"}