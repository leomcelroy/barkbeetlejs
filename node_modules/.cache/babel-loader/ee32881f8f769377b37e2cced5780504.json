{"ast":null,"code":"'use strict'; // NOTE: we only support baseline and progressive JPGs here\n// due to the structure of the loader class, we only get a buffer\n// with a maximum size of 4096 bytes. so if the SOF marker is outside\n// if this range we can't detect the file size correctly.\n\nfunction isJPG(buffer) {\n  //, filepath\n  var SOIMarker = buffer.toString('hex', 0, 2);\n  return 'ffd8' === SOIMarker;\n}\n\nfunction extractSize(buffer, i) {\n  return {\n    'height': buffer.readUInt16BE(i),\n    'width': buffer.readUInt16BE(i + 2)\n  };\n}\n\nfunction validateBuffer(buffer, i) {\n  // index should be within buffer limits\n  if (i > buffer.length) {\n    throw new TypeError('Corrupt JPG, exceeded buffer limits');\n  } // Every JPEG block must begin with a 0xFF\n\n\n  if (buffer[i] !== 0xFF) {\n    throw new TypeError('Invalid JPG, marker table corrupted');\n  }\n}\n\nfunction calculate(buffer) {\n  // Skip 4 chars, they are for signature\n  buffer = buffer.slice(4);\n  var i, next;\n\n  while (buffer.length) {\n    // read length of the next block\n    i = buffer.readUInt16BE(0); // ensure correct format\n\n    validateBuffer(buffer, i); // 0xFFC0 is baseline standard(SOF)\n    // 0xFFC1 is baseline optimized(SOF)\n    // 0xFFC2 is progressive(SOF2)\n\n    next = buffer[i + 1];\n\n    if (next === 0xC0 || next === 0xC1 || next === 0xC2) {\n      return extractSize(buffer, i + 5);\n    } // move to the next block\n\n\n    buffer = buffer.slice(i + 2);\n  }\n\n  throw new TypeError('Invalid JPG, no size found');\n}\n\nmodule.exports = {\n  'detect': isJPG,\n  'calculate': calculate\n};","map":null,"metadata":{},"sourceType":"script"}