{"ast":null,"code":"//This code is adapted from https://github.com/makercam/makercam/blob/master/src/clipperOffset.ts\nimport ClipperLib from 'js-clipper';\nimport { connectPoints } from './primitives.js';\nimport * as utils from '../utils.js';\nvar EndTypes = {\n  etOpenSquare: 0,\n  etOpenRound: 1,\n  etOpenButt: 2,\n  etClosedPolygon: 3,\n  etClosedLine: 4\n};\nvar JoinTypes = [ClipperLib.JoinType.jtSquare, ClipperLib.JoinType.jtRound, ClipperLib.JoinType.jtMiter]; // single contour -> list of offset contours\n\nexport var clipOffsetContour = function clipOffsetContour(contour, offset) {\n  var joints = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var tolerance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.01;\n  var scale = 1000;\n  console.log(\"clipper contour\", contour);\n  var start = contour[0].origin;\n  var end = contour[contour.length - 1].end;\n  var endless = end.every(function (entry, i) {\n    return entry === start[i];\n  }); // console.log(\"contour\", contour);\n\n  var keyPoints = contour.map(function (line) {\n    return {\n      X: Math.round(line.origin[0] * scale),\n      Y: Math.round(line.origin[1] * scale)\n    };\n  });\n\n  if (endless) {\n    keyPoints.push(keyPoints[0]);\n  } else {\n    end = {\n      X: Math.round(end[0] * scale),\n      Y: Math.round(end[1] * scale)\n    };\n    keyPoints.push(end);\n  }\n\n  var paths = [keyPoints];\n  console.log(\"paths\", paths);\n  var co = new ClipperLib.ClipperOffset();\n  var offsetted = new ClipperLib.Paths();\n  co.Clear();\n  co.AddPaths(paths, JoinTypes[joints], endless ? EndTypes.etClosedLine : EndTypes.etOpenButt); //chain.endless ? EndTypes.etClosedLine : EndTypes.etOpenButt\n\n  co.MiterLimit = 2;\n  co.ArcTolerance = 0.25;\n  co.Execute(offsetted, offset * scale); // console.log(\"offsetted\", offsetted)\n  // console.log(\"endless\",endless)\n\n  var newContours = []; //what should I return a list or a js object\n  // console.log(\"offsetted\", offsetted)\n\n  offsetted.forEach(function (points) {\n    // console.log(\"points\", points)\n    if (points.length === 0) return;\n    var result = [];\n    points.forEach(function (point) {\n      result.push([point.X / scale, point.Y / scale]);\n    });\n    if (endless) result.push(result[0]); //to close it\n    // console.log(\"result\", result);\n    // console.log(\"connected\", connectPoints(result))\n\n    newContours.push(connectPoints(result));\n  }); // console.log(\"newContours\", newContours)\n\n  return newContours;\n}; // list of contours -> list of offset contours\n\nexport var clipOffsetContours = function clipOffsetContours(contours, offset) {\n  var joints = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var tolerance = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.01;\n  var scale = 1000; // const chains = maker.model.findChains(modelToOutline);\n\n  var newContours = contours.reduce(function (memo, contour, i) {\n    var start = contour[0].origin;\n    var end = contour[contour.length - 1].end;\n    var endless = end.every(function (entry, i) {\n      return entry === start[i];\n    });\n    var keyPoints = contour.map(function (line) {\n      return {\n        X: Math.round(line.origin[0] * scale),\n        Y: Math.round(line.origin[1] * scale)\n      };\n    });\n\n    if (endless) {\n      keyPoints.push(keyPoints[0]);\n    }\n\n    var paths = [keyPoints];\n    var co = new ClipperLib.ClipperOffset();\n    var offsetted = new ClipperLib.Paths();\n    co.Clear();\n    co.AddPaths(paths, JoinTypes[joints], endless ? EndTypes.etClosedLine : EndTypes.etOpenButt);\n    co.MiterLimit = 2;\n    co.ArcTolerance = 0.25;\n    co.Execute(offsetted, offset * scale);\n    offsetted.forEach(function (points, j) {\n      if (points.length === 0) return;\n      var result = [];\n      points.forEach(function (point) {\n        result.push([point.X / scale, point.Y / scale]);\n      });\n      if (endless) result.push(result[0]); //to close it\n\n      var newModel = connectPoints(result);\n      memo.push(newModel);\n    });\n    return memo;\n  }, []);\n  return newContours;\n}; // let paths = contour.map(line => ([\n//                     {X: Math.round(line.origin[0] * scale), Y: Math.round(line.origin[1] * scale)},\n//                     {X: Math.round(line.end[0] * scale), Y: Math.round(line.end[1] * scale)}\n//             ])).reduce((result, value, index, array) => {\n//                 if (index % 2 === 0) {\n//                     result.push(array.slice(index, index + 2).flat());\n//                 }\n//                 return result;\n//\n//             }, []);","map":{"version":3,"sources":["/Users/leomcelroy/Desktop/barkbeetle_js/src/unmakerjs/clipper.js"],"names":["ClipperLib","connectPoints","utils","EndTypes","etOpenSquare","etOpenRound","etOpenButt","etClosedPolygon","etClosedLine","JoinTypes","JoinType","jtSquare","jtRound","jtMiter","clipOffsetContour","contour","offset","joints","tolerance","scale","console","log","start","origin","end","length","endless","every","entry","i","keyPoints","map","line","X","Math","round","Y","push","paths","co","ClipperOffset","offsetted","Paths","Clear","AddPaths","MiterLimit","ArcTolerance","Execute","newContours","forEach","points","result","point","clipOffsetContours","contours","reduce","memo","j","newModel"],"mappings":"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","sourcesContent":["//This code is adapted from https://github.com/makercam/makercam/blob/master/src/clipperOffset.ts\n\nimport ClipperLib from 'js-clipper';\n\nimport {connectPoints} from './primitives.js';\nimport * as utils from '../utils.js';\n\nconst EndTypes = {\n    etOpenSquare: 0,\n    etOpenRound: 1,\n    etOpenButt: 2,\n    etClosedPolygon: 3,\n    etClosedLine: 4\n};\n\nconst JoinTypes = [\n    ClipperLib.JoinType.jtSquare,\n    ClipperLib.JoinType.jtRound,\n    ClipperLib.JoinType.jtMiter\n]\n\n// single contour -> list of offset contours\nexport const clipOffsetContour = (contour, offset, joints = 1, tolerance = 0.01) => {\n    const scale = 1000\n    console.log(\"clipper contour\", contour)\n    let start = contour[0].origin;\n    let end = contour[contour.length - 1].end;\n    let endless = end.every((entry, i) => entry === start[i]);\n\n    // console.log(\"contour\", contour);\n\n    let keyPoints = contour.map(line => { return {X: Math.round(line.origin[0] * scale), Y: Math.round(line.origin[1] * scale)} });\n\n    if (endless) {\n        keyPoints.push(keyPoints[0]);\n    } else {\n        end = {X: Math.round(end[0] * scale), Y: Math.round(end[1] * scale)};\n        keyPoints.push(end);\n    }\n\n    let paths = [keyPoints]\n\n    console.log(\"paths\", paths);\n\n    const co = new ClipperLib.ClipperOffset()\n    const offsetted = new ClipperLib.Paths()\n    co.Clear()\n    co.AddPaths(paths, JoinTypes[joints], endless ? EndTypes.etClosedLine : EndTypes.etOpenButt) //chain.endless ? EndTypes.etClosedLine : EndTypes.etOpenButt\n    co.MiterLimit = 2\n    co.ArcTolerance = 0.25\n    co.Execute(offsetted, offset * scale);\n\n    // console.log(\"offsetted\", offsetted)\n\n    // console.log(\"endless\",endless)\n\n    let newContours = []; //what should I return a list or a js object\n\n    // console.log(\"offsetted\", offsetted)\n\n    offsetted.forEach((points) => {\n        // console.log(\"points\", points)\n        if (points.length === 0) return\n        let result = []\n        points.forEach((point) => {\n            result.push([point.X / scale, point.Y / scale])\n        })\n\n        if (endless) result.push(result[0]); //to close it\n        // console.log(\"result\", result);\n        // console.log(\"connected\", connectPoints(result))\n\n        newContours.push(connectPoints(result));\n    })\n\n    // console.log(\"newContours\", newContours)\n\n    return newContours;\n}\n\n// list of contours -> list of offset contours\nexport const clipOffsetContours = (contours, offset, joints = 1, tolerance = 0.01) => {\n    const scale = 1000\n    // const chains = maker.model.findChains(modelToOutline);\n    const newContours = contours.reduce((memo, contour, i) => {\n        let start = contour[0].origin;\n        let end = contour[contour.length - 1].end;\n        let endless = end.every((entry, i) => entry === start[i]);\n\n        let keyPoints = contour.map(line => { return {X: Math.round(line.origin[0] * scale), Y: Math.round(line.origin[1] * scale)} });\n\n        if (endless) {\n            keyPoints.push(keyPoints[0])\n        }\n\n        let paths = [keyPoints]\n\n        const co = new ClipperLib.ClipperOffset()\n        const offsetted = new ClipperLib.Paths()\n        co.Clear()\n        co.AddPaths(paths, JoinTypes[joints], endless ? EndTypes.etClosedLine : EndTypes.etOpenButt)\n        co.MiterLimit = 2\n        co.ArcTolerance = 0.25\n        co.Execute(offsetted, offset * scale);\n        offsetted.forEach((points, j) => {\n            if (points.length === 0) return\n            let result = []\n            points.forEach((point: any) => {\n                result.push([point.X / scale, point.Y / scale])\n            })\n\n            if (endless) result.push(result[0]); //to close it\n            const newModel = connectPoints(result)\n\n            memo.push(newModel);\n        })\n        return memo\n    }, [])\n    return newContours;\n}\n\n// let paths = contour.map(line => ([\n//                     {X: Math.round(line.origin[0] * scale), Y: Math.round(line.origin[1] * scale)},\n//                     {X: Math.round(line.end[0] * scale), Y: Math.round(line.end[1] * scale)}\n//             ])).reduce((result, value, index, array) => {\n//                 if (index % 2 === 0) {\n//                     result.push(array.slice(index, index + 2).flat());\n//                 }\n//                 return result;\n//\n//             }, []);\n"]},"metadata":{},"sourceType":"module"}