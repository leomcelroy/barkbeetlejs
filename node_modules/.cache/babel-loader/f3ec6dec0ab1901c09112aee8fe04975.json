{"ast":null,"code":"// makerjs model, depth, params -> pocket toolpath\nimport * as mjs from 'makerjs';\nimport clipperOffset from './clipperOffset.js';\nimport { clipOffsetContour, clipOffsetContours } from '../unmakerjs/clipper.js';\n\nvar len = function len(toolpath) {\n  return Object.keys(toolpath).length;\n};\n\nvar isToolpath = function isToolpath(toolpath) {\n  console.log(\"toolpath\", toolpath);\n\n  if (len(toolpath) >= 1) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\nvar intToolpaths = function intToolpaths(geo, params) {\n  var contours = {};\n  var count = 0;\n  var pass = clipOffsetContour(geo, -params.compensatedRadius);\n\n  if (isToolpath(pass) !== true) {\n    return contours;\n  }\n\n  while (isToolpath(pass)) {\n    contours[count] = pass.flat();\n    count++;\n    console.log(\"contours\", contours);\n    pass = contours[count - 1].map(function (contour) {\n      return clipOffsetContour(contour, -params.compensatedRadius * params.stepoverPercentage / 100);\n    });\n  }\n\n  return contours;\n};\n\nvar pocket = function pocket(contour, params) {\n  var outlines = intToolpaths(contour, params); // let keyPoints = Object.values(outlines).map(outline => outline.map(line => [line.origin[0], line.origin[1]]));\n  //\n  // outlines = Object.values(outlines).flat();\n  //\n  // // console.log(\"keyPoints\", keyPoints);\n  //\n  // let gcodePoints = keyPoints.map(points => {\n  //   let raise = points.length > 1;\n  //   let firstPoint = points[0];\n  //\n  //   firstPoint = `G1 X${firstPoint[0]} Y${firstPoint[1]} F${params.feedRate}`;\n  //\n  //   if (raise) {\n  //     return [\n  //       `G1 Z${params.jogHeight} F${params.jogRate}`,\n  //       firstPoint, //want to jog to this one\n  //       \"plunge\",\n  //       ...points.map(point => `G1 X${point[0]} Y${point[1]} F${params.feedRate}`),\n  //       firstPoint,\n  //       `G1 Z${params.jogHeight} F${params.jogRate}`,\n  //     ]\n  //   } else {\n  //     return [\n  //       firstPoint,\n  //       \"plunge\",\n  //       ...points.map(point => `G1 X${point[0]} Y${point[1]} F${params.feedRate}`),\n  //       firstPoint\n  //     ]\n  //   }\n  // });\n  //\n  // let paths = gcodePoints.flat();\n  //\n  // // let firstPoint = keyPoints[0][0][0];\n  //\n  // let paths2 = params.depthOfPasses.map((p,i) => [\n  //   ...paths.map(x => (x === \"plunge\") ? `G1 Z${params.depthOfPasses[i]} F12.0` : x),\n  // ])\n  //\n  // // console.log(paths2)\n  //\n  // paths2 = paths2.flat();\n  //\n  // let preamble = [params.units, \"G90\"];\n  //\n  // let gcode = [\n  //   ...preamble,\n  //   \"(end of preamble)\",\n  //   `G1 Z${params.jogHeight} F${params.jogRate}`,\n  //   // `G0 X${firstPoint[0]} Y${firstPoint[1]}`,\n  //   ...paths2,\n  //   `G1 Z${params.jogHeight} F${params.jogRate}`,\n  // ]\n  //\n  //\n  // let text = gcode.join('\\n');\n  // write to a new file named\n\n  var filename = 'testGcodePocket.gcode';\n  var text = \"not yet\";\n  return {\n    drawing: outlines,\n    gcode: text,\n    filename: filename\n  };\n};\n\nexport { pocket };","map":{"version":3,"sources":["/Users/leomcelroy/Desktop/barkbeetle_js/src/toolpaths/pocket.js"],"names":["mjs","clipperOffset","clipOffsetContour","clipOffsetContours","len","toolpath","Object","keys","length","isToolpath","console","log","intToolpaths","geo","params","contours","count","pass","compensatedRadius","flat","map","contour","stepoverPercentage","pocket","outlines","filename","text","drawing","gcode"],"mappings":"AAAA;AACA,OAAO,KAAKA,GAAZ,MAAqB,SAArB;AACA,OAAOC,aAAP,MAA0B,oBAA1B;AACA,SAAQC,iBAAR,EAA2BC,kBAA3B,QAAoD,yBAApD;;AAGA,IAAMC,GAAG,GAAG,SAANA,GAAM,CAACC,QAAD;AAAA,SAAcC,MAAM,CAACC,IAAP,CAAYF,QAAZ,EAAsBG,MAApC;AAAA,CAAZ;;AAEA,IAAMC,UAAU,GAAG,SAAbA,UAAa,CAACJ,QAAD,EAAc;AAC/BK,EAAAA,OAAO,CAACC,GAAR,CAAY,UAAZ,EAAwBN,QAAxB;;AAEA,MAAID,GAAG,CAACC,QAAD,CAAH,IAAiB,CAArB,EAAwB;AACtB,WAAO,IAAP;AACD,GAFD,MAEO;AACL,WAAO,KAAP;AACD;AACF,CARD;;AAUA,IAAMO,YAAY,GAAG,SAAfA,YAAe,CAACC,GAAD,EAAMC,MAAN,EAAiB;AACpC,MAAIC,QAAQ,GAAG,EAAf;AACA,MAAIC,KAAK,GAAG,CAAZ;AAEA,MAAIC,IAAI,GAAGf,iBAAiB,CAACW,GAAD,EAAM,CAACC,MAAM,CAACI,iBAAd,CAA5B;;AAEA,MAAIT,UAAU,CAACQ,IAAD,CAAV,KAAqB,IAAzB,EAA+B;AAC7B,WAAOF,QAAP;AACD;;AAED,SAAON,UAAU,CAACQ,IAAD,CAAjB,EAAyB;AACvBF,IAAAA,QAAQ,CAACC,KAAD,CAAR,GAAkBC,IAAI,CAACE,IAAL,EAAlB;AACAH,IAAAA,KAAK;AACLN,IAAAA,OAAO,CAACC,GAAR,CAAY,UAAZ,EAAwBI,QAAxB;AACAE,IAAAA,IAAI,GAAGF,QAAQ,CAACC,KAAK,GAAG,CAAT,CAAR,CAAoBI,GAApB,CAAwB,UAAAC,OAAO;AAAA,aAAInB,iBAAiB,CAACmB,OAAD,EAAU,CAACP,MAAM,CAACI,iBAAR,GAA4BJ,MAAM,CAACQ,kBAAnC,GAAsD,GAAhE,CAArB;AAAA,KAA/B,CAAP;AAED;;AAED,SAAOP,QAAP;AACD,CAnBD;;AAqBA,IAAMQ,MAAM,GAAG,SAATA,MAAS,CAACF,OAAD,EAAUP,MAAV,EAAqB;AAElC,MAAIU,QAAQ,GAAGZ,YAAY,CAACS,OAAD,EAAUP,MAAV,CAA3B,CAFkC,CAIlC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA,MAAIW,QAAQ,GAAG,uBAAf;AACA,MAAIC,IAAI,GAAG,SAAX;AAEA,SAAO;AAACC,IAAAA,OAAO,EAAEH,QAAV;AAAoBI,IAAAA,KAAK,EAAEF,IAA3B;AAAiCD,IAAAA,QAAQ,EAARA;AAAjC,GAAP;AACD,CAlED;;AAqEA,SAAQF,MAAR","sourcesContent":["// makerjs model, depth, params -> pocket toolpath\nimport * as mjs from 'makerjs';\nimport clipperOffset from './clipperOffset.js';\nimport {clipOffsetContour, clipOffsetContours} from '../unmakerjs/clipper.js'\n\n\nconst len = (toolpath) => Object.keys(toolpath).length;\n\nconst isToolpath = (toolpath) => {\n  console.log(\"toolpath\", toolpath);\n\n  if (len(toolpath) >= 1) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nconst intToolpaths = (geo, params) => {\n  let contours = {};\n  let count = 0;\n\n  let pass = clipOffsetContour(geo, -params.compensatedRadius);\n\n  if (isToolpath(pass) !== true) {\n    return contours;\n  }\n\n  while (isToolpath(pass)) {\n    contours[count] = pass.flat();\n    count++;\n    console.log(\"contours\", contours)\n    pass = contours[count - 1].map(contour => clipOffsetContour(contour, -params.compensatedRadius * params.stepoverPercentage/100));\n\n  }\n\n  return contours;\n}\n\nconst pocket = (contour, params) => {\n\n  let outlines = intToolpaths(contour, params);\n\n  // let keyPoints = Object.values(outlines).map(outline => outline.map(line => [line.origin[0], line.origin[1]]));\n  //\n  // outlines = Object.values(outlines).flat();\n  //\n  // // console.log(\"keyPoints\", keyPoints);\n  //\n  // let gcodePoints = keyPoints.map(points => {\n  //   let raise = points.length > 1;\n  //   let firstPoint = points[0];\n  //\n  //   firstPoint = `G1 X${firstPoint[0]} Y${firstPoint[1]} F${params.feedRate}`;\n  //\n  //   if (raise) {\n  //     return [\n  //       `G1 Z${params.jogHeight} F${params.jogRate}`,\n  //       firstPoint, //want to jog to this one\n  //       \"plunge\",\n  //       ...points.map(point => `G1 X${point[0]} Y${point[1]} F${params.feedRate}`),\n  //       firstPoint,\n  //       `G1 Z${params.jogHeight} F${params.jogRate}`,\n  //     ]\n  //   } else {\n  //     return [\n  //       firstPoint,\n  //       \"plunge\",\n  //       ...points.map(point => `G1 X${point[0]} Y${point[1]} F${params.feedRate}`),\n  //       firstPoint\n  //     ]\n  //   }\n  // });\n  //\n  // let paths = gcodePoints.flat();\n  //\n  // // let firstPoint = keyPoints[0][0][0];\n  //\n  // let paths2 = params.depthOfPasses.map((p,i) => [\n  //   ...paths.map(x => (x === \"plunge\") ? `G1 Z${params.depthOfPasses[i]} F12.0` : x),\n  // ])\n  //\n  // // console.log(paths2)\n  //\n  // paths2 = paths2.flat();\n  //\n  // let preamble = [params.units, \"G90\"];\n  //\n  // let gcode = [\n  //   ...preamble,\n  //   \"(end of preamble)\",\n  //   `G1 Z${params.jogHeight} F${params.jogRate}`,\n  //   // `G0 X${firstPoint[0]} Y${firstPoint[1]}`,\n  //   ...paths2,\n  //   `G1 Z${params.jogHeight} F${params.jogRate}`,\n  // ]\n  //\n  //\n  // let text = gcode.join('\\n');\n\n  // write to a new file named\n  let filename = 'testGcodePocket.gcode';\n  let text = \"not yet\";\n\n  return {drawing: outlines, gcode: text, filename};\n};\n\n\nexport {pocket};\n"]},"metadata":{},"sourceType":"module"}