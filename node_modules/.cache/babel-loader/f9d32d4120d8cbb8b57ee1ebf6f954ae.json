{"ast":null,"code":"import _slicedToArray from \"/Users/leomcelroy/Desktop/barkbeetle_js/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nvar _jsxFileName = \"/Users/leomcelroy/Desktop/barkbeetle_js/src/unmakerjs/primitives.js\";\nimport React from 'react';\n\nvar isPrimitive = function isPrimitive(stroke) {\n  if (stroke.hasOwnProperty(\"type\")) {\n    if (stroke.type === \"line\" || stroke.type === \"arc\" || stroke.type === \"circle\" || stroke.type === \"bezier\") {\n      return true;\n    } else {\n      return false;\n    }\n  } else {\n    return false;\n  }\n};\n\nexport var line = function line(origin, end) {\n  return {\n    type: \"line\",\n    origin: origin,\n    end: end\n  };\n};\nexport var connectPoints = function connectPoints(pointsArray) {\n  var lines = [];\n  var lastPoint;\n  pointsArray.forEach(function (point, index) {\n    if (index === 0) {\n      lastPoint = point;\n      return;\n    } else {\n      lines.push(line(lastPoint, point));\n      lastPoint = point;\n    }\n  });\n  return lines;\n};\nexport var renderLine = function renderLine(line, id) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n    selected: false,\n    highlighted: false,\n    toolpath: false\n  };\n  var points = [line.origin, line.end];\n  var pathData = \"M \" + points.map(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        x = _ref2[0],\n        y = _ref2[1];\n\n    return \"\".concat(x, \" \").concat(y);\n  });\n  var color = \"black\";\n  if (selected) color = \"red\";\n  if (highlighted) color = \"yellow\";\n  var style = {\n    fill: \"none\",\n    strokeWidth: \"2px\",\n    stroke: color,\n    strokeLinejoin: \"round\",\n    strokeLinecap: \"round\",\n    opacity: \"1\",\n    vectorEffect: \"non-scaling-stroke\"\n  };\n  var path = React.createElement(\"path\", {\n    d: pathData,\n    style: style,\n    key: id,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 65\n    },\n    __self: this\n  });\n  return path;\n};\n\nvar arc = function arc(origin, radius, startAngle, endAngle) {\n  return {\n    type: \"arc\",\n    origin: origin,\n    radius: radius,\n    startAngle: startAngle,\n    endAngle: endAngle\n  };\n};\n\nvar circle = function circle(origin, radius) {\n  return {\n    type: \"circle\",\n    origin: origin,\n    radius: radius\n  };\n};\n\nvar bezier = function bezier(origin, cOrigin, end, cEnd) {\n  return {\n    type: \"bezier\",\n    origin: origin,\n    cOrigin: cOrigin,\n    end: end,\n    cEnd: cEnd\n  };\n};","map":{"version":3,"sources":["/Users/leomcelroy/Desktop/barkbeetle_js/src/unmakerjs/primitives.js"],"names":["React","isPrimitive","stroke","hasOwnProperty","type","line","origin","end","connectPoints","pointsArray","lines","lastPoint","forEach","point","index","push","renderLine","id","options","selected","highlighted","toolpath","points","pathData","map","x","y","color","style","fill","strokeWidth","strokeLinejoin","strokeLinecap","opacity","vectorEffect","path","arc","radius","startAngle","endAngle","circle","bezier","cOrigin","cEnd"],"mappings":"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","sourcesContent":["import React from 'react';\n\nconst isPrimitive = (stroke) => {\n  if (stroke.hasOwnProperty(\"type\")) {\n\n    if (stroke.type === \"line\" ||\n        stroke.type === \"arc\" ||\n        stroke.type === \"circle\" ||\n        stroke.type === \"bezier\") {\n          return true;\n        } else {\n          return false;\n        }\n\n  } else {\n    return false;\n  }\n}\n\nexport const line = (origin, end) => {\n  return {\n    type: \"line\",\n    origin,\n    end,\n  }\n}\n\nexport const connectPoints = (pointsArray) => {\n  let lines = [];\n  let lastPoint;\n\n  pointsArray.forEach((point, index) => {\n    if (index === 0) {\n      lastPoint = point;\n      return\n    } else {\n      lines.push(line(lastPoint, point));\n      lastPoint = point;\n    }\n  })\n\n  return lines;\n}\n\nexport const renderLine = (line, id, options = {selected : false, highlighted: false, toolpath: false} ) => {\n  let points = [line.origin, line.end];\n\n  let pathData = \"M \" + points.map(([x, y]) => `${x} ${y}`);\n\n  let color = \"black\";\n\n  if (selected) color = \"red\";\n  if (highlighted) color = \"yellow\";\n\n  let style = {\n        fill: \"none\",\n        strokeWidth: \"2px\",\n        stroke: color,\n        strokeLinejoin: \"round\",\n        strokeLinecap: \"round\",\n        opacity: \"1\",\n        vectorEffect: \"non-scaling-stroke\"\n      }\n\n  let path = <path d={pathData} style={style} key={id}/>;\n\n  return path;\n\n}\n\nconst arc = (origin, radius, startAngle, endAngle) => {\n  return {\n    type: \"arc\",\n    origin,\n    radius,\n    startAngle,\n    endAngle,\n  }\n}\n\nconst circle = (origin, radius) => {\n  return {\n    type: \"circle\",\n    origin,\n    radius,\n  }\n}\n\nconst bezier = (origin, cOrigin, end, cEnd) => {\n  return {\n    type: \"bezier\",\n    origin,\n    cOrigin,\n    end,\n    cEnd\n  }\n}\n"]},"metadata":{},"sourceType":"module"}