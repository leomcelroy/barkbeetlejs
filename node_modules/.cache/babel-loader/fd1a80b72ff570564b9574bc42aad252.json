{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nimport React, { PureComponent } from 'react';\nimport PropTypes from 'prop-types';\nimport cn from 'classnames';\nimport isRequiredForA11y from 'react-prop-types/lib/isRequiredForA11y';\nimport deprecated from 'react-prop-types/lib/deprecated';\nimport { TAB, SPACE, ENTER } from '../constants/keyCodes';\nimport captureNextEvent from '../utils/EventUtils/captureNextEvent';\nimport getBtnStyles from '../Buttons/getBtnStyles';\nimport FontIcon from '../FontIcons/FontIcon';\nimport IconSeparator from '../Helpers/IconSeparator';\nimport AccessibleFakeInkedButton from '../Helpers/AccessibleFakeInkedButton';\n/**\n * The `FileInput` component is used as simple styling for the `<input type=\"file\" />`.\n * It will style the input as a raised button by default.\n */\n\nvar FileInput = function (_PureComponent) {\n  _inherits(FileInput, _PureComponent);\n\n  function FileInput() {\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, FileInput);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.state = {\n      hover: false,\n      pressed: false\n    }, _this._handleChange = function (e) {\n      var _this$props = _this.props,\n          multiple = _this$props.multiple,\n          onChange = _this$props.onChange;\n      var files = e.target.files;\n\n      if (onChange) {\n        if (!multiple) {\n          onChange(files[0] || null, e);\n        } else {\n          onChange(Array.prototype.slice.call(files), e);\n        }\n      }\n    }, _this._blur = function () {\n      if (_this.props.disabled) {\n        return;\n      }\n\n      if (_this._timeout) {\n        _this._attemptedBlur = true;\n      } else {\n        _this.setState({\n          pressed: false\n        });\n      }\n    }, _this._handleMouseUp = function (e) {\n      if (_this.props.onMouseUp) {\n        _this.props.onMouseUp(e);\n      }\n\n      _this._blur();\n    }, _this._handleMouseDown = function (e) {\n      if (_this.props.onMouseDown) {\n        _this.props.onMouseDown(e);\n      }\n\n      if (!_this.props.disabled) {\n        _this.setState({\n          pressed: true\n        });\n      }\n    }, _this._handleTouchStart = function (e) {\n      if (_this.props.onTouchStart) {\n        _this.props.onTouchStart(e);\n      }\n\n      if (!_this.props.disabled) {\n        _this.setState({\n          pressed: true\n        });\n      }\n    }, _this._handleTouchEnd = function (e) {\n      if (_this.props.onTouchEnd) {\n        _this.props.onTouchEnd(e);\n      }\n\n      _this._blur();\n\n      captureNextEvent('mouseover');\n    }, _this._handleKeyUp = function (e) {\n      if (_this.props.onKeyUp) {\n        _this.props.onKeyUp(e);\n      }\n\n      if ((e.which || e.keyCode) === TAB) {\n        window.addEventListener('click', _this._blur);\n\n        _this.setState({\n          pressed: true\n        });\n      }\n    }, _this._handleKeyDown = function (e) {\n      if (_this.props.onKeyDown) {\n        _this.props.onKeyDown(e);\n      }\n\n      var key = e.which || e.keyCode;\n\n      if (key === TAB) {\n        window.removeEventListener('click', _this._blur);\n\n        _this.setState({\n          pressed: false\n        });\n      } else if (key === SPACE || key === ENTER) {\n        e.preventDefault();\n        e.target.click();\n      }\n    }, _this._handleMouseOver = function (e) {\n      if (_this.props.onMouseOver) {\n        _this.props.onMouseOver(e);\n      }\n\n      if (!_this.props.disabled) {\n        _this.setState({\n          hover: true\n        });\n      }\n    }, _this._handleMouseLeave = function (e) {\n      if (_this.props.onMouseLeave) {\n        _this.props.onMouseLeave(e);\n      }\n\n      if (!_this.props.disabled) {\n        _this.setState({\n          hover: false\n        });\n      }\n    }, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  FileInput.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {\n    if (this.props.disabled && !nextProps.disabled && this.state.hover) {\n      this.setState({\n        hover: false\n      });\n    }\n  };\n\n  FileInput.prototype.componentWillUpdate = function componentWillUpdate(nextProps, nextState) {\n    var _this2 = this; // I honestly don't remember why this was implemented, but it was copied from the Button\n    // component\n\n\n    if (!this.state.pressed && nextState.pressed) {\n      this._timeout = setTimeout(function () {\n        _this2._timeout = null;\n\n        if (_this2._attemptedBlur) {\n          _this2._attemptedBlur = false;\n\n          _this2.setState({\n            pressed: false\n          });\n        }\n      }, 450);\n    }\n  };\n\n  FileInput.prototype.componentWillUnmount = function componentWillUnmount() {\n    if (this._timeout) {\n      clearTimeout(this._timeout);\n    }\n\n    window.removeEventListener('click', this._blur);\n  };\n\n  FileInput.prototype.render = function render() {\n    var _state = this.state,\n        hover = _state.hover,\n        pressed = _state.pressed;\n\n    var _props = this.props,\n        style = _props.style,\n        className = _props.className,\n        labelStyle = _props.labelStyle,\n        labelClassName = _props.labelClassName,\n        label = _props.label,\n        primary = _props.primary,\n        secondary = _props.secondary,\n        flat = _props.flat,\n        id = _props.id,\n        name = _props.name,\n        iconBefore = _props.iconBefore,\n        disabled = _props.disabled,\n        accept = _props.accept,\n        multiple = _props.multiple,\n        swapTheming = _props.swapTheming,\n        allowDuplicates = _props.allowDuplicates,\n        capture = _props.capture,\n        iconChildren = _props.iconChildren,\n        iconClassName = _props.iconClassName,\n        propIcon = _props.icon,\n        onChange = _props.onChange,\n        onKeyUp = _props.onKeyUp,\n        onKeyDown = _props.onKeyDown,\n        onMouseUp = _props.onMouseUp,\n        onMouseDown = _props.onMouseDown,\n        onMouseOver = _props.onMouseOver,\n        onMouseLeave = _props.onMouseLeave,\n        onTouchStart = _props.onTouchStart,\n        onTouchEnd = _props.onTouchEnd,\n        propValue = _props.value,\n        props = _objectWithoutProperties(_props, ['style', 'className', 'labelStyle', 'labelClassName', 'label', 'primary', 'secondary', 'flat', 'id', 'name', 'iconBefore', 'disabled', 'accept', 'multiple', 'swapTheming', 'allowDuplicates', 'capture', 'iconChildren', 'iconClassName', 'icon', 'onChange', 'onKeyUp', 'onKeyDown', 'onMouseUp', 'onMouseDown', 'onMouseOver', 'onMouseLeave', 'onTouchStart', 'onTouchEnd', 'value']);\n\n    var icon = this.props.icon;\n\n    if (iconClassName || iconChildren) {\n      icon = React.createElement(FontIcon, {\n        iconClassName: iconClassName\n      }, iconChildren);\n    }\n\n    var labelChildren = label;\n\n    if (icon) {\n      icon = React.cloneElement(icon, {\n        inherit: true\n      });\n      labelChildren = React.createElement(IconSeparator, {\n        label: label,\n        iconBefore: iconBefore\n      }, icon);\n    }\n\n    var value = void 0;\n\n    if (allowDuplicates) {\n      value = '';\n    }\n\n    return React.createElement('div', _extends({}, props, {\n      style: style,\n      className: cn('md-inline-block md-file-input-container', className)\n    }), React.createElement(AccessibleFakeInkedButton, {\n      component: 'label',\n      htmlFor: id,\n      disabled: disabled,\n      onTouchStart: this._handleTouchStart,\n      onTouchEnd: this._handleTouchEnd,\n      onMouseDown: this._handleMouseDown,\n      onMouseUp: this._handleMouseUp,\n      onKeyDown: this._handleKeyDown,\n      onKeyUp: this._handleKeyUp,\n      onMouseOver: this._handleMouseOver,\n      onMouseLeave: this._handleMouseLeave,\n      style: labelStyle,\n      className: getBtnStyles({\n        flat: flat,\n        raised: !flat,\n        disabled: disabled,\n        primary: primary,\n        secondary: secondary,\n        hover: hover,\n        swapTheming: swapTheming,\n        pressed: pressed\n      }, labelClassName)\n    }, labelChildren), React.createElement('input', {\n      id: id,\n      name: name,\n      accept: accept,\n      type: 'file',\n      multiple: multiple,\n      disabled: disabled,\n      'aria-hidden': 'true',\n      className: 'md-file-input',\n      onChange: this._handleChange,\n      value: value,\n      tabIndex: -1,\n      capture: capture\n    }));\n  };\n\n  return FileInput;\n}(PureComponent);\n\nFileInput.propTypes = {\n  /**\n   * The id for the text field. This is required for a11y and to get the `input type=\"file\"` to\n   * open.\n   */\n  id: isRequiredForA11y(PropTypes.oneOfType([PropTypes.string, PropTypes.number])),\n\n  /**\n   * An optional name to provide to the input.\n   */\n  name: PropTypes.string,\n\n  /**\n   * An optional style to apply.\n   */\n  style: PropTypes.object,\n\n  /**\n   * An optional className to apply.\n   */\n  className: PropTypes.string,\n\n  /**\n   * An optional style to apply to the label.\n   */\n  labelStyle: PropTypes.object,\n\n  /**\n   * An optional className to apply to the label.\n   */\n  labelClassName: PropTypes.string,\n\n  /**\n   * Boolean if the `FileInput` should be styled with the primary color.\n   */\n  primary: PropTypes.bool,\n\n  /**\n   * Boolean if the `FileInput` should be styled with the secondary color.\n   */\n  secondary: PropTypes.bool,\n\n  /**\n   * Boolean if the `FileInput` should be styled as a flat button instead of a\n   * raised button.\n   */\n  flat: PropTypes.bool,\n\n  /**\n   * Boolean if the theming should be swapped from text to background or vice-versa.\n   *\n   * @see {@link Buttons/Button#swapTheming}\n   */\n  swapTheming: PropTypes.bool,\n\n  /**\n   * This should be a comma separated list of Media Types that the `FileInput` can\n   * accept. If this prop is left blank, any file will be accepted.\n   *\n   * The values can either be:\n   * - A file extension\n   * - audio/*\n   * - video/*\n   * - image/*\n   * - any valid [IANA Media Type](http://www.iana.org/assignments/media-types/media-types.xhtml)\n   *\n   * > NOTE: IE does not enforce this.\n   */\n  accept: PropTypes.string,\n\n  /**\n   * Boolean if the same file is allowed to be uploaded multiple times. This will basically make the\n   * `value` of the file input always blank.\n   */\n  allowDuplicates: PropTypes.bool,\n\n  /**\n   * Boolean if multiple files will be accepted.\n   */\n  multiple: PropTypes.bool,\n\n  /**\n   * A label to display on the `FileInput`. This will be used with the `AccessibleFakeInkedButton` component to\n   * create a `<label>` for the `<input type=\"file\">`.\n   */\n  label: PropTypes.node,\n\n  /**\n   * Boolean if the icons should appear before the label.\n   */\n  iconBefore: PropTypes.bool,\n\n  /**\n   * An optional icon to display with the file download. This can be a `FontIcon` or an `SVGIcon`.\n   */\n  icon: PropTypes.element,\n\n  /**\n   * A function to call when the value of the input changes. This will\n   * be triggered when the user selects a new file or cancels the new file selection.\n   *\n   * This function will be given the new [FileList](https://developer.mozilla.org/en-US/docs/Web/API/FileList)\n   * as an array and the change event. If this is not a multiple file input, only the\n   * newly selected File will be given instead of a list of one file. Since this is an\n   * `input` tag, the user will not be able to select the same file multiple times unless\n   * you manually clear the input's value.\n   *\n   * > NOTE: If the user hits cancel, null will be given for a single file input.\n   *\n   * ```js\n   * onChange(files, e);\n   * ```\n   */\n  onChange: PropTypes.func,\n\n  /**\n   * This prop tells mobile browsers that the input would prefer the user to get the image/video from\n   * the camera instead of using the file browser. This will be completely ignored by desktop browsers.\n   *\n   * Providing `'user'` will select the front facing camera while `'environment'` will select the rear facing\n   * camera.\n   *\n   * @see https://developers.google.com/web/fundamentals/media/capturing-images/\n   */\n  capture: PropTypes.oneOf(['user', 'environment']),\n\n  /**\n   * Boolean if the `FileInput` is currently disabled.\n   */\n  disabled: PropTypes.bool,\n\n  /**\n   * An optional function to call when they keyup event is triggered on the file input's label.\n   */\n  onKeyUp: PropTypes.func,\n\n  /**\n   * An optional function to call when they keydown event is triggered on the file input's label.\n   */\n  onKeyDown: PropTypes.func,\n\n  /**\n   * An optional function to call when they mouseup event is triggered on the file input's label.\n   */\n  onMouseUp: PropTypes.func,\n\n  /**\n   * An optional function to call when they mousedown event is triggered on the file input's label.\n   */\n  onMouseDown: PropTypes.func,\n\n  /**\n   * An optional function to call when they mouseover event is triggered on the file input's label.\n   */\n  onMouseOver: PropTypes.func,\n\n  /**\n   * An optional function to call when they mouseleave event is triggered on the file input's label.\n   */\n  onMouseLeave: PropTypes.func,\n\n  /**\n   * An optional function to call when they touchend event is triggered on the file input's label.\n   */\n  onTouchEnd: PropTypes.func,\n\n  /**\n   * An optional function to call when they touchstart event is triggered on the file input's label.\n   */\n  onTouchStart: PropTypes.func,\n  iconChildren: deprecated(PropTypes.node, 'Use `icon` instead'),\n  iconClassName: deprecated(PropTypes.string, 'Use `icon` instead'),\n  value: deprecated(PropTypes.string, 'There should\\'t be a reason to set the value manually. Check out {@link #allowDuplicates} instead')\n};\nFileInput.defaultProps = {\n  label: 'Select a file',\n  icon: React.createElement(FontIcon, null, 'file_upload'),\n  allowDuplicates: false\n};\nexport default FileInput;","map":null,"metadata":{},"sourceType":"module"}