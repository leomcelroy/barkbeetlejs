{"ast":null,"code":"import _toConsumableArray from \"/Users/leomcelroy/Desktop/barkbeetle_js/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { clipOffsetContour } from '../unmakerjs/clipper.js';\nimport { depthOfPasses } from '../parameters.js';\n\nvar offsetFunc = function offsetFunc(offset) {\n  if (offset === \"outside\") {\n    return false;\n  } else if (offset === \"inside\") {\n    return true;\n  } else if (offset === \"none\") {\n    return \"none\";\n  }\n};\n\nvar createToolpaths = function createToolpaths(contour, params) {\n  var outline;\n  var offset = offsetFunc(params.offset);\n\n  if (offset === \"none\") {\n    outline = [contour];\n  } else {\n    //outline = mjs.model.outline(p, params.compensatedRadius, 0, offset); //third parameter is what type of corners, 0 (rounded) by default\n    offset = offset === true ? -1 : 1;\n    outline = clipOffsetContour(contour, offset * params.compensatedRadius);\n  } // outline = outline.flat(); //TODO: BUG this is a hack to deal with not raising the bit yet\n\n\n  return outline;\n};\n\nexport var profileGcode = function profileGcode(toolpaths, params) {\n  toolpaths = toolpaths.flat(); //TODO: BUG this is a hack to deal with not raising the bit yet\n\n  var keyPoints = toolpaths.map(function (line) {\n    return [line.origin[0], line.origin[1]];\n  });\n  var gcodePoints = keyPoints.map(function (p) {\n    return \"G1 X\".concat(p[0], \" Y\").concat(p[1], \" F\").concat(params.feedRate);\n  }); //let gcode = JSON.parse(JSON.stringify(gcodePoints));\n\n  var firstPoint = keyPoints[0]; //TODO: BUG what if there are no key points\n\n  var passDepths = depthOfPasses(params.cutDepth, params.passDepth);\n  var paths = passDepths.map(function (p, i) {\n    return [\"G1 Z\".concat(passDepths[i], \" F\").concat(params.plungeRate)].concat(_toConsumableArray(gcodePoints), [\"G1 X\".concat(firstPoint[0], \" Y\").concat(firstPoint[1], \" F\").concat(params.feedRate)]);\n  });\n  paths = paths.flat(1);\n  var units;\n  if (params.units === \"in\") units = \"G20\";\n  if (params.units === \"mm\") units = \"G21\";\n  var preamble = [units, \"G90\"];\n  var gcode = [].concat(preamble, [\"(end of preamble)\", \"G1 Z\".concat(params.jogHeight, \" F\").concat(params.jogRate), \"G0 X\".concat(firstPoint[0], \" Y\").concat(firstPoint[1])], _toConsumableArray(paths), [\"G1 Z\".concat(params.jogHeight, \" F\").concat(params.jogRate)]);\n  var text = gcode.join('\\n');\n  return text;\n};\nexport var profile = function profile(contour, params) {\n  var toolpaths = createToolpaths(contour, params); // let gcode = profileGcode(toolpaths, params);\n\n  return {\n    drawing: toolpaths,\n    geometry: toolpaths\n  };\n};","map":{"version":3,"sources":["/Users/leomcelroy/Desktop/barkbeetle_js/src/toolpaths/profile.js"],"names":["clipOffsetContour","depthOfPasses","offsetFunc","offset","createToolpaths","contour","params","outline","compensatedRadius","profileGcode","toolpaths","flat","keyPoints","map","line","origin","gcodePoints","p","feedRate","firstPoint","passDepths","cutDepth","passDepth","paths","i","plungeRate","units","preamble","gcode","jogHeight","jogRate","text","join","profile","drawing","geometry"],"mappings":"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","sourcesContent":["import {clipOffsetContour} from '../unmakerjs/clipper.js'\nimport {depthOfPasses} from '../parameters.js'\n\n\nconst offsetFunc = (offset) => {\n  if (offset === \"outside\") {\n    return false;\n  } else if (offset === \"inside\") {\n    return true;\n  } else if (offset === \"none\") {\n    return \"none\";\n  }\n}\n\nconst createToolpaths = (contour, params) => {\n  let outline;\n  let offset = offsetFunc(params.offset);\n  if (offset === \"none\") {\n    outline = [contour];\n  } else {\n    //outline = mjs.model.outline(p, params.compensatedRadius, 0, offset); //third parameter is what type of corners, 0 (rounded) by default\n    offset = (offset === true) ? -1 : 1;\n\n    outline = clipOffsetContour(contour, offset * params.compensatedRadius);\n  }\n\n  // outline = outline.flat(); //TODO: BUG this is a hack to deal with not raising the bit yet\n\n  return outline;\n}\n\nexport const profileGcode = (toolpaths, params) => {\n  toolpaths = toolpaths.flat(); //TODO: BUG this is a hack to deal with not raising the bit yet\n\n  let keyPoints = toolpaths.map(line => [line.origin[0], line.origin[1]]);\n\n  let gcodePoints = keyPoints.map(p => `G1 X${p[0]} Y${p[1]} F${params.feedRate}`)\n  //let gcode = JSON.parse(JSON.stringify(gcodePoints));\n\n  let firstPoint = keyPoints[0]; //TODO: BUG what if there are no key points\n\n  let passDepths = depthOfPasses(params.cutDepth, params.passDepth);\n\n  let paths = passDepths.map((p,i) => [\n    `G1 Z${passDepths[i]} F${params.plungeRate}`, //plunge rate\n    ...gcodePoints,\n    `G1 X${firstPoint[0]} Y${firstPoint[1]} F${params.feedRate}`\n  ])\n\n  paths = paths.flat(1);\n\n  let units;\n  if (params.units === \"in\") units = \"G20\";\n  if (params.units === \"mm\") units = \"G21\";\n\n  let preamble = [units, \"G90\"];\n\n  let gcode = [\n    ...preamble,\n    \"(end of preamble)\",\n    `G1 Z${params.jogHeight} F${params.jogRate}`,\n    `G0 X${firstPoint[0]} Y${firstPoint[1]}`,\n    ...paths,\n    `G1 Z${params.jogHeight} F${params.jogRate}`,\n  ]\n\n  let text = gcode.join('\\n');\n\n  return text\n}\n\nexport const profile = (contour, params) => {\n\n  let toolpaths = createToolpaths(contour, params);\n  // let gcode = profileGcode(toolpaths, params);\n\n  return {drawing: toolpaths, geometry: toolpaths};\n};\n"]},"metadata":{},"sourceType":"module"}