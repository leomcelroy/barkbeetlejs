"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf3 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _layers = require("../../layers");

var _ScrollbarSize = _interopRequireDefault(require("./ScrollbarSize"));

var TableHead =
/*#__PURE__*/
function (_PureComponent) {
  (0, _inherits2.default)(TableHead, _PureComponent);

  function TableHead() {
    var _getPrototypeOf2;

    var _this;

    (0, _classCallCheck2.default)(this, TableHead);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(TableHead)).call.apply(_getPrototypeOf2, [this].concat(args)));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "state", {
      scrollbarWidth: 0
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleScrollbarSize", function (width) {
      _this.setState({
        scrollbarWidth: width
      });
    });
    return _this;
  }

  (0, _createClass2.default)(TableHead, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          children = _this$props.children,
          height = _this$props.height,
          accountForScrollbar = _this$props.accountForScrollbar,
          props = (0, _objectWithoutProperties2.default)(_this$props, ["children", "height", "accountForScrollbar"]);
      var scrollbarWidth = this.state.scrollbarWidth;
      return _react.default.createElement(_layers.Pane, (0, _extends2.default)({
        display: "flex",
        flexShrink: 0,
        paddingRight: scrollbarWidth,
        borderBottom: "default",
        background: "tint2",
        height: height
      }, props), children, ' ', accountForScrollbar && _react.default.createElement(_ScrollbarSize.default, {
        handleScrollbarSize: this.handleScrollbarSize
      }));
    }
  }]);
  return TableHead;
}(_react.PureComponent);

exports.default = TableHead;
TableHead.displayName = "TableHead";
(0, _defineProperty2.default)(TableHead, "propTypes", (0, _objectSpread2.default)({}, _layers.Pane.propTypes, {
  /**
   * The height of the table head.
   */
  height: _propTypes.default.number.isRequired,

  /**
   * This should always be true if you are using TableHead together with a TableBody.
   * Because TableBody has `overflowY: scroll` by default.
   */
  accountForScrollbar: _propTypes.default.bool
}));
(0, _defineProperty2.default)(TableHead, "defaultProps", {
  height: 32,
  accountForScrollbar: true
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy90YWJsZS9zcmMvVGFibGVIZWFkLmpzIl0sIm5hbWVzIjpbIlRhYmxlSGVhZCIsInNjcm9sbGJhcldpZHRoIiwid2lkdGgiLCJzZXRTdGF0ZSIsInByb3BzIiwiY2hpbGRyZW4iLCJoZWlnaHQiLCJhY2NvdW50Rm9yU2Nyb2xsYmFyIiwic3RhdGUiLCJoYW5kbGVTY3JvbGxiYXJTaXplIiwiUHVyZUNvbXBvbmVudCIsIlBhbmUiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJudW1iZXIiLCJpc1JlcXVpcmVkIiwiYm9vbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztJQUVxQkEsUzs7Ozs7Ozs7Ozs7Ozs7Ozs7d0ZBbUJYO0FBQ05DLE1BQUFBLGNBQWMsRUFBRTtBQURWLEs7c0dBU2MsVUFBQUMsS0FBSyxFQUFJO0FBQzdCLFlBQUtDLFFBQUwsQ0FBYztBQUNaRixRQUFBQSxjQUFjLEVBQUVDO0FBREosT0FBZDtBQUdELEs7Ozs7Ozs2QkFFUTtBQUFBLHdCQUNxRCxLQUFLRSxLQUQxRDtBQUFBLFVBQ0NDLFFBREQsZUFDQ0EsUUFERDtBQUFBLFVBQ1dDLE1BRFgsZUFDV0EsTUFEWDtBQUFBLFVBQ21CQyxtQkFEbkIsZUFDbUJBLG1CQURuQjtBQUFBLFVBQzJDSCxLQUQzQztBQUFBLFVBRUNILGNBRkQsR0FFb0IsS0FBS08sS0FGekIsQ0FFQ1AsY0FGRDtBQUlQLGFBQ0UsNkJBQUMsWUFBRDtBQUNFLFFBQUEsT0FBTyxFQUFDLE1BRFY7QUFFRSxRQUFBLFVBQVUsRUFBRSxDQUZkO0FBR0UsUUFBQSxZQUFZLEVBQUVBLGNBSGhCO0FBSUUsUUFBQSxZQUFZLEVBQUMsU0FKZjtBQUtFLFFBQUEsVUFBVSxFQUFDLE9BTGI7QUFNRSxRQUFBLE1BQU0sRUFBRUs7QUFOVixTQU9NRixLQVBOLEdBU0dDLFFBVEgsRUFTYSxHQVRiLEVBVUdFLG1CQUFtQixJQUNsQiw2QkFBQyxzQkFBRDtBQUFlLFFBQUEsbUJBQW1CLEVBQUUsS0FBS0U7QUFBekMsUUFYSixDQURGO0FBZ0JEOzs7RUF0RG9DQyxvQjs7O0FBQWxCVixTOzhCQUFBQSxTLCtDQUtkVyxhQUFLQyxTO0FBRVI7OztBQUdBTixFQUFBQSxNQUFNLEVBQUVPLG1CQUFVQyxNQUFWLENBQWlCQyxVOztBQUV6Qjs7OztBQUlBUixFQUFBQSxtQkFBbUIsRUFBRU0sbUJBQVVHOzs4QkFoQmRoQixTLGtCQXVCRztBQUNwQk0sRUFBQUEsTUFBTSxFQUFFLEVBRFk7QUFFcEJDLEVBQUFBLG1CQUFtQixFQUFFO0FBRkQsQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBQdXJlQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnXG5pbXBvcnQgeyBQYW5lIH0gZnJvbSAnLi4vLi4vbGF5ZXJzJ1xuaW1wb3J0IFNjcm9sbGJhclNpemUgZnJvbSAnLi9TY3JvbGxiYXJTaXplJ1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUYWJsZUhlYWQgZXh0ZW5kcyBQdXJlQ29tcG9uZW50IHtcbiAgc3RhdGljIHByb3BUeXBlcyA9IHtcbiAgICAvKipcbiAgICAgKiBDb21wb3NlcyB0aGUgUGFuZSBjb21wb25lbnQgYXMgdGhlIGJhc2UuXG4gICAgICovXG4gICAgLi4uUGFuZS5wcm9wVHlwZXMsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSB0YWJsZSBoZWFkLlxuICAgICAqL1xuICAgIGhlaWdodDogUHJvcFR5cGVzLm51bWJlci5pc1JlcXVpcmVkLFxuXG4gICAgLyoqXG4gICAgICogVGhpcyBzaG91bGQgYWx3YXlzIGJlIHRydWUgaWYgeW91IGFyZSB1c2luZyBUYWJsZUhlYWQgdG9nZXRoZXIgd2l0aCBhIFRhYmxlQm9keS5cbiAgICAgKiBCZWNhdXNlIFRhYmxlQm9keSBoYXMgYG92ZXJmbG93WTogc2Nyb2xsYCBieSBkZWZhdWx0LlxuICAgICAqL1xuICAgIGFjY291bnRGb3JTY3JvbGxiYXI6IFByb3BUeXBlcy5ib29sXG4gIH1cblxuICBzdGF0ZSA9IHtcbiAgICBzY3JvbGxiYXJXaWR0aDogMFxuICB9XG5cbiAgc3RhdGljIGRlZmF1bHRQcm9wcyA9IHtcbiAgICBoZWlnaHQ6IDMyLFxuICAgIGFjY291bnRGb3JTY3JvbGxiYXI6IHRydWVcbiAgfVxuXG4gIGhhbmRsZVNjcm9sbGJhclNpemUgPSB3aWR0aCA9PiB7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBzY3JvbGxiYXJXaWR0aDogd2lkdGhcbiAgICB9KVxuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4sIGhlaWdodCwgYWNjb3VudEZvclNjcm9sbGJhciwgLi4ucHJvcHMgfSA9IHRoaXMucHJvcHNcbiAgICBjb25zdCB7IHNjcm9sbGJhcldpZHRoIH0gPSB0aGlzLnN0YXRlXG5cbiAgICByZXR1cm4gKFxuICAgICAgPFBhbmVcbiAgICAgICAgZGlzcGxheT1cImZsZXhcIlxuICAgICAgICBmbGV4U2hyaW5rPXswfVxuICAgICAgICBwYWRkaW5nUmlnaHQ9e3Njcm9sbGJhcldpZHRofVxuICAgICAgICBib3JkZXJCb3R0b209XCJkZWZhdWx0XCJcbiAgICAgICAgYmFja2dyb3VuZD1cInRpbnQyXCJcbiAgICAgICAgaGVpZ2h0PXtoZWlnaHR9XG4gICAgICAgIHsuLi5wcm9wc31cbiAgICAgID5cbiAgICAgICAge2NoaWxkcmVufXsnICd9XG4gICAgICAgIHthY2NvdW50Rm9yU2Nyb2xsYmFyICYmIChcbiAgICAgICAgICA8U2Nyb2xsYmFyU2l6ZSBoYW5kbGVTY3JvbGxiYXJTaXplPXt0aGlzLmhhbmRsZVNjcm9sbGJhclNpemV9IC8+XG4gICAgICAgICl9XG4gICAgICA8L1BhbmU+XG4gICAgKVxuICB9XG59XG4iXX0=