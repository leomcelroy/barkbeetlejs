{"version":3,"sources":["webpack://TransformationMatrix/webpack/universalModuleDefinition","webpack://TransformationMatrix/webpack/bootstrap","webpack://TransformationMatrix/./src/applyToPoint.js","webpack://TransformationMatrix/./src/fromObject.js","webpack://TransformationMatrix/./src/fromString.js","webpack://TransformationMatrix/./src/identity.js","webpack://TransformationMatrix/./src/inverse.js","webpack://TransformationMatrix/./src/utils.js","webpack://TransformationMatrix/./src/isAffineMatrix.js","webpack://TransformationMatrix/./src/translate.js","webpack://TransformationMatrix/./src/transform.js","webpack://TransformationMatrix/./src/rotate.js","webpack://TransformationMatrix/./src/scale.js","webpack://TransformationMatrix/./src/shear.js","webpack://TransformationMatrix/./src/skew.js","webpack://TransformationMatrix/./src/toString.js","webpack://TransformationMatrix/./src/smoothMatrix.js","webpack://TransformationMatrix/./src/fromTriangles.js","webpack://TransformationMatrix/./src/fromDefinition.js","webpack://TransformationMatrix/./src/fromTransformAttribute.autogenerated.js","webpack://TransformationMatrix/./src/fromTransformAttribute.js","webpack://TransformationMatrix/./src/index.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","applyToPoint","matrix","point","Array","isArray","a","e","b","f","x","y","applyToPoints","points","map","fromObject","parseFloat","matrixRegex","fromString","string","parsed","match","length","Error","concat","identity","inverse","denom","isUndefined","val","isNumeric","Number","isNaN","isFinite","isAffineMatrix","_typeof","obj","translate","tx","arguments","undefined","transform","_len","matrices","_key","multiply","m1","m2","_matrices2","_toArray","rest","slice","apply","_toConsumableArray","compose","cos","Math","sin","PI","rotate","angle","cx","cy","cosAngle","sinAngle","rotationMatrix","rotateDEG","scale","sx","sy","shear","shx","shy","tan","skew","ax","ay","skewDEG","toCSS","toString","toSVG","smoothMatrix","precision","round","fromTriangles","t1","t2","px1","py1","px2","py2","qx1","qy1","qx2","qy2","rx1","ry1","rx2","ry2","fromDefinition","definitionOrArrayOfDefinition","mapper","descriptor","type","ty","peg$SyntaxError","message","expected","found","location","this","captureStackTrace","peg$parse","input","options","peg$result","peg$FAILED","peg$startRuleFunctions","transformList","peg$parsetransformList","peg$startRuleFunction","peg$c0","peg$c1","peg$c2","peg$c3","peg$c4","peg$c5","peg$c6","peg$c7","peg$c8","peg$c9","peg$r0","peg$r1","peg$r2","peg$r3","peg$e0","peg$literalExpectation","peg$e1","peg$e2","peg$e3","peg$e4","peg$e5","peg$e6","peg$e7","peg$e8","peg$e9","peg$otherExpectation","peg$e10","peg$classExpectation","peg$e11","peg$e12","peg$e13","peg$f0","ts","peg$f1","peg$f2","peg$f3","peg$f4","peg$f5","peg$f6","peg$f7","peg$f8","join","peg$f9","parseInt","peg$f10","peg$f11","n1","n2","peg$f12","ds","peg$f13","d1","d2","peg$f14","peg$currPos","peg$posDetailsCache","line","column","peg$expected","peg$silentFails","startRule","text","ignoreCase","parts","inverted","description","peg$computePosDetails","pos","details","charCodeAt","peg$VALIDFILENAME","filename","peg$computeLocation","startPos","endPos","loc","startPosDetails","start","offset","endPosDetails","end","peg$expect","top","variants","push","peg$buildStructuredError","buildMessage","s0","s1","s2","s3","s4","peg$parsewsp","peg$parsetransforms","peg$parsetransform","peg$parsecommaWsp","s5","s7","s9","s11","s13","s15","s16","s17","rule$expects","substr","peg$parsenumber","peg$parsematrix","s6","s8","peg$parsecommaWspNumber","peg$parsetranslate","peg$parsescale","peg$parsecommaWspTwoNumbers","peg$parserotate","peg$parseskewX","peg$parseskewY","peg$parsesign","peg$parsedigitSequence","peg$parsefractionalConstant","peg$parseexponent","peg$parsefloatingPointConstant","peg$parseintegerConstant","peg$parsecomma","test","charAt","peg$parsedigit","failPos","peg$buildError","child","parent","C","constructor","peg$subclass","DESCRIBE_EXPECTATION_FNS","literal","expectation","literalEscape","class","escapedParts","part","classEscape","any","other","not","describeExpectation","hex","ch","toUpperCase","replace","j","descriptions","sort","describeExpected","describeFound","fromTransformAttribute","transformString","parse","__webpack_exports__","toString_toString"],"mappings":"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","file":"transformation-matrix.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"TransformationMatrix\"] = factory();\n\telse\n\t\troot[\"TransformationMatrix\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\n * Calculate a point transformed with an affine matrix\n * @param matrix {Matrix} Affine Matrix\n * @param  point {Point} Point\n * @returns {Point} Point\n */\nexport function applyToPoint (matrix, point) {\n  return Array.isArray(point) ? [\n    matrix.a * point[0] + matrix.c * point[1] + matrix.e,\n    matrix.b * point[0] + matrix.d * point[1] + matrix.f\n  ] : {\n    x: matrix.a * point.x + matrix.c * point.y + matrix.e,\n    y: matrix.b * point.x + matrix.d * point.y + matrix.f\n  }\n}\n\n/**\n * Calculate an array of points transformed with an affine matrix\n * @param matrix {Matrix} Affine Matrix\n * @param points {Point[]} Array of point\n * @returns {Point[]} Array of point\n */\nexport function applyToPoints (matrix, points) {\n  return points.map(point => applyToPoint(matrix, point))\n}\n","/**\n * Extract an affine matrix from an object that contains a,b,c,d,e,f keys\n * Any value could be a float or a string that contains a float\n * @param object {Object} Object that contains a,b,c,d,e,f keys\n * @return {Matrix} Affine Matrix\n */\nexport function fromObject (object) {\n  return {\n    a: parseFloat(object.a),\n    b: parseFloat(object.b),\n    c: parseFloat(object.c),\n    d: parseFloat(object.d),\n    e: parseFloat(object.e),\n    f: parseFloat(object.f)\n  }\n}\n","/**\n * @ignore\n * @type {RegExp}\n */\nconst matrixRegex = /^matrix\\(\\s*([0-9_+-.e]+)\\s*,\\s*([0-9_+-.e]+)\\s*,\\s*([0-9_+-.e]+)\\s*,\\s*([0-9_+-.e]+)\\s*,\\s*([0-9_+-.e]+)\\s*,\\s*([0-9_+-.e]+)\\s*\\)$/i\n\n/**\n * Parse a string formatted as matrix(a,b,c,d,e,f)\n * @param string {string} String with an affine matrix\n * @returns {Matrix} Affine Matrix\n *\n * @example\n * > fromString('matrix(1,2,3,4,5,6)')\n * {a: 1, b: 2, c: 3, d: 4, c: 5, e: 6}\n */\nexport function fromString (string) {\n  let parsed = string.match(matrixRegex)\n  if (parsed === null || parsed.length < 7) throw new Error(`'${string}' is not a matrix`)\n  return {\n    a: parseFloat(parsed[1]),\n    b: parseFloat(parsed[2]),\n    c: parseFloat(parsed[3]),\n    d: parseFloat(parsed[4]),\n    e: parseFloat(parsed[5]),\n    f: parseFloat(parsed[6])\n  }\n}\n","/**\n * Identity matrix\n * @returns {Matrix} Affine Matrix\n */\nexport function identity () {\n  return {\n    a: 1,\n    c: 0,\n    e: 0,\n    b: 0,\n    d: 1,\n    f: 0\n  }\n}\n","/**\n * Calculate a matrix that is the inverse of the provided matrix\n * @param matrix {Matrix} Affine Matrix\n * @returns {Matrix} Inverted Affine Matrix\n */\nexport function inverse (matrix) {\n  // http://www.wolframalpha.com/input/?i=Inverse+%5B%7B%7Ba,c,e%7D,%7Bb,d,f%7D,%7B0,0,1%7D%7D%5D\n\n  let { a, b, c, d, e, f } = matrix\n\n  let denom = a * d - b * c\n\n  return {\n    a: d / denom,\n    b: b / -denom,\n    c: c / -denom,\n    d: a / denom,\n    e: (d * e - c * f) / -denom,\n    f: (b * e - a * f) / denom\n  }\n}\n","export function isUndefined (val) {\n  return typeof val === 'undefined'\n}\n\nexport function isNumeric (n) {\n  return typeof n === 'number' &&\n    !Number.isNaN(n) &&\n    Number.isFinite(n)\n}\n\nexport function isObject (obj) {\n  return typeof obj === 'object' &&\n    obj !== null &&\n    !Array.isArray(obj)\n}\n\nexport function matchesShape (obj, keys) {\n  return keys.every(key => key in obj)\n}\n","import { isNumeric, isObject } from './utils'\n\n/**\n * Check if the object contain an affine matrix\n * @param object {Object} Generic Plain Object\n * @return {boolean} True if is an object and contains an affine matrix\n */\n\nexport function isAffineMatrix (object) {\n  return isObject(object) &&\n    object.hasOwnProperty('a') &&\n    isNumeric(object.a) &&\n    object.hasOwnProperty('b') &&\n    isNumeric(object.b) &&\n    object.hasOwnProperty('c') &&\n    isNumeric(object.c) &&\n    object.hasOwnProperty('d') &&\n    isNumeric(object.d) &&\n    object.hasOwnProperty('e') &&\n    isNumeric(object.e) &&\n    object.hasOwnProperty('f') &&\n    isNumeric(object.f)\n}\n","/**\n * Calculate a translate matrix\n * @param tx {number} Translation on axis x\n * @param [ty = 0] {number} Translation on axis y\n * @returns {Matrix} Affine Matrix\n */\nexport function translate (tx, ty = 0) {\n  return {\n    a: 1,\n    c: 0,\n    e: tx,\n    b: 0,\n    d: 1,\n    f: ty\n  }\n}\n","/**\n * Merge multiple matrices into one\n * @param matrices {Matrix[]} Array of affine matrix\n * @returns {Matrix} Affine Matrix\n */\nexport function transform (...matrices) {\n  matrices = Array.isArray(matrices[0]) ? matrices[0] : matrices\n\n  const multiply = (m1, m2) => {\n    return {\n      a: m1.a * m2.a + m1.c * m2.b,\n      c: m1.a * m2.c + m1.c * m2.d,\n      e: m1.a * m2.e + m1.c * m2.f + m1.e,\n      b: m1.b * m2.a + m1.d * m2.b,\n      d: m1.b * m2.c + m1.d * m2.d,\n      f: m1.b * m2.e + m1.d * m2.f + m1.f\n    }\n  }\n\n  switch (matrices.length) {\n    case 0:\n      throw new Error('no matrices provided')\n\n    case 1:\n      return matrices[0]\n\n    case 2:\n      return multiply(matrices[0], matrices[1])\n\n    default:\n      let [m1, m2, ...rest] = matrices\n      let m = multiply(m1, m2)\n      return transform(m, ...rest)\n  }\n}\n\n/**\n * Merge multiple matrices into one\n * @param matrices {Matrix[]} Array of matrix\n * @returns {Matrix} Affine Matrix\n */\nexport function compose (...matrices) {\n  return transform(...matrices)\n}\n","import { isUndefined } from './utils'\nimport { translate } from './translate'\nimport { transform } from './transform'\n\nconst { cos, sin, PI } = Math\n/**\n * Calculate a rotation matrix\n * @param angle {number} Angle in radians\n * @param [cx] {number} If (cx,cy) are supplied the rotate is about this point\n * @param [cy] {number} If (cx,cy) are supplied the rotate is about this point\n * @returns {Matrix} Affine Matrix\n */\nexport function rotate (angle, cx, cy) {\n  let cosAngle = cos(angle)\n  let sinAngle = sin(angle)\n  let rotationMatrix = {\n    a: cosAngle,\n    c: -sinAngle,\n    e: 0,\n    b: sinAngle,\n    d: cosAngle,\n    f: 0\n  }\n  if (isUndefined(cx) || isUndefined(cy)) {\n    return rotationMatrix\n  }\n\n  return transform([\n    translate(cx, cy),\n    rotationMatrix,\n    translate(-cx, -cy)\n  ])\n}\n\n/**\n * Calculate a rotation matrix with a DEG angle\n * @param angle {number} Angle in degree\n * @param [cx] {number} If (cx,cy) are supplied the rotate is about this point\n * @param [cy] {number} If (cx,cy) are supplied the rotate is about this point\n * @returns {Matrix} Affine Matrix\n */\nexport function rotateDEG (angle, cx = undefined, cy = undefined) {\n  return rotate(angle * PI / 180, cx, cy)\n}\n","import { isUndefined } from './utils'\n\n/**\n * Calculate a scaling matrix\n * @param sx {number} Scaling on axis x\n * @param [sy = sx] {number} Scaling on axis y (default sx)\n * @returns {Matrix} Affine Matrix\n */\nexport function scale (sx, sy = undefined) {\n  if (isUndefined(sy)) sy = sx\n  return {\n    a: sx,\n    c: 0,\n    e: 0,\n    b: 0,\n    d: sy,\n    f: 0\n  }\n}\n","/**\n * Calculate a shear matrix\n * @param shx {number} Shear on axis x\n * @param shy {number} Shear on axis y\n * @returns {Matrix} Affine Matrix\n */\nexport function shear (shx, shy) {\n  return {\n    a: 1,\n    c: shx,\n    e: 0,\n    b: shy,\n    d: 1,\n    f: 0\n  }\n}\n","// https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/skew\nconst { tan } = Math\n\n/**\n * Calculate a skew matrix\n * @param ax {number} Skew on axis x\n * @param ay {number} Skew on axis y\n * @returns {Matrix} Affine Matrix\n */\nexport function skew (ax, ay) {\n  return {\n    a: 1,\n    c: tan(ax),\n    e: 0,\n    b: tan(ay),\n    d: 1,\n    f: 0\n  }\n}\n\n/**\n * Calculate a skew matrix using DEG angles\n * @param ax {number} Skew on axis x\n * @param ay {number} Skew on axis y\n * @returns {Matrix} Affine Matrix\n */\nexport function skewDEG (ax, ay) {\n  return skew(ax * Math.PI / 180, ay * Math.PI / 180)\n}\n","/**\n * Serialize an affine matrix to a string that can be used with CSS or SVG\n * @param matrix {Matrix} Affine Matrix\n * @returns {string} String that contains an affine matrix formatted as matrix(a,b,c,d,e,f)\n */\nexport function toCSS (matrix) {\n  return toString(matrix)\n}\n\n/**\n * Serialize an affine matrix to a string that can be used with CSS or SVG\n * @param matrix {Matrix} Affine Matrix\n * @returns {string} String that contains an affine matrix formatted as matrix(a,b,c,d,e,f)\n */\nexport function toSVG (matrix) {\n  return toString(matrix)\n}\n\n/**\n * Serialize an affine matrix to a string that can be used with CSS or SVG\n * @param matrix {Matrix} Affine Matrix\n * @returns {string} String that contains an affine matrix formatted as matrix(a,b,c,d,e,f)\n */\nexport function toString (matrix) {\n  return `matrix(${matrix.a},${matrix.b},${matrix.c},${matrix.d},${matrix.e},${matrix.f})`\n}\n","/**\n * Rounds all elements of the given matrix using the given precision\n * @param matrix {Matrix} An affine matrix to round\n * @param [precision] {number} A precision to use for Math.round. Defaults to 10000000000 (meaning which rounds to the 10th digit after the comma).\n * @returns {Matrix} The rounded Affine Matrix\n */\nexport function smoothMatrix (matrix, precision = 10000000000) {\n  return {\n    a: Math.round(matrix.a * precision) / precision,\n    b: Math.round(matrix.b * precision) / precision,\n    c: Math.round(matrix.c * precision) / precision,\n    d: Math.round(matrix.d * precision) / precision,\n    e: Math.round(matrix.e * precision) / precision,\n    f: Math.round(matrix.f * precision) / precision\n  }\n}\n","import { inverse } from './inverse'\nimport { transform } from './transform'\nimport { smoothMatrix } from './smoothMatrix'\n\n/**\n * Returns a matrix that transforms a triangle t1 into another triangle t2, or throws an exception if it is impossible.\n * @param t1 {Point[]} Array of points containing the three points for the first triangle\n * @param t2 {Point[]} Array of points containing the three points for the second triangle\n * @returns {Matrix} Matrix which transforms t1 to t2\n * @throws Exception if the matrix becomes not invertible\n */\nexport function fromTriangles (t1, t2) {\n  // point p = first point of the triangle\n  let px1 = t1[0].x != null ? t1[0].x : t1[0][0]\n  let py1 = t1[0].y != null ? t1[0].y : t1[0][1]\n  let px2 = t2[0].x != null ? t2[0].x : t2[0][0]\n  let py2 = t2[0].y != null ? t2[0].y : t2[0][1]\n\n  // point q = second point of the triangle\n  let qx1 = t1[1].x != null ? t1[1].x : t1[1][0]\n  let qy1 = t1[1].y != null ? t1[1].y : t1[1][1]\n  let qx2 = t2[1].x != null ? t2[1].x : t2[1][0]\n  let qy2 = t2[1].y != null ? t2[1].y : t2[1][1]\n\n  // point r = third point of the triangle\n  let rx1 = t1[2].x != null ? t1[2].x : t1[2][0]\n  let ry1 = t1[2].y != null ? t1[2].y : t1[2][1]\n  let rx2 = t2[2].x != null ? t2[2].x : t2[2][0]\n  let ry2 = t2[2].y != null ? t2[2].y : t2[2][1]\n\n  let r1 = {\n    a: px1 - rx1,\n    b: py1 - ry1,\n    c: qx1 - rx1,\n    d: qy1 - ry1,\n    e: rx1,\n    f: ry1\n  }\n  let r2 = {\n    a: px2 - rx2,\n    b: py2 - ry2,\n    c: qx2 - rx2,\n    d: qy2 - ry2,\n    e: rx2,\n    f: ry2\n  }\n\n  let inverseR1 = inverse(r1)\n  let affineMatrix = transform([r2, inverseR1])\n\n  // round the matrix elements to smooth the finite inversion\n  return smoothMatrix(affineMatrix)\n}\n","import { fromObject } from './fromObject'\nimport { translate } from './translate'\nimport { scale } from './scale'\nimport { rotateDEG } from './rotate'\nimport { skewDEG } from './skew'\nimport { shear } from './shear'\n\n/**\n * Converts array of matrix descriptor to array of matrix\n * @param definitionOrArrayOfDefinition {Object[]} Array of object describing the matrix\n * @returns {Matrix[]} Array of matrix\n *\n * @example\n * > fromDefinition([\n *  { type: 'matrix', a:1, b:2, c:3, d:4, e:5, f:6 },\n *  { type: 'translate', tx: 10, ty: 20 },\n *  { type: 'scale', sx: 2, sy: 4 },\n *  { type: 'rotate', angle: 90, sx: 50, sy: 25 },\n *  { type: 'skewX', angle: 45 },\n *  { type: 'skewY',  angle: 45 },\n *  { type: 'shear', shx: 10, shy: 20}\n * ])\n *\n * [\n *  { a: 1, b: 2, c: 3, d: 4, e: 5, f: 6 },\n *  { a: 1, c: 0, e: 10, b: 0, d: 1, f: 20 },\n *  { a: 2, c: 0, e: 0, b: 0, d: 4, f: 0 },\n *  { a: 6.123, c: -1, e: 0, b: 1, d: 6.123, f: 0 },\n *  { a: 1, c: 0.99.., e: 0, b: 0, d: 1, f: 0 },\n *  { a: 1, c: 0, e: 0, b: 0.99, d: 1, f: 0 },\n *  { a: 1, c: 10, e: 0, b: 20, d: 1, f: 0 }\n * ]\n **/\nexport function fromDefinition (definitionOrArrayOfDefinition) {\n  return Array.isArray(definitionOrArrayOfDefinition)\n    ? definitionOrArrayOfDefinition.map(mapper)\n    : mapper(definitionOrArrayOfDefinition)\n\n  function mapper (descriptor) {\n    switch (descriptor.type) {\n      case 'matrix':\n        if ('a' in descriptor &&\n          'b' in descriptor &&\n          'c' in descriptor &&\n          'd' in descriptor &&\n          'e' in descriptor &&\n          'f' in descriptor\n        ) {\n          return fromObject(descriptor)\n        } else {\n          throw new Error('MISSING_MANDATORY_PARAM')\n        }\n\n      case 'translate':\n        if (!('tx' in descriptor)) throw new Error('MISSING_MANDATORY_PARAM')\n\n        if ('ty' in descriptor) return translate(descriptor.tx, descriptor.ty)\n\n        return translate(descriptor.tx)\n\n      case 'scale':\n        if (!('sx' in descriptor)) throw new Error('MISSING_MANDATORY_PARAM')\n\n        if ('sy' in descriptor) return scale(descriptor.sx, descriptor.sy)\n\n        return scale(descriptor.sx)\n\n      case 'rotate':\n        if (!('angle' in descriptor)) throw new Error('MISSING_MANDATORY_PARAM')\n\n        if ('cx' in descriptor && 'cy' in descriptor) {\n          return rotateDEG(descriptor.angle, descriptor.cx, descriptor.cy)\n        }\n        return rotateDEG(descriptor.angle)\n\n      case 'skewX':\n        if (!('angle' in descriptor)) throw new Error('MISSING_MANDATORY_PARAM')\n        return skewDEG(descriptor.angle, 0)\n\n      case 'skewY':\n        if (!('angle' in descriptor)) throw new Error('MISSING_MANDATORY_PARAM')\n        return skewDEG(0, descriptor.angle)\n\n      case 'shear':\n        if (!('shx' in descriptor && 'shy' in descriptor)) throw new Error('MISSING_MANDATORY_PARAM')\n        return shear(descriptor.shx, descriptor.shy)\n\n      default:\n        throw new Error('UNSUPPORTED_DESCRIPTOR')\n    }\n  }\n}\n","// Generated by PEG.js v0.11.0-master.30f3260, https://pegjs.org/\n\nfunction peg$subclass(child, parent) {\n  function C() { this.constructor = child; }\n  C.prototype = parent.prototype;\n  child.prototype = new C();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message = message;\n  this.expected = expected;\n  this.found = found;\n  this.location = location;\n  this.name = \"SyntaxError\";\n\n  // istanbul ignore next\n  if (typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n    literal: function(expectation) {\n      return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n    },\n\n    class: function(expectation) {\n      var escapedParts = expectation.parts.map(function(part) {\n        return Array.isArray(part)\n          ? classEscape(part[0]) + \"-\" + classEscape(part[1])\n          : classEscape(part);\n      });\n\n      return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n    },\n\n    any: function() {\n      return \"any character\";\n    },\n\n    end: function() {\n      return \"end of input\";\n    },\n\n    other: function(expectation) {\n      return expectation.description;\n    },\n\n    not: function(expectation) {\n      return \"not \" + describeExpectation(expectation.expected);\n    }\n  };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\"/g,  \"\\\\\\\"\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\\]/g, \"\\\\]\")\n      .replace(/\\^/g, \"\\\\^\")\n      .replace(/-/g,  \"\\\\-\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = expected.map(describeExpectation);\n    var i, j;\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== undefined ? options : {};\n\n  var peg$FAILED = {};\n\n  var peg$startRuleFunctions = { transformList: peg$parsetransformList };\n  var peg$startRuleFunction = peg$parsetransformList;\n\n  var peg$c0 = \"matrix\";\n  var peg$c1 = \"(\";\n  var peg$c2 = \")\";\n  var peg$c3 = \"translate\";\n  var peg$c4 = \"scale\";\n  var peg$c5 = \"rotate\";\n  var peg$c6 = \"skewX\";\n  var peg$c7 = \"skewY\";\n  var peg$c8 = \",\";\n  var peg$c9 = \".\";\n\n  var peg$r0 = /^[eE]/;\n  var peg$r1 = /^[+\\-]/;\n  var peg$r2 = /^[0-9]/;\n  var peg$r3 = /^[ \\t\\r\\n]/;\n\n  var peg$e0 = peg$literalExpectation(\"matrix\", false);\n  var peg$e1 = peg$literalExpectation(\"(\", false);\n  var peg$e2 = peg$literalExpectation(\")\", false);\n  var peg$e3 = peg$literalExpectation(\"translate\", false);\n  var peg$e4 = peg$literalExpectation(\"scale\", false);\n  var peg$e5 = peg$literalExpectation(\"rotate\", false);\n  var peg$e6 = peg$literalExpectation(\"skewX\", false);\n  var peg$e7 = peg$literalExpectation(\"skewY\", false);\n  var peg$e8 = peg$literalExpectation(\",\", false);\n  var peg$e9 = peg$otherExpectation(\"fractionalConstant\");\n  var peg$e10 = peg$classExpectation([\"e\", \"E\"], false, false);\n  var peg$e11 = peg$classExpectation([\"+\", \"-\"], false, false);\n  var peg$e12 = peg$classExpectation([[\"0\", \"9\"]], false, false);\n  var peg$e13 = peg$classExpectation([\" \", \"\\t\", \"\\r\", \"\\n\"], false, false);\n\n  var peg$f0 = function(ts) { return ts; };\n  var peg$f1 = function(t, ts) { return t.concat(ts) };\n  var peg$f2 = function(a, b, c, d, e, f) {\n        return [{type: 'matrix', a: a, b: b, c: c, d: d, e: e, f: f}];\n      };\n  var peg$f3 = function(tx, ty) {\n        var t = {type: 'translate', tx: tx};\n        if (ty) t.ty = ty;\n        return [t];\n      };\n  var peg$f4 = function(sx, sy) {\n        var s = {type:'scale', sx: sx};\n        if (sy) s.sy = sy;\n        return [s];\n      };\n  var peg$f5 = function(angle, c) {\n        var r = {type:'rotate', angle: angle};\n        if (c) {\n          r.cx = c[0];\n          r.cy = c[1];\n        }\n        return [r];\n      };\n  var peg$f6 = function(angle) {\n        return [{type: 'skewX', angle: angle}];\n      };\n  var peg$f7 = function(angle) {\n        return [{type: 'skewY', angle: angle}];\n      };\n  var peg$f8 = function(f) { return parseFloat(f.join(\"\")); };\n  var peg$f9 = function(i) { return parseInt(i.join(\"\")); };\n  var peg$f10 = function(n) { return n; };\n  var peg$f11 = function(n1, n2) { return [n1, n2]; };\n  var peg$f12 = function(ds) { return ds.join(\"\"); };\n  var peg$f13 = function(d1, d2) { return [d1 ? d1.join(\"\") : null, \".\", d2.join(\"\")].join(\"\"); };\n  var peg$f14 = function(d) { return d.join(\"\"); };\n\n  var peg$currPos = 0;\n  var peg$savedPos = 0;\n  var peg$posDetailsCache = [{ line: 1, column: 1 }];\n  var peg$expected = [];\n  var peg$silentFails = 0;\n\n  var peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$savedPos;\n  }\n\n  function range() {\n    return [peg$savedPos, peg$currPos];\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos];\n    var p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n\n      return details;\n    }\n  }\n\n  var peg$VALIDFILENAME = typeof options.filename === \"string\" && options.filename.length > 0;\n  function peg$computeLocation(startPos, endPos) {\n    var loc = {};\n\n    if ( peg$VALIDFILENAME ) loc.filename = options.filename;\n\n    var startPosDetails = peg$computePosDetails(startPos);\n    loc.start = {\n      offset: startPos,\n      line: startPosDetails.line,\n      column: startPosDetails.column\n    };\n\n    var endPosDetails = peg$computePosDetails(endPos);\n    loc.end = {\n      offset: endPos,\n      line: endPosDetails.line,\n      column: endPosDetails.column\n    };\n\n    return loc;\n  }\n\n  function peg$begin() {\n    peg$expected.push({ pos: peg$currPos, variants: [] });\n  }\n\n  function peg$expect(expected) {\n    var top = peg$expected[peg$expected.length - 1];\n\n    if (peg$currPos < top.pos) { return; }\n\n    if (peg$currPos > top.pos) {\n      top.pos = peg$currPos;\n      top.variants = [];\n    }\n\n    top.variants.push(expected);\n  }\n\n  function peg$end(invert) {\n    var expected = peg$expected.pop();\n    var top = peg$expected[peg$expected.length - 1];\n    var variants = expected.variants;\n\n    if (top.pos !== expected.pos) { return; }\n\n    if (invert) {\n      variants = variants.map(function(e) {\n        return e.type === \"not\" ? e.expected : { type: \"not\", expected: e };\n      });\n    }\n\n    Array.prototype.push.apply(top.variants, variants);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$buildError() {\n    var expected = peg$expected[0];\n    var failPos = expected.pos;\n\n    return peg$buildStructuredError(\n      expected.variants,\n      failPos < input.length ? input.charAt(failPos) : null,\n      failPos < input.length\n        ? peg$computeLocation(failPos, failPos + 1)\n        : peg$computeLocation(failPos, failPos)\n    );\n  }\n\n  function peg$parsetransformList() {\n    var s0, s1, s2, s3, s4;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsewsp();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parsewsp();\n    }\n    s2 = peg$parsetransforms();\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    s3 = [];\n    s4 = peg$parsewsp();\n    while (s4 !== peg$FAILED) {\n      s3.push(s4);\n      s4 = peg$parsewsp();\n    }\n    peg$savedPos = s0;\n    s0 = peg$f0(s2);\n\n    return s0;\n  }\n\n  function peg$parsetransforms() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsetransform();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsecommaWsp();\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsecommaWsp();\n        }\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsetransforms();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f1(s1, s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsetransform();\n    }\n\n    return s0;\n  }\n\n  function peg$parsetransform() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$parsematrix();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsetranslate();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsescale();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parserotate();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseskewX();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parseskewY();\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsematrix() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e0);\n    if (input.substr(peg$currPos, 6) === peg$c0) {\n      s1 = peg$c0;\n      peg$currPos += 6;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      rule$expects(peg$e1);\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s3 = peg$c1;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$parsewsp();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parsewsp();\n        }\n        s5 = peg$parsenumber();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parsecommaWsp();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parsenumber();\n            if (s7 !== peg$FAILED) {\n              s8 = peg$parsecommaWsp();\n              if (s8 !== peg$FAILED) {\n                s9 = peg$parsenumber();\n                if (s9 !== peg$FAILED) {\n                  s10 = peg$parsecommaWsp();\n                  if (s10 !== peg$FAILED) {\n                    s11 = peg$parsenumber();\n                    if (s11 !== peg$FAILED) {\n                      s12 = peg$parsecommaWsp();\n                      if (s12 !== peg$FAILED) {\n                        s13 = peg$parsenumber();\n                        if (s13 !== peg$FAILED) {\n                          s14 = peg$parsecommaWsp();\n                          if (s14 !== peg$FAILED) {\n                            s15 = peg$parsenumber();\n                            if (s15 !== peg$FAILED) {\n                              s16 = [];\n                              s17 = peg$parsewsp();\n                              while (s17 !== peg$FAILED) {\n                                s16.push(s17);\n                                s17 = peg$parsewsp();\n                              }\n                              rule$expects(peg$e2);\n                              if (input.charCodeAt(peg$currPos) === 41) {\n                                s17 = peg$c2;\n                                peg$currPos++;\n                              } else {\n                                s17 = peg$FAILED;\n                              }\n                              if (s17 !== peg$FAILED) {\n                                peg$savedPos = s0;\n                                s0 = peg$f2(s5, s7, s9, s11, s13, s15);\n                              } else {\n                                peg$currPos = s0;\n                                s0 = peg$FAILED;\n                              }\n                            } else {\n                              peg$currPos = s0;\n                              s0 = peg$FAILED;\n                            }\n                          } else {\n                            peg$currPos = s0;\n                            s0 = peg$FAILED;\n                          }\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsetranslate() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e3);\n    if (input.substr(peg$currPos, 9) === peg$c3) {\n      s1 = peg$c3;\n      peg$currPos += 9;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      rule$expects(peg$e1);\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s3 = peg$c1;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$parsewsp();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parsewsp();\n        }\n        s5 = peg$parsenumber();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parsecommaWspNumber();\n          if (s6 === peg$FAILED) {\n            s6 = null;\n          }\n          s7 = [];\n          s8 = peg$parsewsp();\n          while (s8 !== peg$FAILED) {\n            s7.push(s8);\n            s8 = peg$parsewsp();\n          }\n          rule$expects(peg$e2);\n          if (input.charCodeAt(peg$currPos) === 41) {\n            s8 = peg$c2;\n            peg$currPos++;\n          } else {\n            s8 = peg$FAILED;\n          }\n          if (s8 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f3(s5, s6);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsescale() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e4);\n    if (input.substr(peg$currPos, 5) === peg$c4) {\n      s1 = peg$c4;\n      peg$currPos += 5;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      rule$expects(peg$e1);\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s3 = peg$c1;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$parsewsp();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parsewsp();\n        }\n        s5 = peg$parsenumber();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parsecommaWspNumber();\n          if (s6 === peg$FAILED) {\n            s6 = null;\n          }\n          s7 = [];\n          s8 = peg$parsewsp();\n          while (s8 !== peg$FAILED) {\n            s7.push(s8);\n            s8 = peg$parsewsp();\n          }\n          rule$expects(peg$e2);\n          if (input.charCodeAt(peg$currPos) === 41) {\n            s8 = peg$c2;\n            peg$currPos++;\n          } else {\n            s8 = peg$FAILED;\n          }\n          if (s8 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f4(s5, s6);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parserotate() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e5);\n    if (input.substr(peg$currPos, 6) === peg$c5) {\n      s1 = peg$c5;\n      peg$currPos += 6;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      rule$expects(peg$e1);\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s3 = peg$c1;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$parsewsp();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parsewsp();\n        }\n        s5 = peg$parsenumber();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parsecommaWspTwoNumbers();\n          if (s6 === peg$FAILED) {\n            s6 = null;\n          }\n          s7 = [];\n          s8 = peg$parsewsp();\n          while (s8 !== peg$FAILED) {\n            s7.push(s8);\n            s8 = peg$parsewsp();\n          }\n          rule$expects(peg$e2);\n          if (input.charCodeAt(peg$currPos) === 41) {\n            s8 = peg$c2;\n            peg$currPos++;\n          } else {\n            s8 = peg$FAILED;\n          }\n          if (s8 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f5(s5, s6);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseskewX() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e6);\n    if (input.substr(peg$currPos, 5) === peg$c6) {\n      s1 = peg$c6;\n      peg$currPos += 5;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      rule$expects(peg$e1);\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s3 = peg$c1;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$parsewsp();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parsewsp();\n        }\n        s5 = peg$parsenumber();\n        if (s5 !== peg$FAILED) {\n          s6 = [];\n          s7 = peg$parsewsp();\n          while (s7 !== peg$FAILED) {\n            s6.push(s7);\n            s7 = peg$parsewsp();\n          }\n          rule$expects(peg$e2);\n          if (input.charCodeAt(peg$currPos) === 41) {\n            s7 = peg$c2;\n            peg$currPos++;\n          } else {\n            s7 = peg$FAILED;\n          }\n          if (s7 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f6(s5);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseskewY() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e7);\n    if (input.substr(peg$currPos, 5) === peg$c7) {\n      s1 = peg$c7;\n      peg$currPos += 5;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      rule$expects(peg$e1);\n      if (input.charCodeAt(peg$currPos) === 40) {\n        s3 = peg$c1;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$parsewsp();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parsewsp();\n        }\n        s5 = peg$parsenumber();\n        if (s5 !== peg$FAILED) {\n          s6 = [];\n          s7 = peg$parsewsp();\n          while (s7 !== peg$FAILED) {\n            s6.push(s7);\n            s7 = peg$parsewsp();\n          }\n          rule$expects(peg$e2);\n          if (input.charCodeAt(peg$currPos) === 41) {\n            s7 = peg$c2;\n            peg$currPos++;\n          } else {\n            s7 = peg$FAILED;\n          }\n          if (s7 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f7(s5);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsenumber() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parsesign();\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    s3 = peg$parsefloatingPointConstant();\n    if (s3 !== peg$FAILED) {\n      s2 = [s2, s3];\n      s1 = s2;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f8(s1);\n    }\n    s0 = s1;\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsesign();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      s3 = peg$parseintegerConstant();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$f9(s1);\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecommaWspNumber() {\n    var s0, s1, s2;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsecommaWsp();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsenumber();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f10(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecommaWspTwoNumbers() {\n    var s0, s1, s2, s3, s4;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsecommaWsp();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsenumber();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecommaWsp();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsenumber();\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f11(s2, s4);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecommaWsp() {\n    var s0, s1, s2, s3, s4;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsewsp();\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsewsp();\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      s3 = [];\n      s4 = peg$parsewsp();\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = peg$parsewsp();\n      }\n      s1 = [s1, s2, s3];\n      s0 = s1;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsecomma();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parsewsp();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parsewsp();\n        }\n        s1 = [s1, s2];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsecomma() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    rule$expects(peg$e8);\n    if (input.charCodeAt(peg$currPos) === 44) {\n      s0 = peg$c8;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseintegerConstant() {\n    var s0, s1;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsedigitSequence();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f12(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsefloatingPointConstant() {\n    var s0, s1, s2;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    s1 = peg$parsefractionalConstant();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseexponent();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      s1 = [s1, s2];\n      s0 = s1;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsedigitSequence();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseexponent();\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsefractionalConstant() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    rule$expects(peg$e9);\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parsedigitSequence();\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s2 = peg$c9;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parsedigitSequence();\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f13(s1, s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parsedigitSequence();\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s2 = peg$c9;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f14(s1);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n    peg$silentFails--;\n\n    return s0;\n  }\n\n  function peg$parseexponent() {\n    var s0, s1, s2, s3;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = peg$currPos;\n    rule$expects(peg$e10);\n    if (peg$r0.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsesign();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      s3 = peg$parsedigitSequence();\n      if (s3 !== peg$FAILED) {\n        s1 = [s1, s2, s3];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesign() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    rule$expects(peg$e11);\n    if (peg$r1.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsedigitSequence() {\n    var s0, s1;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    s0 = [];\n    s1 = peg$parsedigit();\n    if (s1 !== peg$FAILED) {\n      while (s1 !== peg$FAILED) {\n        s0.push(s1);\n        s1 = peg$parsedigit();\n      }\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsedigit() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    rule$expects(peg$e12);\n    if (peg$r2.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsewsp() {\n    var s0;\n\n    var rule$expects = function (expected) {\n      if (peg$silentFails === 0) peg$expect(expected);\n    }\n\n    rule$expects(peg$e13);\n    if (peg$r3.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  peg$begin();\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$expect(peg$endExpectation());\n    }\n\n    throw peg$buildError();\n  }\n}\n\nexport {\n  peg$SyntaxError as SyntaxError,\n  peg$parse as parse\n};\n\nexport default {\n  SyntaxError: peg$SyntaxError,\n  parse: peg$parse\n};\n","import { parse } from './fromTransformAttribute.autogenerated'\n\n/**\n * Parser for SVG Trasform Attribute http://www.w3.org/TR/SVG/coords.html#TransformAttribute <br/>\n * Warning: This should be considered BETA until it is released a stable version of pegjs.\n * @param transformString {string} Transform string as defined by w3 Consortium\n * @returns {Matrix[]} Array of MatrixDescriptor\n *\n * @example\n * > fromTransformAttribute('translate(-10,-10) scale(2,2) translate(10,10)')\n * [\n *  { type: 'translate', tx: -10, ty: -10},\n *  { type: 'scale', sx: 2, sy: 2 },\n *  { type: 'translate', tx: 10, ty: 10}\n * ]\n *\n * > compose(fromDefinition(fromTransformAttribute('translate(-10, -10) scale(10, 10)')))\n * { a: 10, c: 0, e: -10, b: 0, d: 10, f: -10 }\n */\nexport function fromTransformAttribute (transformString) {\n  return parse(transformString)\n}\n","export * from './applyToPoint'\nexport * from './fromObject'\nexport * from './fromString'\nexport * from './identity'\nexport * from './inverse'\nexport * from './isAffineMatrix'\nexport * from './rotate'\nexport * from './scale'\nexport * from './shear'\nexport * from './skew'\nexport * from './toString'\nexport * from './transform'\nexport * from './translate'\nexport * from './fromTriangles'\nexport * from './smoothMatrix'\nexport * from './fromDefinition'\nexport * from './fromTransformAttribute'\n"],"sourceRoot":""}